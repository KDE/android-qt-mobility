<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- organizer.qdoc -->
  <title>Qt 1.1: Organizer</title>
  <link rel="stylesheet" type="text/css" href="style/style.css"
 />  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
 <script src="./scripts/superfish.js" type="text/javascript"></script>
 <script src="./scripts/narrow.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />  <link rel="stylesheet" type="text/css" href="style/narrow.css" /></head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Mobility Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt.nokia.com/developer">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
        <li class="nav-topright-shop"><a title="SHOP" href="http://shop.qt.nokia.com">SHOP</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Mobility 1.1</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL Qt VERSIONS        </a></li>
      </ul>
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="index.html#platform-compatibility">Platform Compatibility</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/">Qt 4.7</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/declarativeui.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li>Organizer</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3>Contents</h3>
<ul>
<li class="level1"><a href="#namespace">Namespace</a></li>
<li class="level1"><a href="#introduction">Introduction</a></li>
<li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#client-facing-api">Client-Facing API</a></li>
<li class="level2"><a href="#container-classes">Container Classes</a></li>
<li class="level3"><a href="#item"><b>Item</b></a></li>
<li class="level3"><a href="#detail"><b>Detail</b></a></li>
<li class="level3"><a href="#detail-definition"><b>Detail Definition</b></a></li>
<li class="level2"><a href="#manager">Manager</a></li>
<li class="level3"><a href="#meta-data-api"><b>Meta Data API</b></a></li>
<li class="level3"><a href="#asynchronous-api"><b>Asynchronous API</b></a></li>
<li class="level3"><a href="#synchronous-api"><b>Synchronous API</b></a></li>
<li class="level1"><a href="#non-client-facing-api">Non-Client-Facing API</a></li>
<li class="level2"><a href="#manager-engine">Manager Engine</a></li>
<li class="level1"><a href="#on-going-development">On-going Development</a></li>
<li class="level2"><a href="#multiple-calendar-support">Multiple Calendar Support</a></li>
<li class="level2"><a href="#timezone-support">Timezone Support</a></li>
<li class="level2"><a href="#result-pagination">Result Pagination</a></li>
<li class="level2"><a href="#all-day-and-multiple-day-event-support">All-day and Multiple-day Event Support</a></li>
<li class="level1"><a href="#using-the-api">Using the API</a></li>
<li class="level1"><a href="#building-and-compiling">Building and compiling</a></li>
<li class="level1"><a href="#reference-documentation">Reference documentation</a></li>
<li class="level2"><a href="#main-classes">Main classes</a></li>
<li class="level2"><a href="#organizer-item-details-leaf-classes">&quot;Organizer Item Details&quot; Leaf Classes</a></li>
<li class="level2"><a href="#asynchronous-requests">Asynchronous Requests</a></li>
<li class="level2"><a href="#organizer-item-selection-and-sorting">Organizer Item Selection And Sorting</a></li>
<li class="level2"><a href="#implementing-backends">Implementing Backends</a></li>
<li class="level2"><a href="#synchronization-and-serialization">Synchronization and Serialization</a></li>
<li class="level2"><a href="#examples">Examples</a></li>
</ul>
</div>
<h1 class="title">Organizer</h1>
<span class="subtitle"></span>
<div class="descr"/>
<p>The Organizer API enables a client to request calendar, schedule and personal data from local or remote backends. This is part of the Qt Mobility Project.</p>
<p><b>Note:</b> This API and documentation is a <b>Technology Preview</b> and is still subject to change.</p>
<a name="namespace"></a>
<h2>Namespace</h2>
<p>The QtMobility APIs are placed into the <i>QtMobility</i> namespace. This is done to facilitate the future migration of Mobility APIs into Qt. See the <a href="quickstart.html">Quickstart guide</a> for an example on how the namespace impacts on application development.</p>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>The Organizer API provides clients with the ability to access calendar, schedule and personal data in a platform-independent and datastore-agnostic manner. This is achieved by defining generic personal information data abstractions which can sufficiently describe calendar and scheduling data stored on any platform. Due to the cross-platform nature of the API, and the ability for developers to write platform-independent implementations of a <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> which may unify one or more platform-specific calendar or scheduling backends, it is intended that the semantics and quirks of the underlying datastores on any platform may be entirely opaque from the perspective of Qt-based, cross-platform client applications.</p>
<a name="overview"></a>
<h2>Overview</h2>
<p>The QtMobility APIs are placed into the <i>QtMobility</i> namespace. This is done to facilitate the future migration of Mobility APIs into Qt. See the <a href="quickstart.html">Quickstart guide</a> for an example on how the namespace impacts on application development.</p>
<p>Organizer information is stored in datastores whose functionality is exposed via a <a href="qorganizeritemmanager.html">manager</a>. The Organizer API models organizer information as an <a href="qorganizeritem.html">item</a> which consists of a collection of distinct details. Each <a href="qorganizeritemdetail.html">detail</a> conforms to a particular <a href="qorganizeritemdetaildefinition.html">definition</a> (or template), which may be extensible or otherwise modifiable by clients. Individual organizer items may be recurrent, and occurrences of such items are also items, but are linked to the &quot;parent&quot; item.</p>
<p><a href="qorganizeritem.html">Item</a> and <a href="qorganizeritemdetaildefinition.html">detail definition</a> information may be retrieved, modified or deleted by clients using either <a href="itemssync.html">synchronous</a> or <a href="organizerasync.html">asynchronous</a> API.</p>
<a name="client-facing-api"></a>
<h2>Client-Facing API</h2>
<p>The client-facing API allows retrieval, modification and deletion of organizer items and detail definitions, and access to manager meta data and capability reporting.</p>
<a name="container-classes"></a>
<h3>Container Classes</h3>
<p>Organizational data is stored in container (value) classes. These classes are not derived from QObject, and hence can be used in lists, do not have parents, do not emit signals, and so on. They represent data which may be manipulated and retrieved from a <a href="qorganizeritemmanager.html">manager</a>.</p>
<a name="item"></a>
<h4><b>Item</b></h4>
<p>An <a href="qorganizeritem.html">item</a> is the digital representation of an event, journal, todo, or note which is stored in a platform-specific manner. Information pertaining to a single item may be located across several different datastores.</p>
<p>Each item stored in a manager is identified by an <a href="qorganizeritemid.html">id</a> which consists of a manager identifier (URI) and the <a href="qorganizeritemid.html#QOrganizerItemLocalId-typedef">manager-local id</a> which is used to identify the item within that manager. Note that an item stored in one manager may have the same local id as a different item stored in another manager; please see the <a href="qorganizeritemid.html">QOrganizerItemId</a> documentation for more information.</p>
<a name="detail"></a>
<h4><b>Detail</b></h4>
<p>A <a href="qorganizeritemdetail.html">detail</a> is a single, cohesive unit of information that is stored in an item. Any detail stored in an item which is saved in a manager will conform to a particular detail definition which that manager supports. A detail may have specific meta-data associated with it, such as its sub-type and arbitrary, user-defined meta-data, as well as access constraints which may apply to the detail (e.g&#x2e;, read-only, irremovable, etc).</p>
<p>There are a number of common details defined in the API which are intended for use by clients, as listed <a href="#organizer-item-details-leaf-classes">here</a>.</p>
<a name="detail-definition"></a>
<h4><b>Detail Definition</b></h4>
<p>Each detail stored in an item has defined semantics of usage and storage. The Qt Organizer API allows per-datastore organizer item <a href="qorganizeritemdetaildefinition.html">detail definitions</a>, allowing a manager to provide clients with this information on demand, and allowing third-party developers to register detail definitions for use by clients. A detail definition includes the fields (and value-types of those fields) which make up the detail, and per-item uniqueness constraints on details of the definition.</p>
<p>Most clients can safely ignore this class entirely, since they will most likely want to use the predefined details listed <a href="#organizer-item-details-leaf-classes">here</a>. In some cases, however, a manager will not support all of the fields of a particular predefined detail leaf class; in that case, it may be necessary for the client to inspect the supported detail definition for that leaf class and modify its behavior accordingly.</p>
<a name="manager"></a>
<h3>Manager</h3>
<p>Access to organizer items is provided by implementations of the Qt Organizer <a href="qorganizeritemmanager.html">manager</a> API. A manager provides access to zero or more platform-specific datastores. Each datastore may support different capabilities (for example, the ability to store certain datatypes, the ability to natively filter on different details or details of different definitions, the provision of locking mechanisms, the provision of changelog information, etc) which are reported by the manager on request. The manager therefore provides access to detail definitions and organizer items stored in different datastores, in a platform and datastore independent manner.</p>
<a name="meta-data-api"></a>
<h4><b>Meta Data API</b></h4>
<p>The API offered by the <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> exposes functionality which is implemented by plugins. These plugins may be platform specific, and may be provided by Nokia or by third party developers. As described above, each plugin will have different capabilities and implement the functionality exposed by the Qt Organizer API to a different degree.</p>
<p>The <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> class provides a static function <a href="qorganizeritemmanager.html#availableManagers">QOrganizerItemManager::availableManagers</a>() which allows clients of the API to determine (at run time) which plugins (managers) are available for use.</p>
<p>Clients of the API also need to be able to determine (at run time) what the capabilities of a given plugin (organizer item manager) are. The <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> class provides API to query the capabilities of a given manager with the following synchronous functions:</p>
<ul>
<li>hasFeature(<a href="qorganizeritemmanager.html#ManagerFeature-enum">QOrganizerItemManager::ManagerFeature</a> feature, const QString&amp; itemType = <a href="qorganizeritemtype.html#TypeEvent-var">QOrganizerItemType::TypeEvent</a>) const</li>
<li>isFilterSupported(const <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a>&amp; filter) const</li>
<li>supportedDataTypes() const</li>
<li>supportedItemTypes() const</li>
</ul>
<p>A given manager is identified by its URI. The URI consists of the manager's name, any relevant parameters which were used during instantiation of the manager, and the version of the manager. While the name of the manager identifies the plugin which provides the functionality, you cannot guarantee that the data available through one manager will be available through another with the same name (for example, if one parameter tells the plugin to store and retrieve organizer information from a particular online service or local file).</p>
<p>The synchronous API offered to allow run-time querying of a manager's metadata includes:</p>
<ul>
<li>managerName() const</li>
<li>managerParameters() const</li>
<li>managerUri() const</li>
<li>managerVersion() const;</li>
<li>(static) parseUri(const QString&amp; uri, QString* managerName, QMap&lt;QString, QString&gt;* params)</li>
<li>(static) buildUri(const QString&amp; managerName, const QMap&lt;QString, QString&gt;&amp; params, int implementationVersion = -1)</li>
</ul>
<p>The functionality that the above functions provide is only available through synchronous API.</p>
<a name="asynchronous-api"></a>
<h4><b>Asynchronous API</b></h4>
<p>The asynchronous API provides a way to access or modify the organizer item information managed by a particular backend via non-blocking, asynchronous requests. It is recommended for most applications that the asynchronous API be used where possible.</p>
<p>The asynchronous API is offered through various classes derived from the <a href="qorganizeritemabstractrequest.html">QOrganizerItemAbstractRequest</a> class, including <a href="qorganizeritemlocalidfetchrequest.html">QOrganizerItemLocalIdFetchRequest</a>, <a href="qorganizeritemfetchrequest.html">QOrganizerItemFetchRequest</a>, <a href="qorganizeritemsaverequest.html">QOrganizerItemSaveRequest</a>, <a href="qorganizeritemremoverequest.html">QOrganizerItemRemoveRequest</a>, <a href="qorganizeritemdetaildefinitionfetchrequest.html">QOrganizerItemDetailDefinitionFetchRequest</a>, <a href="qorganizeritemdetaildefinitionsaverequest.html">QOrganizerItemDetailDefinitionSaveRequest</a>, and <a href="qorganizeritemdetaildefinitionremoverequest.html">QOrganizerItemDetailDefinitionRemoveRequest</a>.</p>
<p>The asynchronous API allows manipulation of <a href="qorganizeritem.html">items</a> and <a href="qorganizeritemdetaildefinition.html">schema definitions</a>, but does not provide manager capability or meta data information reporting.</p>
<p>For more detailed documentation on the asynchronous API, see the <a href="organizerasync.html">Organizer Asynchronous API</a>.</p>
<a name="synchronous-api"></a>
<h4><b>Synchronous API</b></h4>
<p>The synchronous API provides the simplest way to access or modify the organizer item information managed by a particular backend. It has the disadvantage that calls block the current thread of execution until completion and is therefore most suitable only for applications which interact with local, high-speed datastores, or for applications which do not require a responsive user interface.</p>
<p>The synchronous API is offered through the <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> class, and includes manipulation of <a href="qorganizeritem.html">items</a> and <a href="qorganizeritemdetaildefinition.html">schema definitions</a>. As previously described, the meta data reporting and manipulation functions are also provided via synchronous API only.</p>
<p>For more detailed documentation on the synchronous API, see the <a href="itemssync.html">Organizer Synchronous API</a>.</p>
<a name="non-client-facing-api"></a>
<h2>Non-Client-Facing API</h2>
<p>The non-client-facing API allows third party developers to implement a manager engine plugin from which clients may request data.</p>
<a name="manager-engine"></a>
<h3>Manager Engine</h3>
<p>The functionality exposed by the <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> class may be implemented by <a href="qorganizeritemmanagerengine.html">engine</a> plugins which interface directly to a platform-specific backend or provide their own data storage backend. As such, the terms &quot;manager&quot;, &quot;plugin&quot; and &quot;backend&quot; are used interchangeably in this documentation to refer to any engine plugin which implements the functionality exposed by the <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> interface. The plugin architecture allows dynamic loading of different manager engines at runtime.</p>
<p>A manager backend may be implemented by subclassing <a href="qorganizeritemmanagerengine.html">QOrganizerItemManagerEngine</a>, and providing a <a href="qorganizeritemmanagerenginefactory.html">QOrganizerItemManagerEngineFactory</a> which can instantiate it when required.</p>
<p>See <a href="organizerengines.html">Qt Organizer Manager Engines</a> for more information on available engines and how to write your own engine.</p>
<a name="on-going-development"></a>
<h2>On-going Development</h2>
<p>There are several areas of API which are actively being developed, which are not included in the Technical Preview. These include:</p>
<ul>
<li>Multiple Calendar Support</li>
<li>Timezone Support</li>
<li>Result Pagination Support</li>
<li>All-day and Multiple-day Event Support</li>
</ul>
<p>Each of these areas is complex and may have important ramifications to related areas of the API, and so are discussed separately below.</p>
<a name="multiple-calendar-support"></a>
<h3>Multiple Calendar Support</h3>
<p>One aspect of the Qt Mobility Organizer API which is still under discussion and active development is the ability to support multiple &quot;calendars&quot; for different contexts. Currently, no API is offered to support multiple calendars. It is still undecided how multiple calendars should be supported by the API (some possibilities, in no particular order, include: each calendar is modeled as a separate manager; each calendar is modeled as a top-level item, and API for manipulating these calendars is offered via <a href="qorganizeritemmanager.html">QOrganizerItemManager</a> and through various subclasses of <a href="qorganizeritemabstractrequest.html">QOrganizerItemAbstractRequest</a>; calendars are supported only as a QOrganizerItemTag detail in each item; etc).</p>
<p>The semantics of events stored in multiple calendars is also under discussion. Multiple calendar support has the potential to introduce possibly confusing semantics (for example: sharing of event data versus duplication of event data) and so we need to carefully consider how current calendar and scheduling backends work, in order to determine what is technically feasible and what is most intuitive for the application developer, before mandating some particular set of semantics related to multiple calendar support.</p>
<a name="timezone-support"></a>
<h3>Timezone Support</h3>
<p>A critical part of the API which is still under development is support for different time zones. In general, dates are considered to be timezone-independent (that is, floating dates), whereas datetimes should include timezone information. The exact manner in which timezone information should be offered to clients in the API is still under discussion.</p>
<p>One possible solution would be to offer a QOrganizerTimezone class which provides API to allow clients to transform a particular datetime into another datetime in a different timezone. A more complete solution might be to add timezone support to QDateTime directly, however this would require extensive modifications to Qt and so may not be possible due to technical reasons (e.g&#x2e;, binary compatibility promises, release scheduling, etc).</p>
<a name="result-pagination"></a>
<h3>Result Pagination</h3>
<p>Often, clients will want a single &quot;page&quot; of results from a single filtering operation at a time. The advantage of an API to allow this is that memory use decreases, and results may be returned faster (since there are less of them to instantiate).</p>
<p>We see two main use cases for pagination:</p>
<ul>
<li>Limiting results to a single offset plus a count</li>
<li>Limiting results to a single count (implied offset of zero)</li>
</ul>
<p>The first is more general, and support on some platforms is limited or even non-existent. Emulation of such a feature obviates any potential benefits which might be derived from offering the API in the first place (as emulating the feature would use more memory and be less performant that simply returning all results of the filtering operation). Paging of results is possible to achieve manually using the current API (by retrieving a list of ids, and then manually retrieving pages of items manually by id) but may be suboptimal.</p>
<p>The second is supported on most platforms, and is the more common use case. It may be implemented by extending <a href="qorganizeritemfetchhint.html">QOrganizerItemFetchHint</a> to include a maximum count parameter, which may be ignored by backends if the backend does not support the feature.</p>
<p>In short, discussion about result pagination is still on-going, as it is a complex topic with far-reaching ramifications given that we must maintain consistency between the various modules of the Qt Mobility project.</p>
<a name="all-day-and-multiple-day-event-support"></a>
<h3>All-day and Multiple-day Event Support</h3>
<p>Several options for supporting all-day and multiple-day events have been considered. One possible method of supporting all-day events is to allow the start date time of the event to be set to a date without a time component, while another might be to explicitly set the start and end date times to cover an entire 24 hour period (the currently supported solution). We envision that multiple-day events will be supported in the same manner as all-day events.</p>
<p>Finally, the way in which all-day and multiple-day events are supported may depend on the way in which timezone support is implemented. As such, this aspect of the API will be considered iteratively as support for timezone information matures.</p>
<a name="using-the-api"></a>
<h2>Using the API</h2>
<p>Some examples of common usage of the API may be found <a href="organizerusage.html">here</a>.</p>
<a name="building-and-compiling"></a>
<h2>Building and compiling</h2>
<p>This library requires Qt 4.6 to be installed.</p>
<p>To build the library, see the Qt Mobility installation instructions.</p>
<a name="reference-documentation"></a>
<h2>Reference documentation</h2>
<a name="main-classes"></a>
<h3>Main classes</h3>
<table class="annotated">
<tr class="odd topAlign"><td><p><a href="qorganizeritem.html">QOrganizerItem</a></p></td><td><p>Represents an event, todo, note, or journal entry</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemabstractrequest.html">QOrganizerItemAbstractRequest</a></p></td><td><p>Mechanism for asynchronous requests to be made of a manager if it supports them</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemdetail.html">QOrganizerItemDetail</a></p></td><td><p>Represents a single, complete detail about an organizer item</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemfilter.html">QOrganizerItemFilter</a></p></td><td><p>Used to select organizer items made available through a QOrganizerItemManager</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemmanager.html">QOrganizerItemManager</a></p></td><td><p>Interface which allows clients with access to organizer item information stored in a particular backend</p></td></tr>
</table>
<a name="organizer-item-details-leaf-classes"></a>
<h3>&quot;Organizer Item Details&quot; Leaf Classes</h3>
<p>Several subclasses of <a href="qorganizeritemdetail.html">QOrganizerItemDetail</a> are provided as part of the Qt Mobility Organizer API. They are general in design but are intended to fulfill specific use-cases. Please note that certain backends may choose not to support one or more of these subclasses as they appear here; they may offer their own which provide similar functionality.</p>
<table class="annotated">
<tr class="odd topAlign"><td><p><a href="qorganizereventtimerange.html">QOrganizerEventTimeRange</a></p></td><td><p>Contains the start and end dates and times of a recurring event series, or occurrence of an event</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemcomment.html">QOrganizerItemComment</a></p></td><td><p>Contains some arbitrary information which is relevant to the organizer item</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemdescription.html">QOrganizerItemDescription</a></p></td><td><p>Contains some arbitrary information which is relevant to the organizer item</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemdisplaylabel.html">QOrganizerItemDisplayLabel</a></p></td><td><p>Contains the backend-synthesized display label of the organizer item</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemguid.html">QOrganizerItemGuid</a></p></td><td><p>Contains the globally unique identifier of the organizer item, which can be used for synchronization purposes</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeriteminstanceorigin.html">QOrganizerItemInstanceOrigin</a></p></td><td><p>Contains information about when and from where or whom the organizer item originated</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemlocation.html">QOrganizerItemLocation</a></p></td><td><p>Contains information about a location which is related to the organizer item in some manner</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritempriority.html">QOrganizerItemPriority</a></p></td><td><p>Contains the priority of the organizer item, which may be used to resolve scheduling conflicts</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemrecurrence.html">QOrganizerItemRecurrence</a></p></td><td><p>Contains a list of rules and dates on which the recurrent item occurs, and a list of rules and dates on which exceptions occur</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemtimestamp.html">QOrganizerItemTimestamp</a></p></td><td><p>Contains the creation and last-modified timestamp associated with the organizer item. XXX TODO: what about last accessed?</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemtype.html">QOrganizerItemType</a></p></td><td><p>Describes the type of the organizer item. This detail may be automatically synthesized by the backend depending on other details in the organizer item</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizerjournaltimerange.html">QOrganizerJournalTimeRange</a></p></td><td><p>Contains information about the date and time for which a journal entry has been created</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizertodoprogress.html">QOrganizerTodoProgress</a></p></td><td><p>Contains information about the progress of a todo item</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizertodotimerange.html">QOrganizerTodoTimeRange</a></p></td><td><p>Contains information about the time range of a todo item</p></td></tr>
</table>
<p>Each of these subclasses provide access to information stored in fields which may have certain constraints, as listed in the <a href="organizerschema.html">schema</a>.</p>
<a name="asynchronous-requests"></a>
<h3>Asynchronous Requests</h3>
<p>Clients may use either the <a href="itemssync.html">synchronous</a> or <a href="organizerasync.html">asynchronous</a> API to access functionality provided by a manager backend. The <a href="organizerasync.html">asynchronous</a> API is offered through subclasses of the <a href="qorganizeritemabstractrequest.html">QOrganizerItemAbstractRequest</a> class:</p>
<table class="annotated">
<tr class="odd topAlign"><td><p><a href="qorganizeritemdetaildefinitionfetchrequest.html">QOrganizerItemDetailDefinitionFetchRequest</a></p></td><td><p>Allows a client to asynchronously request detail definitions from an organizer item store manager</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemdetaildefinitionremoverequest.html">QOrganizerItemDetailDefinitionRemoveRequest</a></p></td><td><p>Allows a client to asynchronously request that certain detail definitions be removed from an organizer item manager</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemdetaildefinitionsaverequest.html">QOrganizerItemDetailDefinitionSaveRequest</a></p></td><td><p>Allows a client to asynchronously request that certain detail definitions be saved in an organizer item store manager</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemfetchrequest.html">QOrganizerItemFetchRequest</a></p></td><td><p>Allows a client to asynchronously request organizer items from an organizer item store manager</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeriteminstancefetchrequest.html">QOrganizerItemInstanceFetchRequest</a></p></td><td><p>Allows a client to asynchronously request organizer item instances (occurrences) from an organizer item store manager</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemlocalidfetchrequest.html">QOrganizerItemLocalIdFetchRequest</a></p></td><td><p>Allows a client to asynchronously request a list of organizer item ids from a organizer item store manager</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemremoverequest.html">QOrganizerItemRemoveRequest</a></p></td><td><p>Allows a client to asynchronously request that certain organizer items be removed from a organizer items store</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemsaverequest.html">QOrganizerItemSaveRequest</a></p></td><td><p>Allows a client to asynchronously request that certain organizer items be saved to an organizer item store</p></td></tr>
</table>
<a name="organizer-item-selection-and-sorting"></a>
<h3>Organizer Item Selection And Sorting</h3>
<p>Clients may select an organizer item by specifying a unique item id, or by supplying a <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> which matches the item or items they wish to select. The various derivatives of <a href="qorganizeritemfilter.html">QOrganizerItemFilter</a> allow for fine-grained and flexible selection of organizer data according to various criteria:</p>
<table class="annotated">
<tr class="odd topAlign"><td><p><a href="qorganizeritemchangelogfilter.html">QOrganizerItemChangeLogFilter</a></p></td><td><p>Filter based around a organizer item timestamp criterion</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemdatetimeperiodfilter.html">QOrganizerItemDateTimePeriodFilter</a></p></td><td><p>Filter based around a datetime period between start and end datetime</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemdetailfilter.html">QOrganizerItemDetailFilter</a></p></td><td><p>Filter based around a detail value criterion</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemdetailrangefilter.html">QOrganizerItemDetailRangeFilter</a></p></td><td><p>Filter based around a detail value range criterion</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemintersectionfilter.html">QOrganizerItemIntersectionFilter</a></p></td><td><p>Filter which intersects the results of other filters</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeriteminvalidfilter.html">QOrganizerItemInvalidFilter</a></p></td><td><p>Matches no organizeritems</p></td></tr>
<tr class="odd topAlign"><td><p><a href="qorganizeritemlocalidfilter.html">QOrganizerItemLocalIdFilter</a></p></td><td><p>Filter based around a list of organizer item ids</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemunionfilter.html">QOrganizerItemUnionFilter</a></p></td><td><p>Filter which unions the results of other filters</p></td></tr>
</table>
<p>A client can also request that the results of such a selection be sorted, by passing a <a href="qorganizeritemsortorder.html">QOrganizerItemSortOrder</a> (or list of sort orders) to the manager.</p>
<a name="implementing-backends"></a>
<h3>Implementing Backends</h3>
<p>A backend implementor must implement the following interfaces:</p>
<table class="annotated">
<tr class="odd topAlign"><td><p><a href="qorganizeritemmanagerengine.html">QOrganizerItemManagerEngine</a></p></td><td><p>The interface for all implementations of the organizer item manager backend functionality</p></td></tr>
<tr class="even topAlign"><td><p><a href="qorganizeritemmanagerenginefactory.html">QOrganizerItemManagerEngineFactory</a></p></td><td><p>The interface for plugins that implement QOrganizerItemManagerEngine functionality</p></td></tr>
</table>
<p>For more information on this topic, see please see the documentation on <a href="organizerengines.html">implementing manager engines</a>.</p>
<a name="synchronization-and-serialization"></a>
<h3>Synchronization and Serialization</h3>
<p>The organizer API is used by another Qt Mobility module: the <a href="versit.html">Versit</a>* module. It allows serialization of a <a href="qorganizeritem.html">QOrganizerItem</a> into an iCalendar document, and vice versa.</p>
<p>[*] Versit <sup>&reg;</sup> is a trademark of the Internet Mail Consortium.</p>
<a name="examples"></a>
<h3>Examples</h3>
<p>The following sample applications show examples of API usage:</p>
<ul>
<li><a href="calendardemo.html">Example Calendar Application</a></li>
</ul>
<p>See <a href="organizerusage.html">Organizer API Usage</a> for more examples of API usage.</p>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009-2010 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.1.0</div></td>
</tr></table></div></address>  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
