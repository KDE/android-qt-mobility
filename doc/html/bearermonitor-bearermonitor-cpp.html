<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt Mobility Project 1.0: bearermonitor.cpp Example File (bearermonitor/bearermonitor.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">bearermonitor.cpp Example File<br /><span class="small-subtitle">bearermonitor/bearermonitor.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;bearermonitor.h&quot;
    #include &quot;sessionwidget.h&quot;

    #include &lt;QDebug&gt;

    #ifdef Q_OS_WIN
    #include &lt;winsock2.h&gt;
    #undef interface

    #ifndef NS_NLA
    #define NS_NLA 15
    #endif
    #endif

    BearerMonitor::BearerMonitor(QWidget *parent)
    :   QWidget(parent)
    {
        setupUi(this);
        delete tabWidget-&gt;currentWidget();
        sessionGroup-&gt;hide();
    #if defined (Q_OS_SYMBIAN) || defined(Q_OS_WINCE)
        setWindowState(Qt::WindowMaximized);
    #endif
        updateConfigurations();

        onlineStateChanged(!manager.allConfigurations(QNetworkConfiguration::Active).isEmpty());

        QNetworkConfiguration defaultConfiguration = manager.defaultConfiguration();
        for (int i = 0; i &lt; treeWidget-&gt;topLevelItemCount(); ++i) {
            QTreeWidgetItem *item = treeWidget-&gt;topLevelItem(i);

            if (item-&gt;data(0, Qt::UserRole).toString() == defaultConfiguration.identifier()) {
                treeWidget-&gt;setCurrentItem(item);
                showConfigurationFor(item);
                break;
            }
        }

        connect(&amp;manager, SIGNAL(configurationAdded(const QNetworkConfiguration&amp;)),
                this, SLOT(configurationAdded(const QNetworkConfiguration&amp;)));
        connect(&amp;manager, SIGNAL(configurationRemoved(const QNetworkConfiguration&amp;)),
                this, SLOT(configurationRemoved(const QNetworkConfiguration&amp;)));
        connect(&amp;manager, SIGNAL(configurationChanged(const QNetworkConfiguration&amp;)),
                this, SLOT(configurationChanged(const QNetworkConfiguration)));
        connect(&amp;manager, SIGNAL(updateCompleted()), this, SLOT(updateConfigurations()));
        connect(&amp;manager, SIGNAL(onlineStateChanged(bool)), this ,SLOT(onlineStateChanged(bool)));

    #ifdef Q_OS_WIN
        connect(registerButton, SIGNAL(clicked()), this, SLOT(registerNetwork()));
        connect(unregisterButton, SIGNAL(clicked()), this, SLOT(unregisterNetwork()));
    #else
        nlaGroup-&gt;hide();
    #endif

        connect(treeWidget, SIGNAL(itemActivated(QTreeWidgetItem*,int)),
                this, SLOT(createSessionFor(QTreeWidgetItem*)));

        connect(treeWidget, SIGNAL(currentItemChanged(QTreeWidgetItem*,QTreeWidgetItem*)),
                this, SLOT(showConfigurationFor(QTreeWidgetItem*)));

        connect(newSessionButton, SIGNAL(clicked()),
                this, SLOT(createNewSession()));
        connect(deleteSessionButton, SIGNAL(clicked()),
                this, SLOT(deleteSession()));

        connect(scanButton, SIGNAL(clicked()),
                this, SLOT(performScan()));
    }

    BearerMonitor::~BearerMonitor()
    {
    }

    static void updateItem(QTreeWidgetItem *item, const QNetworkConfiguration &amp;config)
    {
        item-&gt;setText(0, config.name());
        item-&gt;setData(0, Qt::UserRole, config.identifier());

        QFont font = item-&gt;font(1);
        font.setBold((config.state() &amp; QNetworkConfiguration::Active) == QNetworkConfiguration::Active);
        item-&gt;setFont(0, font);
    }

    void BearerMonitor::configurationAdded(const QNetworkConfiguration &amp;config, QTreeWidgetItem *parent)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem;
        updateItem(item, config);

        if (parent)
            parent-&gt;addChild(item);
        else
            treeWidget-&gt;addTopLevelItem(item);

        if (config.type() == QNetworkConfiguration::ServiceNetwork) {
            foreach (const QNetworkConfiguration &amp;child, config.children())
                configurationAdded(child, item);
        }
    }

    void BearerMonitor::configurationRemoved(const QNetworkConfiguration &amp;config)
    {
        for (int i = 0; i &lt; treeWidget-&gt;topLevelItemCount(); ++i) {
            QTreeWidgetItem *item = treeWidget-&gt;topLevelItem(i);

            if (item-&gt;data(0, Qt::UserRole).toString() == config.identifier()) {
                delete item;
                break;
            }
        }
    }

    void BearerMonitor::configurationChanged(const QNetworkConfiguration &amp;config)
    {
        for (int i = 0; i &lt; treeWidget-&gt;topLevelItemCount(); ++i) {
            QTreeWidgetItem *item = treeWidget-&gt;topLevelItem(i);

            if (item-&gt;data(0, Qt::UserRole).toString() == config.identifier()) {
                updateItem(item, config);

                if (config.type() == QNetworkConfiguration::ServiceNetwork)
                    updateSnapConfiguration(item, config);

                if (item == treeWidget-&gt;currentItem())
                    showConfigurationFor(item);

                break;
            }
        }
    }

    void BearerMonitor::updateSnapConfiguration(QTreeWidgetItem *parent, const QNetworkConfiguration &amp;snap)
    {
        QMap&lt;QString, QTreeWidgetItem *&gt; itemMap;
        for (int i = 0; i &lt; parent-&gt;childCount(); ++i) {
            QTreeWidgetItem *item = parent-&gt;child(i);
            itemMap.insert(item-&gt;data(0, Qt::UserRole).toString(), item);
        }

        QList&lt;QNetworkConfiguration&gt; allConfigurations = snap.children();

        while (!allConfigurations.isEmpty()) {
            QNetworkConfiguration config = allConfigurations.takeFirst();

            QTreeWidgetItem *item = itemMap.take(config.identifier());
            if (item) {
                updateItem(item, config);

                if (config.type() == QNetworkConfiguration::ServiceNetwork)
                    updateSnapConfiguration(item, config);
            } else {
                configurationAdded(config, parent);
            }
        }

        foreach (const QString &amp;id, itemMap.keys())
            delete itemMap.value(id);

        itemMap.clear();
    }

    void BearerMonitor::updateConfigurations()
    {
        progressBar-&gt;hide();
        scanButton-&gt;show();

        QList&lt;QTreeWidgetItem *&gt; items = treeWidget-&gt;findItems(QLatin1String(&quot;*&quot;), Qt::MatchWildcard);
        QMap&lt;QString, QTreeWidgetItem *&gt; itemMap;
        while (!items.isEmpty()) {
            QTreeWidgetItem *item = items.takeFirst();
            itemMap.insert(item-&gt;data(0, Qt::UserRole).toString(), item);
        }

        QList&lt;QNetworkConfiguration&gt; allConfigurations = manager.allConfigurations();

        while (!allConfigurations.isEmpty()) {
            QNetworkConfiguration config = allConfigurations.takeFirst();

            QTreeWidgetItem *item = itemMap.take(config.identifier());
            if (item) {
                updateItem(item, config);

                if (config.type() == QNetworkConfiguration::ServiceNetwork)
                    updateSnapConfiguration(item, config);
            } else {
                configurationAdded(config);
            }
        }

        foreach (const QString &amp;id, itemMap.keys())
            delete itemMap.value(id);
    }

    void BearerMonitor::onlineStateChanged(bool isOnline)
    {
        if (isOnline)
            onlineState-&gt;setText(tr(&quot;Online&quot;));
        else
            onlineState-&gt;setText(tr(&quot;Offline&quot;));
    }

    #ifdef Q_OS_WIN
    void BearerMonitor::registerNetwork()
    {
        QTreeWidgetItem *item = treeWidget-&gt;currentItem();

        QNetworkConfiguration configuration =
            manager.configurationFromIdentifier(item-&gt;data(0, Qt::UserRole).toString());

        const QString name = configuration.name();

        qDebug() &lt;&lt; &quot;Registering&quot; &lt;&lt; name &lt;&lt; &quot;with system&quot;;

        WSAQUERYSET networkInfo;
        memset(&amp;networkInfo, 0, sizeof(networkInfo));
        networkInfo.dwSize = sizeof(networkInfo);
        networkInfo.lpszServiceInstanceName = (LPWSTR)name.utf16();
        networkInfo.dwNameSpace = NS_NLA;

        if (WSASetService(&amp;networkInfo, RNRSERVICE_REGISTER, 0) == SOCKET_ERROR)
            qDebug() &lt;&lt; &quot;WSASetService(RNRSERVICE_REGISTER) returned&quot; &lt;&lt; WSAGetLastError();
    }

    void BearerMonitor::unregisterNetwork()
    {
        QTreeWidgetItem *item = treeWidget-&gt;currentItem();

        QNetworkConfiguration configuration =
            manager.configurationFromIdentifier(item-&gt;data(0, Qt::UserRole).toString());

        const QString name = configuration.name();

        qDebug() &lt;&lt; &quot;Unregistering&quot; &lt;&lt; name &lt;&lt; &quot;with system&quot;;

        WSAQUERYSET networkInfo;
        memset(&amp;networkInfo, 0, sizeof(networkInfo));
        networkInfo.dwSize = sizeof(networkInfo);
        networkInfo.lpszServiceInstanceName = (LPWSTR)name.utf16();
        networkInfo.dwNameSpace = NS_NLA;

        if (WSASetService(&amp;networkInfo, RNRSERVICE_DELETE, 0) == SOCKET_ERROR)
            qDebug() &lt;&lt; &quot;WSASetService(RNRSERVICE_DELETE) returned&quot; &lt;&lt; WSAGetLastError();
    }
    #endif

    void BearerMonitor::showConfigurationFor(QTreeWidgetItem *item)
    {
        QString identifier;

        if (item)
            identifier = item-&gt;data(0, Qt::UserRole).toString();

        QNetworkConfiguration conf = manager.configurationFromIdentifier(identifier);

        switch (conf.state()) {
        case QNetworkConfiguration::Active:
            configurationState-&gt;setText(tr(&quot;Active&quot;));
            break;
        case QNetworkConfiguration::Discovered:
            configurationState-&gt;setText(tr(&quot;Discovered&quot;));
            break;
        case QNetworkConfiguration::Defined:
            configurationState-&gt;setText(tr(&quot;Defined&quot;));
            break;
        case QNetworkConfiguration::Undefined:
            configurationState-&gt;setText(tr(&quot;Undefined&quot;));
            break;
        default:
            configurationState-&gt;setText(QString());
        }

        switch (conf.type()) {
        case QNetworkConfiguration::InternetAccessPoint:
            configurationType-&gt;setText(tr(&quot;Internet Access Point&quot;));
            break;
        case QNetworkConfiguration::ServiceNetwork:
            configurationType-&gt;setText(tr(&quot;Service Network&quot;));
            break;
        case QNetworkConfiguration::UserChoice:
            configurationType-&gt;setText(tr(&quot;User Choice&quot;));
            break;
        case QNetworkConfiguration::Invalid:
            configurationType-&gt;setText(tr(&quot;Invalid&quot;));
            break;
        default:
            configurationType-&gt;setText(QString());
        }

        switch (conf.purpose()) {
        case QNetworkConfiguration::UnknownPurpose:
            configurationPurpose-&gt;setText(tr(&quot;Unknown&quot;));
            break;
        case QNetworkConfiguration::PublicPurpose:
            configurationPurpose-&gt;setText(tr(&quot;Public&quot;));
            break;
        case QNetworkConfiguration::PrivatePurpose:
            configurationPurpose-&gt;setText(tr(&quot;Private&quot;));
            break;
        case QNetworkConfiguration::ServiceSpecificPurpose:
            configurationPurpose-&gt;setText(tr(&quot;Service Specific&quot;));
            break;
        default:
            configurationPurpose-&gt;setText(QString());
        }

        configurationIdentifier-&gt;setText(conf.identifier());

        configurationRoaming-&gt;setText(conf.isRoamingAvailable() ? tr(&quot;Available&quot;) : tr(&quot;Not available&quot;));

        configurationChildren-&gt;setText(QString::number(conf.children().count()));

        configurationName-&gt;setText(conf.name());
    }

    void BearerMonitor::createSessionFor(QTreeWidgetItem *item)
    {
        const QString identifier = item-&gt;data(0, Qt::UserRole).toString();

        QNetworkConfiguration conf = manager.configurationFromIdentifier(identifier);

        SessionWidget *session = new SessionWidget(conf);

        tabWidget-&gt;addTab(session, conf.name());

        sessionGroup-&gt;show();

        sessionWidgets.append(session);
    }

    void BearerMonitor::createNewSession()
    {
        QTreeWidgetItem *item = treeWidget-&gt;currentItem();

        createSessionFor(item);
    }

    void BearerMonitor::deleteSession()
    {
        SessionWidget *session = qobject_cast&lt;SessionWidget *&gt;(tabWidget-&gt;currentWidget());
        if (session) {
            sessionWidgets.removeAll(session);

            delete session;

            if (tabWidget-&gt;count() == 0)
                sessionGroup-&gt;hide();
        }
    }

    void BearerMonitor::performScan()
    {
        scanButton-&gt;hide();
        progressBar-&gt;show();
        manager.updateConfigurations();
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.0 (Technology Preview)</div></td>
</tr></table></div></address></body>
</html>
