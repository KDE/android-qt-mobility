<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- contacts.qdoc -->
<head>
  <title>Qt Mobility Project 1.0: Contacts</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">Contacts<br /><span class="subtitle"></span>
</h1>
<p>The Contacts API enables a client to request contact data from local or remote backends. This is part of the Qt Mobility Project.</p>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#using-the-api">Using the API</a></li>
<ul><li><a href="#synchronous-api-usage">Synchronous API Usage</a></li>
<li><a href="#asynchronous-api-usage">Asynchronous API Usage</a></li>
<li><a href="#contact-details">Contact Details</a></li>
<ul><li><a href="#viewing-a-specific-detail-of-a-contact">Viewing a specific detail of a contact</a></li>
<li><a href="#viewing-all-of-the-details-of-a-contact">Viewing all of the details of a contact</a></li>
</ul>
</ul>
<li><a href="#manager-settings-and-configuration">Manager Settings And Configuration</a></li>
<ul><li><a href="#loading-the-manager-for-a-specific-backend">Loading the manager for a specific backend</a></li>
<li><a href="#loading-a-manager-with-specific-parameters">Loading a manager with specific parameters</a></li>
</ul>
<li><a href="#building-and-compiling">Building and compiling</a></li>
<li><a href="#reference-documentation">Reference documentation</a></li>
<ul><li><a href="#main-classes">Main classes</a></li>
<li><a href="#contact-details-leaf-classes">&quot;Contact Details&quot; Leaf Classes</a></li>
<li><a href="#asynchronous-requests">Asynchronous Requests</a></li>
<li><a href="#contact-selection">Contact Selection</a></li>
<li><a href="#actions">Actions</a></li>
<li><a href="#implementing-backends">Implementing Backends</a></li>
<li><a href="#manager-information-and-functionality-reporting">Manager information and functionality reporting</a></li>
<li><a href="#synchronization-and-serialization">Synchronization and Serialization</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</ul>
<a name="introduction"></a>
<h3>Introduction</h3>
<p>The Contacts API provides clients with the ability to access contact data in a platform-independent and datastore-agnostic manner. This is achieved by defining generic personal information data abstractions which can sufficiently describe contact data stored on any platform. Due to the cross-platform nature of the API, and the ability for developers to write platform-independent implementations of a <a href="qcontactmanager.html">QContactManager</a> which may unify one or more platform-specific contact backends, it is intended that the semantics and quirks of the underlying datastores on any platform may be entirely opaque from the perspective of Qt-based, cross-platform client applications.</p>
<a name="overview"></a>
<h3>Overview</h3>
<p>A contact is the digital representation of a person, group or entity, which is stored in a platform-specific manner. Information pertaining to a single contact may be located across several different datastores, and each datum (or detail) may or may not pertain to a particular context in which that information is valid. A contact may include semantically identical pieces of information that are relevant in different contexts. For example, a contact may have a phone number that is relevant to their &quot;home&quot; context, and another phone number that is relevant to their &quot;work&quot; context. It can be seen that the context of information defines its validity to the user, depending on the context of usage; and as such, the sum of information in a given context can be considered equivalent to a &quot;contextual identity&quot;. This allows great flexibility when consolidating data from various sources into a single, cohesive contact.</p>
<p>Each datum (or detail) stored in a contact has defined semantics of usage and storage. The Qt Contacts API allows per-datastore contact detail definitions, allowing a manager to provide clients with this information on demand, and allowing third-party developers to register detail definitions for use by clients. A detail definition includes the fields (and value-types of those fields) which make up the detail, per-contact uniqueness constraints on details of the definition, and access constraints (such as read-only, create-only, etc). Additionally, the fields of a detail definition may also be constrained to be read-only or not.</p>
<p>A detail is a single, cohesive unit of information that is stored in a contact. As explained previously, it is valid for a particular context or set of contexts, and conforms to a particular definition. A detail may have specific metadata associated with it, such as its sub-type, context, and arbitrary, user-defined metadata.</p>
<p>Contacts may participate in relationships with other contacts. The details of any such relationship is stored by the manager which contains the contact. There are several standard relationship types supported by the default schema, and arbitrary relationship types are also allowed. In particular, membership of a contact in a group can be modeled as that group contact participating in a <tt>HasMember</tt> relationship with the contact.</p>
<p>Access to the contacts is provided by implementations of the Qt Contacts manager API. A manager provides access to zero or more platform-specific datastores. Each datastore may support different capabilities (for example, the ability to store certain datatypes, the ability to natively filter on different details or details of different definitions, the provision of locking mechanisms, the provision of changelog information, etc) which are reported by the manager on request. The manager therefore provides access to detail definitions, contacts, and relationships stored in different datastores, in a platform and datastore independent manner. The engine of a manager may be implemented as a plugin to allow dynamic loading of different engines at run-time.</p>
<p>The functionality exposed by the <a href="qcontactmanager.html">QContactManager</a> class may be implemented by plugins which interface directly to a platform-specific backend or provide their own data storage backend. As such, the terms &quot;manager&quot;, &quot;plugin&quot; and &quot;backend&quot; are used interchangeably in this documentation to refer to any plugin which implements the functionality exposed by the <a href="qcontactmanager.html">QContactManager</a> interface.</p>
<a name="using-the-api"></a>
<h3>Using the API</h3>
<p>This section provides some examples of common usage of the API.</p>
<a name="synchronous-api-usage"></a>
<h4>Synchronous API Usage</h4>
<p>The synchronous API provides the simplest way to access or modify the contact information managed by a particular backend. It has the disadvantage that calls block until completion and is therefore most suitable only for applications which interact with local, high-speed datastores, or for applications which do not require a responsive UI.</p>
<p>The synchronous API is offered through the <a href="qcontactmanager.html">QContactManager</a> class, and includes manipulation of <a href="qcontact.html">contacts</a>, <a href="qcontactrelationship.html">contact relationships</a>, and <a href="qcontactdetaildefinition.html">schema definitions</a> as well as capability and metadata information reporting.</p>
<p>For more detailed documentation on the synchronous API, see the <a href="contactssync.html">Contacts Synchronous API</a>.</p>
<a name="asynchronous-api-usage"></a>
<h4>Asynchronous API Usage</h4>
<p>The asynchronous API provides a way to access or modify the contact information managed by a particular backend via non-blocking, asynchronous requests. It is recommended for most applications that the asynchronous API be used where possible.</p>
<p>The asynchronous API is offered through various classes derived from the <a href="qcontactabstractrequest.html">QContactAbstractRequest</a> class, including <a href="qcontactlocalidfetchrequest.html">QContactLocalIdFetchRequest</a>, <a href="qcontactfetchrequest.html">QContactFetchRequest</a>, <a href="qcontactsaverequest.html">QContactSaveRequest</a>, <a href="qcontactremoverequest.html">QContactRemoveRequest</a>, <a href="qcontactdetaildefinitionfetchrequest.html">QContactDetailDefinitionFetchRequest</a>, <a href="qcontactdetaildefinitionsaverequest.html">QContactDetailDefinitionSaveRequest</a>, <a href="qcontactdetaildefinitionremoverequest.html">QContactDetailDefinitionRemoveRequest</a>, <a href="qcontactrelationshipfetchrequest.html">QContactRelationshipFetchRequest</a>, <a href="qcontactrelationshipsaverequest.html">QContactRelationshipSaveRequest</a>, and <a href="qcontactrelationshipremoverequest.html">QContactRelationshipRemoveRequest</a>.</p>
<p>The asynchronous API allows manipulation of <a href="qcontact.html">contacts</a>, <a href="qcontactrelationship.html">contact relationships</a>, and <a href="qcontactdetaildefinition.html">schema definitions</a>, but does not provide manager capability or metadata information reporting (which is only available through the <a href="contactssync.html">Contacts Synchronous API</a>).</p>
<p>For more detailed documentation on the asynchronous API, see the <a href="contactsasync.html">Contacts Asynchronous API</a>.</p>
<a name="contact-details"></a>
<h4>Contact Details</h4>
<p>Once a contact has been created (or retrieved from a manager), the client can retrieve, create, update or delete details from the contact. Since <a href="qcontact.html">QContact</a> and <a href="qcontactdetail.html">QContactDetail</a> are both container (value) classes, the API offered for these operations is purely synchronous.</p>
<a name="viewing-a-specific-detail-of-a-contact"></a>
<h5>Viewing a specific detail of a contact</h5>
<p>The client retrieves the phone numbers of a contact, and displays the first one</p>
<pre>    void viewSpecificDetail(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;The first phone number of&quot; &lt;&lt; a.displayLabel()
                 &lt;&lt; &quot;is&quot; &lt;&lt; a.detail(QContactPhoneNumber::DefinitionName).value(QContactPhoneNumber::FieldNumber);
    }</pre>
<a name="viewing-all-of-the-details-of-a-contact"></a>
<h5>Viewing all of the details of a contact</h5>
<p>The client retrieves all of the details of a contact, and displays them</p>
<pre>    void viewDetails(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;Viewing the details of&quot; &lt;&lt; a.displayLabel();

        QList&lt;QContactDetail&gt; allDetails = a.details();
        for (int i = 0; i &lt; allDetails.size(); i++) {
            QContactDetail detail = allDetails.at(i);
            QContactDetailDefinition currentDefinition = cm-&gt;detailDefinition(detail.definitionName());
            QMap&lt;QString, QContactDetailFieldDefinition&gt; fields = currentDefinition.fields();

            qDebug(&quot;\tDetail #%d (%s):&quot;, i, detail.definitionName().toAscii().constData());
            foreach (const QString&amp; fieldKey, fields.keys()) {
                qDebug() &lt;&lt; &quot;\t\t&quot; &lt;&lt; fieldKey &lt;&lt; &quot;(&quot; &lt;&lt; fields.value(fieldKey).dataType() &lt;&lt; &quot;) =&quot; &lt;&lt; detail.value(fieldKey);
            }
            qDebug();
        }
    }</pre>
<p>It is important to note that details are implicitly shared objects with particular semantics surrounding saving, removal and modification. The following example demonstrates these semantics</p>
<pre>    void detailSharing(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;Demonstrating detail sharing semantics with&quot; &lt;&lt; a.displayLabel();

        <span class="comment">/* Create a new phone number detail. */</span>
        QContactPhoneNumber newNumber;
        newNumber.setNumber(&quot;123123123&quot;);
        qDebug() &lt;&lt; &quot;\tThe new phone number is&quot; &lt;&lt; newNumber.number();

        <span class="comment">/*
         * Create a copy of that detail.  These will be implicitly shared;
         * changes to nnCopy will not affect newNumber, and vice versa.
         * However, attempting to save them will cause overwrite to occur.
         * Removal is done purely via key() checking, also.
         */</span>
        QContactPhoneNumber nnCopy(newNumber);
        nnCopy.setNumber(&quot;456456456&quot;);
        qDebug() &lt;&lt; &quot;\tThat number is still&quot; &lt;&lt; newNumber.number() &lt;&lt; &quot;, the copy is&quot; &lt;&lt; nnCopy.number();

        <span class="comment">/* Save the detail in the contact, then remove via the copy, then resave. */</span>
        a.saveDetail(&amp;newNumber);
        a.removeDetail(&amp;nnCopy);  <span class="comment">// identical to a.removeDetail(&amp;newNumber);</span>
        a.saveDetail(&amp;newNumber); <span class="comment">// since newNumber.key() == nnCopy.key();</span>

        <span class="comment">/* Saving will cause overwrite */</span>
        qDebug() &lt;&lt; &quot;\tPrior to saving nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.saveDetail(&amp;nnCopy);
        qDebug() &lt;&lt; &quot;\tAfter saving nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;still has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;

        <span class="comment">/* In order to save nnCopy as a new detail, we must reset its key */</span>
        nnCopy.resetKey();
        qDebug() &lt;&lt; &quot;\tThe copy key is now&quot; &lt;&lt; nnCopy.key() &lt;&lt; &quot;, whereas the original key is&quot; &lt;&lt; newNumber.key();
        qDebug() &lt;&lt; &quot;\tPrior to saving (key reset) nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.saveDetail(&amp;nnCopy);
        qDebug() &lt;&lt; &quot;\tAfter saving (key reset) nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;still has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.removeDetail(&amp;nnCopy);

        <span class="comment">/*
         * Note that changes made to details are not
         * propagated automatically to the contact.
         * To persist changes to a detail, you must call saveDetail().
         */</span>
        QList&lt;QContactPhoneNumber&gt; allNumbers = a.details&lt;QContactPhoneNumber&gt;();
        foreach (const QContactPhoneNumber&amp; savedPhn, allNumbers) {
            if (savedPhn.key() != newNumber.key()) {
                continue;
            }

            <span class="comment">/*
             * This phone number is the saved copy of the newNumber detail.
             * It is detached from the newNumber detail, so changes to newNumber
             * shouldn't affect savedPhn until saveDetail() is called again.
             */</span>
            qDebug() &lt;&lt; &quot;\tCurrently, the (stack) newNumber is&quot; &lt;&lt; newNumber.number()
                     &lt;&lt; &quot;, and the saved newNumber is&quot; &lt;&lt; savedPhn.number();
            newNumber.setNumber(&quot;678678678&quot;);
            qDebug() &lt;&lt; &quot;\tNow, the (stack) newNumber is&quot; &lt;&lt; newNumber.number()
                     &lt;&lt; &quot;, but the saved newNumber is&quot; &lt;&lt; savedPhn.number();
        }

        <span class="comment">/*
         * Removal of the detail depends only on the key of the detail; the fact
         * that the values differ is not taken into account by the remove operation.
         */</span>
        a.removeDetail(&amp;newNumber) ? qDebug() &lt;&lt; &quot;\tSucceeded in removing the temporary detail.&quot;
                                   : qDebug() &lt;&lt; &quot;\tFailed to remove the temporary detail.\n&quot;;
    }</pre>
<a name="manager-settings-and-configuration"></a>
<h3>Manager Settings And Configuration</h3>
<p>Users of the contacts API can define which backend they wish to access if a manager for that backend is available. The list of available managers can be queried programmatically at run-time, and the capabilities of different managers can be ascertained by inspecting a <a href="qcontactmanager.html">QContactManager</a> instance. Furthermore, some managers can be constructed with parameters which affect the operation of the backend.</p>
<a name="loading-the-manager-for-a-specific-backend"></a>
<h4>Loading the manager for a specific backend</h4>
<p>In this example, the client loads a manager for a specific backend. While this could be found and retrieved using a more advanced plugin framework (such as the Qt Service Framework), this code assumes that the client has prior knowledge of the backend in question.</p>
<pre>    void loadManager()
    {
        QContactManager* cm = new QContactManager(&quot;KABC&quot;);
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        if (!contactIds.isEmpty()) {
            QContact a = cm-&gt;contact(contactIds.first());
            qDebug() &lt;&lt; &quot;This manager contains&quot; &lt;&lt; a.displayLabel();
        } else {
            qDebug() &lt;&lt; &quot;This manager contains no contacts&quot;;
        }

        delete cm;
    }</pre>
<a name="loading-a-manager-with-specific-parameters"></a>
<h4>Loading a manager with specific parameters</h4>
<p>The client loads a manager with specific parameters defined. The parameters which are available are backend specific, and so the client had to know that the &quot;Settings&quot; parameter was valid for the particular backend, and what argument it took. In this example, the client tells the backend to load detail definitions saved in a particular settings file.</p>
<pre>    void loadManagerWithParameters()
    {
        QMap&lt;QString, QString&gt; parameters;
        parameters.insert(&quot;Settings&quot;, &quot;~/.qcontactmanager-kabc-settings.ini&quot;);
        QContactManager* cm = new QContactManager(&quot;KABC&quot;, parameters);
        QMap&lt;QString, QContactDetailDefinition&gt; definitions = cm-&gt;detailDefinitions();

        qDebug() &lt;&lt; &quot;This backend currently supports the following detail definitions:&quot;;
        QList&lt;QContactDetailDefinition&gt; allDefinitions = definitions.values();
        foreach (const QContactDetailDefinition&amp; defn, allDefinitions) {
            QMap&lt;QString, QContactDetailFieldDefinition&gt; fields = defn.fields();
            foreach (const QString&amp; fieldKey, fields.keys()) {
                QList&lt;QVariant&gt; allowableValues = fields.value(fieldKey).allowableValues();
                qDebug() &lt;&lt; &quot;\t&quot; &lt;&lt; fieldKey &lt;&lt; &quot;(&quot; &lt;&lt; fields.value(fieldKey).dataType() &lt;&lt; &quot;):&quot;;
                if (allowableValues.isEmpty()) {
                    qDebug() &lt;&lt; &quot;\t\tAny Value Permitted&quot;;
                } else {
                    qDebug() &lt;&lt; allowableValues;
                }
            }
        }

        delete cm;
    }</pre>
<a name="building-and-compiling"></a>
<h3>Building and compiling</h3>
<p>This library requires Qt 4.5 to be installed.</p>
<p>To build the library, run <tt>qmake</tt> and <tt>make</tt>.</p>
<a name="reference-documentation"></a>
<h3>Reference documentation</h3>
<a name="main-classes"></a>
<h4>Main classes</h4>
<p><table width="100%" class="annotated" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><th><a href="qcontact.html">QContact</a></th><td>Represents an addressbook contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactabstractrequest.html">QContactAbstractRequest</a></th><td>Mechanism for asynchronous requests to be made of a manager if it supports them</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactaction.html">QContactAction</a></th><td>Interface for performing an action on a QContact or QContactDetail</td></tr>
<tr valign="top" class="even"><th><a href="qcontactdetail.html">QContactDetail</a></th><td>Represents a single, complete detail about a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactfilter.html">QContactFilter</a></th><td>Used to select contacts made available through a QContactManager</td></tr>
<tr valign="top" class="even"><th><a href="qcontactmanager.html">QContactManager</a></th><td>Interface which allows clients with access to contact information stored in a particular backend</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactrelationship.html">QContactRelationship</a></th><td>Describes a one-to-one relationship between a locally-stored contact and another (possibly remote) contact</td></tr>
</table></p>
<a name="contact-details-leaf-classes"></a>
<h4>&quot;Contact Details&quot; Leaf Classes</h4>
<p>Several subclasses of <a href="qcontactdetail.html">QContactDetail</a> are provided as part of the Qt Mobility Project Contacts API. They are general in design but are intended to fulfil specific use-cases. Please note that certain backends may choose not to support one or more of these subclasses as they appear here; they may offer their own which provide similar functionality.</p>
<p><table width="100%" class="annotated" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><th><a href="qcontactaddress.html">QContactAddress</a></th><td>Contains an address of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactanniversary.html">QContactAnniversary</a></th><td>Contains the anniversary of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactavatar.html">QContactAvatar</a></th><td>Contains the avatar of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactbirthday.html">QContactBirthday</a></th><td>Contains the birthday of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactdisplaylabel.html">QContactDisplayLabel</a></th><td>The (possibly synthesized) display label of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactemailaddress.html">QContactEmailAddress</a></th><td>Contains the email address of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactfamily.html">QContactFamily</a></th><td>Contains the names of the family members of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactgender.html">QContactGender</a></th><td>Contains the gender of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactgeolocation.html">QContactGeoLocation</a></th><td>Contains the global location coordinate associated with a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactglobalpresence.html">QContactGlobalPresence</a></th><td>Aggregated presence information for a contact, synthesized or supplied by the backend</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactguid.html">QContactGuid</a></th><td>Contains the globally unique Id of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactname.html">QContactName</a></th><td>Contains the name of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactnickname.html">QContactNickname</a></th><td>Contains a nickname of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactnote.html">QContactNote</a></th><td>Contains a note associated with a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactonlineaccount.html">QContactOnlineAccount</a></th><td>The online account, which the contact uses to communicate with friends and family</td></tr>
<tr valign="top" class="even"><th><a href="qcontactorganization.html">QContactOrganization</a></th><td>Details about an organization that the contact is either a part of, or stands for</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactphonenumber.html">QContactPhoneNumber</a></th><td>Phone number of a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactpresence.html">QContactPresence</a></th><td>Presence information for an online account of a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactringtone.html">QContactRingtone</a></th><td>Ringtone associated with a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactsynctarget.html">QContactSyncTarget</a></th><td>Sync target for a contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontacttag.html">QContactTag</a></th><td>Contains a tag associated with a contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontactthumbnail.html">QContactThumbnail</a></th><td>Contains a thumbnail used in display lists to represent the contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontacttimestamp.html">QContactTimestamp</a></th><td>Contains the creation and last-modified timestamp associated with the contact</td></tr>
<tr valign="top" class="even"><th><a href="qcontacttype.html">QContactType</a></th><td>Describes the type of the contact</td></tr>
<tr valign="top" class="odd"><th><a href="qcontacturl.html">QContactUrl</a></th><td>Contains a url associated with a contact</td></tr>
</table></p>
<p>Each of these subclasses provide access to information stored in fields which may have certain constraints, as listed in the <a href="contactsschema.html">schema</a>.</p>
<a name="asynchronous-requests"></a>
<h4>Asynchronous Requests</h4>
<p>Clients may use either the <a href="contactssync.html">synchronous</a> or <a href="contactsasync.html">asynchronous</a> API to access functionality provided by a manager backend. The <a href="contactsasync.html">asynchronous</a> API is offered through subclasses of the <a href="qcontactabstractrequest.html">QContactAbstractRequest</a> class:</p>
<p><table width="100%" class="annotated" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><th><a href="qcontactdetaildefinitionfetchrequest.html">QContactDetailDefinitionFetchRequest</a></th><td>Allows a client to asynchronously request detail definitions from a contacts store manager</td></tr>
<tr valign="top" class="even"><th><a href="qcontactdetaildefinitionremoverequest.html">QContactDetailDefinitionRemoveRequest</a></th><td>Allows a client to asynchronously request that certain detail definitions be removed from a contacts store</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactdetaildefinitionsaverequest.html">QContactDetailDefinitionSaveRequest</a></th><td>Allows a client to asynchronously request that certain detail definitions be saved in a contacts store</td></tr>
<tr valign="top" class="even"><th><a href="qcontactfetchrequest.html">QContactFetchRequest</a></th><td>Allows a client to asynchronously request contacts from a contacts store manager</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactlocalidfetchrequest.html">QContactLocalIdFetchRequest</a></th><td>Allows a client to asynchronously request a list of contact ids from a contacts store manager</td></tr>
<tr valign="top" class="even"><th><a href="qcontactrelationshipfetchrequest.html">QContactRelationshipFetchRequest</a></th><td>Allows a client to asynchronously request relationships from a contacts store manager</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactrelationshipremoverequest.html">QContactRelationshipRemoveRequest</a></th><td>Allows a client to asynchronously request that certain relationships be removed from a contacts store</td></tr>
<tr valign="top" class="even"><th><a href="qcontactrelationshipsaverequest.html">QContactRelationshipSaveRequest</a></th><td>Allows a client to asynchronously request that certain groups be saved to a contacts store</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactremoverequest.html">QContactRemoveRequest</a></th><td>Allows a client to asynchronously request that certain contacts be removed from a contacts store</td></tr>
<tr valign="top" class="even"><th><a href="qcontactsaverequest.html">QContactSaveRequest</a></th><td>Allows a client to asynchronously request that certain contacts be saved to a contacts store</td></tr>
</table></p>
<a name="contact-selection"></a>
<h4>Contact Selection</h4>
<p>Clients may select a contact by specifying a unique contact id, or by supplying a <a href="qcontactfilter.html">QContactFilter</a> which matches the contact or contacts they wish to select. The various derivatives of <a href="qcontactfilter.html">QContactFilter</a> allow for fine-grained and flexible selection of contacts according to various criteria:</p>
<p><table width="100%" class="annotated" cellpadding="2" cellspacing="1" border="0">
<tr valign="top" class="odd"><th><a href="qcontactactionfilter.html">QContactActionFilter</a></th><td>Filter based around an action availability criterion</td></tr>
<tr valign="top" class="even"><th><a href="qcontactchangelogfilter.html">QContactChangeLogFilter</a></th><td>Filter based around a contact timestamp criterion</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactdetailfilter.html">QContactDetailFilter</a></th><td>Filter based around a detail value criterion</td></tr>
<tr valign="top" class="even"><th><a href="qcontactdetailrangefilter.html">QContactDetailRangeFilter</a></th><td>Filter based around a detail value range criterion</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactintersectionfilter.html">QContactIntersectionFilter</a></th><td>Filter which intersects the results of other filters</td></tr>
<tr valign="top" class="even"><th><a href="qcontactinvalidfilter.html">QContactInvalidFilter</a></th><td>Matches no contacts</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactlocalidfilter.html">QContactLocalIdFilter</a></th><td>Filter based around a list of contact ids</td></tr>
<tr valign="top" class="even"><th><a href="qcontactrelationshipfilter.html">QContactRelationshipFilter</a></th><td>Filter based around relationship criteria</td></tr>
<tr valign="top" class="odd"><th><a href="qcontactunionfilter.html">QContactUnionFilter</a></th><td>Filter which unions the results of other filters</td></tr>
</table></p>
<p>A client can also request that the results of such a selection be sorted, by passing a <a href="qcontactsortorder.html">QContactSortOrder</a> (or list of sort orders) to the manager.</p>
<a name="actions"></a>
<h4>Actions</h4>
<p>Clients can perform actions on contacts which support them. Actions are things like &quot;Send Email&quot; or &quot;Dial&quot;, and can be provided from various sources including Qt Plugins or the Qt Mobility Service Framework. Every action implementation is uniquely identified by a combination of its name, the name of the vendor which provided the implementation, and the version of the implementation according to the vendor. These pieces of data may be encapsulated in a <a href="qcontactactiondescriptor.html">QContactActionDescriptor</a> which can be used to retrieve an instance of the implementation from a <a href="qcontactactionfactory.html">QContactActionFactory</a>.</p>
<p>When an instance of a <a href="qcontactaction.html">QContactAction</a> is created, the caller takes ownership of the instance, and must delete it after use.</p>
<a name="implementing-backends"></a>
<h4>Implementing Backends</h4>
<p>A manager backend may be implemented by subclassing <a href="qcontactmanagerengine.html">QContactManagerEngine</a>, and providing a <a href="qcontactmanagerenginefactory.html">QContactManagerEngineFactory</a> which can instantiate it when required.</p>
<a name="manager-information-and-functionality-reporting"></a>
<h4>Manager information and functionality reporting</h4>
<p>Different backends have different capabilities and offer different functionality. In order to allow clients to query the provided functionality at runtime, every backend must be capable of reporting their functionality and implementation version. They are reported to clients through various functions provided by the <a href="qcontactmanager.html">QContactManager</a> class.</p>
<a name="synchronization-and-serialization"></a>
<h4>Synchronization and Serialization</h4>
<p>The contacts API is used by another Qt Mobility module: the <a href="versit.html">Versit</a>* module. It allows serialization of a <a href="qcontact.html">QContact</a> into a vCard document, and vice versa.</p>
<p>[*] Versit <sup>&reg;</sup> is a trademark of the Internet Mail Consortium.</p>
<a name="examples"></a>
<h4>Examples</h4>
<ul>
<li><a href="samplephonebook.html">Sample Phonebook</a></li>
<li><a href="qmlcontacts.html">QML-based Sample Phonebook</a></li>
</ul>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.0</div></td>
</tr></table></div></address></body>
</html>
