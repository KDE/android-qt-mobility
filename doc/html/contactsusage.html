<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- contactsusage.qdoc -->
<head>
  <title>Qt Mobility Project 1.0: Contacts API Usage</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">Contacts API Usage<br /><span class="subtitle"></span>
</h1>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#manager-settings-and-configuration">Manager Settings And Configuration</a></li>
<ul><li><a href="#loading-the-default-manager-for-the-platform">Loading the default manager for the platform</a></li>
<li><a href="#querying-a-manager-for-capabilities">Querying a manager for capabilities</a></li>
<li><a href="#loading-the-manager-for-a-specific-backend">Loading the manager for a specific backend</a></li>
<li><a href="#loading-a-manager-with-specific-parameters">Loading a manager with specific parameters</a></li>
</ul>
<li><a href="#contact-detail-manipulation">Contact Detail Manipulation</a></li>
<ul><li><a href="#adding-a-detail-to-a-contact">Adding a detail to a contact</a></li>
<li><a href="#updating-a-detail-in-a-contact">Updating a detail in a contact</a></li>
<li><a href="#removing-a-detail-from-a-contact">Removing a detail from a contact</a></li>
<li><a href="#viewing-a-specific-detail-of-a-contact">Viewing a specific detail of a contact</a></li>
<li><a href="#viewing-all-of-the-details-of-a-contact">Viewing all of the details of a contact</a></li>
</ul>
<li><a href="#persistent-contact-information">Persistent Contact Information</a></li>
<ul><li><a href="#creating-a-new-contact-in-a-manager">Creating a new contact in a manager</a></li>
<li><a href="#retrieving-contacts-from-a-manager">Retrieving contacts from a manager</a></li>
<li><a href="#updating-an-existing-contact-in-a-manager">Updating an existing contact in a manager</a></li>
<li><a href="#removing-a-contact-from-a-manager">Removing a contact from a manager</a></li>
<li><a href="#creating-a-new-relationship-between-two-contacts">Creating a new relationship between two contacts</a></li>
<li><a href="#retrieving-relationships-between-contacts">Retrieving relationships between contacts</a></li>
<li><a href="#removing-a-relationship-between-two-contacts">Removing a relationship between two contacts</a></li>
<li><a href="#querying-the-schema-supported-by-a-manager">Querying the schema supported by a manager</a></li>
<li><a href="#modifying-the-schema-supported-by-a-manager">Modifying the schema supported by a manager</a></li>
</ul>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>This section provides some examples of common usage of the Qt Contacts API.</p>
<a name="manager-settings-and-configuration"></a>
<h2>Manager Settings And Configuration</h2>
<p>Users of the contacts API can define which backend they wish to access if a manager for that backend is available. The list of available managers can be queried programmatically at run-time, and the capabilities of different managers can be ascertained by inspecting a <a href="qcontactmanager.html">QContactManager</a> instance. Furthermore, some managers can be constructed with parameters which affect the operation of the backend.</p>
<a name="loading-the-default-manager-for-the-platform"></a>
<h3>Loading the default manager for the platform</h3>
<p>Most users of the API will want to use the default manager for the platform, which provides access to the system address book. Instantiating a manager by using the default constructor will result in the default manager for that platform being instantiated.</p>
<p>The default constructor can either be used to create a manager on the stack, in which case it will be deleted automatically when it goes out of scope:</p>
<pre>        QContactManager stackDefaultContactManager;</pre>
<p>or it can be used explicitly to create a manager on the heap, in which case the client must ensure that they delete the manager when they are finished with it in order to avoid a memory leak:</p>
<pre>        QContactManager *heapDefaultContactManager = new QContactManager;
        <span class="comment">// ... perform contact manipulation</span>
        delete heapDefaultContactManager;</pre>
<a name="querying-a-manager-for-capabilities"></a>
<h3>Querying a manager for capabilities</h3>
<p>Different managers will support different capabilities and details. Clients can use the meta data reporting functions of <a href="qcontactmanager.html">QContactManager</a> to determine what the capabilities of the manager they have instantiated might be.</p>
<pre>        QContactManager cm;
        qDebug() &lt;&lt; &quot;The default manager for the platform is:&quot; &lt;&lt; cm.managerName();
        qDebug() &lt;&lt; &quot;It&quot; &lt;&lt; (cm.isRelationshipTypeSupported(QContactRelationship::HasAssistant) ? &quot;supports&quot; : &quot;does not support&quot;) &lt;&lt; &quot;assistant relationships.&quot;;
        qDebug() &lt;&lt; &quot;It&quot; &lt;&lt; (cm.supportedContactTypes().contains(QContactType::TypeGroup) ? &quot;supports&quot; : &quot;does not support&quot;) &lt;&lt; &quot;groups.&quot;;
        qDebug() &lt;&lt; &quot;It&quot; &lt;&lt; (cm.hasFeature(QContactManager::MutableDefinitions) ? &quot;supports&quot; : &quot;does not support&quot;) &lt;&lt; &quot;mutable detail definitions.&quot;;</pre>
<a name="loading-the-manager-for-a-specific-backend"></a>
<h3>Loading the manager for a specific backend</h3>
<p>In this example, the client loads a manager for a specific backend. While this could be found and retrieved using a more advanced plugin framework (such as the Qt Service Framework), this code assumes that the client has prior knowledge of the backend in question.</p>
<p>Clients may wish to use this feature of the API if they wish to store or retrieve contact information to a particular manager (for example, one that interfaces with a particular online service).</p>
<pre>        QContactManager contactManager(&quot;KABC&quot;);</pre>
<a name="loading-a-manager-with-specific-parameters"></a>
<h3>Loading a manager with specific parameters</h3>
<p>The client loads a manager with specific parameters defined. The parameters which are available are backend specific, and so the client had to know that the &quot;Settings&quot; parameter was valid for the particular backend, and what argument it took. In this example, the client tells the backend to load detail definitions saved in a particular settings file.</p>
<pre>        QMap&lt;QString, QString&gt; parameters;
        parameters.insert(&quot;Settings&quot;, &quot;~/.qcontactmanager-kabc-settings.ini&quot;);
        QContactManager contactManager(&quot;KABC&quot;, parameters);</pre>
<a name="contact-detail-manipulation"></a>
<h2>Contact Detail Manipulation</h2>
<p>Once a contact has been created (or retrieved from a manager), the client can retrieve, create, update or delete details from the contact. Since <a href="qcontact.html">QContact</a> and <a href="qcontactdetail.html">QContactDetail</a> are both container (value) classes, the API offered for these operations is purely synchronous.</p>
<p>A contact consists of the details it contains, as well as an id. Some details are read-only (such as the display label of a contact) or irremovable (like the type of a contact), but most are freely modifiable by clients.</p>
<a name="adding-a-detail-to-a-contact"></a>
<h3>Adding a detail to a contact</h3>
<p>The client adds a name and a phone number to a contact.</p>
<pre>        QContact exampleContact;

        QContactName nameDetail;
        nameDetail.setFirstName(&quot;Adam&quot;);
        nameDetail.setLastName(&quot;Unlikely&quot;);

        QContactPhoneNumber phoneNumberDetail;
        phoneNumberDetail.setNumber(&quot;+123 4567&quot;);

        exampleContact.saveDetail(&amp;nameDetail);
        exampleContact.saveDetail(&amp;phoneNumberDetail);</pre>
<a name="updating-a-detail-in-a-contact"></a>
<h3>Updating a detail in a contact</h3>
<p>The client updates the phone number of a contact.</p>
<pre>        phoneNumberDetail.setNumber(&quot;+123 9876&quot;);
        exampleContact.saveDetail(&amp;phoneNumberDetail); <span class="comment">// overwrites old value on save</span></pre>
<a name="removing-a-detail-from-a-contact"></a>
<h3>Removing a detail from a contact</h3>
<p>The client removes the phone number of a contact.</p>
<pre>        exampleContact.removeDetail(&amp;phoneNumberDetail);</pre>
<a name="viewing-a-specific-detail-of-a-contact"></a>
<h3>Viewing a specific detail of a contact</h3>
<p>The client retrieves and displays the first phone number of a contact</p>
<pre>    void viewSpecificDetail(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;The first phone number of&quot; &lt;&lt; a.displayLabel()
                 &lt;&lt; &quot;is&quot; &lt;&lt; a.detail(QContactPhoneNumber::DefinitionName).value(QContactPhoneNumber::FieldNumber);
    }</pre>
<a name="viewing-all-of-the-details-of-a-contact"></a>
<h3>Viewing all of the details of a contact</h3>
<p>The client retrieves all of the details of a contact, and displays them</p>
<pre>    void viewDetails(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;Viewing the details of&quot; &lt;&lt; a.displayLabel();

        QList&lt;QContactDetail&gt; allDetails = a.details();
        for (int i = 0; i &lt; allDetails.size(); i++) {
            QContactDetail detail = allDetails.at(i);
            QContactDetailDefinition currentDefinition = cm-&gt;detailDefinition(detail.definitionName());
            QMap&lt;QString, QContactDetailFieldDefinition&gt; fields = currentDefinition.fields();

            qDebug(&quot;\tDetail #%d (%s):&quot;, i, detail.definitionName().toAscii().constData());
            foreach (const QString&amp; fieldKey, fields.keys()) {
                qDebug() &lt;&lt; &quot;\t\t&quot; &lt;&lt; fieldKey &lt;&lt; &quot;(&quot; &lt;&lt; fields.value(fieldKey).dataType() &lt;&lt; &quot;) =&quot; &lt;&lt; detail.value(fieldKey);
            }
            qDebug();
        }
    }</pre>
<p>It is important to note that details are implicitly shared objects with particular semantics surrounding saving, removal and modification. The following example demonstrates these semantics</p>
<pre>    void detailSharing(QContactManager* cm)
    {
        QList&lt;QContactLocalId&gt; contactIds = cm-&gt;contactIds();
        QContact a = cm-&gt;contact(contactIds.first());
        qDebug() &lt;&lt; &quot;Demonstrating detail sharing semantics with&quot; &lt;&lt; a.displayLabel();

        <span class="comment">/* Create a new phone number detail. */</span>
        QContactPhoneNumber newNumber;
        newNumber.setNumber(&quot;123123123&quot;);
        qDebug() &lt;&lt; &quot;\tThe new phone number is&quot; &lt;&lt; newNumber.number();

        <span class="comment">/*
         * Create a copy of that detail.  These will be implicitly shared;
         * changes to nnCopy will not affect newNumber, and vice versa.
         * However, attempting to save them will cause overwrite to occur.
         * Removal is done purely via key() checking, also.
         */</span>
        QContactPhoneNumber nnCopy(newNumber);
        nnCopy.setNumber(&quot;456456456&quot;);
        qDebug() &lt;&lt; &quot;\tThat number is still&quot; &lt;&lt; newNumber.number() &lt;&lt; &quot;, the copy is&quot; &lt;&lt; nnCopy.number();

        <span class="comment">/* Save the detail in the contact, then remove via the copy, then resave. */</span>
        a.saveDetail(&amp;newNumber);
        a.removeDetail(&amp;nnCopy);  <span class="comment">// identical to a.removeDetail(&amp;newNumber);</span>
        a.saveDetail(&amp;newNumber); <span class="comment">// since newNumber.key() == nnCopy.key();</span>

        <span class="comment">/* Saving will cause overwrite */</span>
        qDebug() &lt;&lt; &quot;\tPrior to saving nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.saveDetail(&amp;nnCopy);
        qDebug() &lt;&lt; &quot;\tAfter saving nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;still has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;

        <span class="comment">/* In order to save nnCopy as a new detail, we must reset its key */</span>
        nnCopy.resetKey();
        qDebug() &lt;&lt; &quot;\tThe copy key is now&quot; &lt;&lt; nnCopy.key() &lt;&lt; &quot;, whereas the original key is&quot; &lt;&lt; newNumber.key();
        qDebug() &lt;&lt; &quot;\tPrior to saving (key reset) nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.saveDetail(&amp;nnCopy);
        qDebug() &lt;&lt; &quot;\tAfter saving (key reset) nnCopy,&quot; &lt;&lt; a.displayLabel() &lt;&lt; &quot;still has&quot; &lt;&lt; a.details().count() &lt;&lt; &quot;details.&quot;;
        a.removeDetail(&amp;nnCopy);

        <span class="comment">/*
         * Note that changes made to details are not
         * propagated automatically to the contact.
         * To persist changes to a detail, you must call saveDetail().
         */</span>
        QList&lt;QContactPhoneNumber&gt; allNumbers = a.details&lt;QContactPhoneNumber&gt;();
        foreach (const QContactPhoneNumber&amp; savedPhn, allNumbers) {
            if (savedPhn.key() != newNumber.key()) {
                continue;
            }

            <span class="comment">/*
             * This phone number is the saved copy of the newNumber detail.
             * It is detached from the newNumber detail, so changes to newNumber
             * shouldn't affect savedPhn until saveDetail() is called again.
             */</span>
            qDebug() &lt;&lt; &quot;\tCurrently, the (stack) newNumber is&quot; &lt;&lt; newNumber.number()
                     &lt;&lt; &quot;, and the saved newNumber is&quot; &lt;&lt; savedPhn.number();
            newNumber.setNumber(&quot;678678678&quot;);
            qDebug() &lt;&lt; &quot;\tNow, the (stack) newNumber is&quot; &lt;&lt; newNumber.number()
                     &lt;&lt; &quot;, but the saved newNumber is&quot; &lt;&lt; savedPhn.number();
        }

        <span class="comment">/*
         * Removal of the detail depends only on the key of the detail; the fact
         * that the values differ is not taken into account by the remove operation.
         */</span>
        a.removeDetail(&amp;newNumber) ? qDebug() &lt;&lt; &quot;\tSucceeded in removing the temporary detail.&quot;
                                   : qDebug() &lt;&lt; &quot;\tFailed to remove the temporary detail.\n&quot;;
    }</pre>
<a name="persistent-contact-information"></a>
<h2>Persistent Contact Information</h2>
<p>After instantiating a manager, clients will wish to retrieve or modify contact information (including relationships and possibly detail definitions) which is persistently stored in the manager (for example, in a database or online cloud).</p>
<p>If the client wishes to use the asynchronous API, it is suggested that their class uses member variables for the manager and requests, similarly to:</p>
<pre>    QTM_USE_NAMESPACE
    class AsyncRequestExample : public QObject
    {
        Q_OBJECT

    public:
        AsyncRequestExample();
        ~AsyncRequestExample();

    public slots:
        void performRequests();

    private slots:
        void contactFetchRequestStateChanged(QContactAbstractRequest::State newState);
        void contactSaveRequestStateChanged(QContactAbstractRequest::State newState);
        void contactRemoveRequestStateChanged(QContactAbstractRequest::State newState);
        void relationshipFetchRequestStateChanged(QContactAbstractRequest::State newState);
        void relationshipSaveRequestStateChanged(QContactAbstractRequest::State newState);
        void relationshipRemoveRequestStateChanged(QContactAbstractRequest::State newState);
        void definitionFetchRequestStateChanged(QContactAbstractRequest::State newState);
        void definitionSaveRequestStateChanged(QContactAbstractRequest::State newState);
        void definitionRemoveRequestStateChanged(QContactAbstractRequest::State newState);

    private:
        QContactManager *m_manager;
        QContactFetchRequest m_contactFetchRequest;
        QContactSaveRequest m_contactSaveRequest;
        QContactRemoveRequest m_contactRemoveRequest;
        QContactRelationshipFetchRequest m_relationshipFetchRequest;
        QContactRelationshipSaveRequest m_relationshipSaveRequest;
        QContactRelationshipRemoveRequest m_relationshipRemoveRequest;
        QContactDetailDefinitionFetchRequest m_definitionFetchRequest;
        QContactDetailDefinitionSaveRequest m_definitionSaveRequest;
        QContactDetailDefinitionRemoveRequest m_definitionRemoveRequest;
    };</pre>
<p>This allows them to define slots which deal with the data as required when the state of the request changes:</p>
<pre>    void AsyncRequestExample::contactFetchRequestStateChanged(QContactAbstractRequest::State newState)
    {
        if (newState == QContactAbstractRequest::FinishedState) {
            QContactFetchRequest *request = qobject_cast&lt;QContactFetchRequest*&gt;(QObject::sender());
            if (request-&gt;error() != QContactManager::NoError) {
                qDebug() &lt;&lt; &quot;Error&quot; &lt;&lt; request-&gt;error() &lt;&lt; &quot;occurred during fetch request!&quot;;
                return;
            }

            QList&lt;QContact&gt; results = request-&gt;contacts();
            for (int i = 0; i &lt; results.size(); i++) {
                qDebug() &lt;&lt; &quot;Retrieved contact:&quot; &lt;&lt; results.at(i).displayLabel();
            }
        } else if (newState == QContactAbstractRequest::CanceledState) {
            qDebug() &lt;&lt; &quot;Fetch operation canceled!&quot;;
        }
    }</pre>
<p>Note that if the client is interested in receiving the results of the request as they become available, rather than only the final set of results once the request changes state (to <tt>FinishedState</tt>, for example), the client should instead connect the <a href="qcontactabstractrequest.html#resultsAvailable">QContactAbstractRequest::resultsAvailable</a>() signal to the slot which deals with the results.</p>
<a name="creating-a-new-contact-in-a-manager"></a>
<h3>Creating a new contact in a manager</h3>
<p>The client creates a new contact and saves it in a manager</p>
<pre>        QContact exampleContact;

        QContactName nameDetail;
        nameDetail.setFirstName(&quot;Adam&quot;);
        nameDetail.setLastName(&quot;Unlikely&quot;);

        QContactPhoneNumber phoneNumberDetail;
        phoneNumberDetail.setNumber(&quot;+123 4567&quot;);

        exampleContact.saveDetail(&amp;nameDetail);
        exampleContact.saveDetail(&amp;phoneNumberDetail);

        <span class="comment">// save the newly created contact in the manager</span>
        connect(&amp;m_contactSaveRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(contactSaveRequestStateChanged(QContactAbstractRequest::State)));
        m_contactSaveRequest.setManager(m_manager);
        m_contactSaveRequest.setContacts(QList&lt;QContact&gt;() &lt;&lt; exampleContact);
        m_contactSaveRequest.start();</pre>
<p>Alternatively, the client can explicitly block execution until the request is complete, by doing something like:</p>
<pre>        m_contactSaveRequest.setManager(m_manager);
        m_contactSaveRequest.setContacts(QList&lt;QContact&gt;() &lt;&lt; exampleContact);
        m_contactSaveRequest.start();
        m_contactSaveRequest.waitForFinished();
        QList&lt;QContact&gt; savedContacts = m_contactSaveRequest.contacts();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        QContact exampleContact;

        QContactName nameDetail;
        nameDetail.setFirstName(&quot;Adam&quot;);
        nameDetail.setLastName(&quot;Unlikely&quot;);

        QContactPhoneNumber phoneNumberDetail;
        phoneNumberDetail.setNumber(&quot;+123 4567&quot;);

        exampleContact.saveDetail(&amp;nameDetail);
        exampleContact.saveDetail(&amp;phoneNumberDetail);

        <span class="comment">// save the newly created contact in the manager</span>
        if (!m_manager.saveContact(&amp;exampleContact))
            qDebug() &lt;&lt; &quot;Error&quot; &lt;&lt; m_manager.error() &lt;&lt; &quot;occurred whilst saving contact!&quot;;</pre>
<a name="retrieving-contacts-from-a-manager"></a>
<h3>Retrieving contacts from a manager</h3>
<p>The client requests all contacts from the manager which match a particular filter.</p>
<pre>        connect(&amp;m_contactFetchRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(contactFetchRequestStateChanged(QContactAbstractRequest::State)));
        m_contactFetchRequest.setManager(m_manager);
        m_contactFetchRequest.setFilter(QContactPhoneNumber::match(&quot;+123 4567&quot;));
        m_contactFetchRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        QList&lt;QContact&gt; results = m_manager.contacts(QContactPhoneNumber::match(&quot;+123 4567&quot;));</pre>
<p>The client can also retrieve a particular existing contact from a manager, by directly requesting the contact with a particular (previously known) id. With the asynchronous API, this takes the form of another filter:</p>
<pre>        QContactLocalIdFilter idListFilter;
        idListFilter.setIds(QList&lt;QContactLocalId&gt;() &lt;&lt; exampleContact.localId());
        m_contactFetchRequest.setManager(m_manager);
        m_contactFetchRequest.setFilter(idListFilter);
        m_contactFetchRequest.start();</pre>
<p>The synchronous API provides a function specifically for this purpose:</p>
<pre>        QContact existing = m_manager.contact(exampleContact.localId());</pre>
<a name="updating-an-existing-contact-in-a-manager"></a>
<h3>Updating an existing contact in a manager</h3>
<p>The client updates a previously saved contact by saving the updated version of the contact. Any contact whose id is the same as that of the updated contact will be overwritten as a result of the save request.</p>
<pre>        phoneNumberDetail.setNumber(&quot;+123 9876&quot;);
        exampleContact.saveDetail(&amp;phoneNumberDetail);
        m_contactSaveRequest.setManager(m_manager);
        m_contactSaveRequest.setContacts(QList&lt;QContact&gt;() &lt;&lt; exampleContact);
        m_contactSaveRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        phoneNumberDetail.setNumber(&quot;+123 9876&quot;);
        exampleContact.saveDetail(&amp;phoneNumberDetail);
        m_manager.saveContact(&amp;exampleContact);</pre>
<a name="removing-a-contact-from-a-manager"></a>
<h3>Removing a contact from a manager</h3>
<p>The client removes a contact from the manager by specifying its local id.</p>
<pre>        connect(&amp;m_contactRemoveRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(contactRemoveRequestStateChanged(QContactAbstractRequest::State)));
        m_contactRemoveRequest.setManager(m_manager);
        m_contactRemoveRequest.setContactIds(QList&lt;QContactLocalId&gt;() &lt;&lt; exampleContact.localId());
        m_contactRemoveRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        m_manager.removeContact(exampleContact.localId());</pre>
<a name="creating-a-new-relationship-between-two-contacts"></a>
<h3>Creating a new relationship between two contacts</h3>
<p>The client specifies a relationship between two contacts stored in the manager</p>
<pre>        <span class="comment">// first, create the group and the group member</span>
        QContact exampleGroup;
        exampleGroup.setType(QContactType::TypeGroup);
        QContactNickname groupName;
        groupName.setNickname(&quot;Example Group&quot;);
        exampleGroup.saveDetail(&amp;groupName);

        QContact exampleGroupMember;
        QContactName groupMemberName;
        groupMemberName.setFirstName(&quot;Member&quot;);
        exampleGroupMember.saveDetail(&amp;groupMemberName);

        <span class="comment">// second, save those contacts in the manager</span>
        QList&lt;QContact&gt; saveList;
        saveList &lt;&lt; exampleGroup &lt;&lt; exampleGroupMember;
        m_contactSaveRequest.setContacts(saveList);
        m_contactSaveRequest.start();
        m_contactSaveRequest.waitForFinished();

        <span class="comment">// third, create the relationship between those contacts</span>
        QContactRelationship groupRelationship;
        groupRelationship.setFirst(exampleGroup.id());
        groupRelationship.setRelationshipType(QContactRelationship::HasMember);
        groupRelationship.setSecond(exampleGroupMember.id());

        <span class="comment">// finally, save the relationship in the manager</span>
        connect(&amp;m_relationshipSaveRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(relationshipSaveRequestStateChanged(QContactAbstractRequest::State)));
        m_relationshipSaveRequest.setManager(m_manager);
        m_relationshipSaveRequest.setRelationships(QList&lt;QContactRelationship&gt;() &lt;&lt; groupRelationship);
        m_relationshipSaveRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        <span class="comment">// first, create the group and the group member</span>
        QContact exampleGroup;
        exampleGroup.setType(QContactType::TypeGroup);
        QContactNickname groupName;
        groupName.setNickname(&quot;Example Group&quot;);
        exampleGroup.saveDetail(&amp;groupName);

        QContact exampleGroupMember;
        QContactName groupMemberName;
        groupMemberName.setFirstName(&quot;Member&quot;);
        exampleGroupMember.saveDetail(&amp;groupMemberName);

        <span class="comment">// second, save those contacts in the manager</span>
        QMap&lt;int, QContactManager::Error&gt; errorMap;
        QList&lt;QContact&gt; saveList;
        saveList &lt;&lt; exampleGroup &lt;&lt; exampleGroupMember;
        m_manager.saveContacts(&amp;saveList, &amp;errorMap);

        <span class="comment">// third, create the relationship between those contacts</span>
        QContactRelationship groupRelationship;
        groupRelationship.setFirst(exampleGroup.id());
        groupRelationship.setRelationshipType(QContactRelationship::HasMember);
        groupRelationship.setSecond(exampleGroupMember.id());

        <span class="comment">// finally, save the relationship in the manager</span>
        m_manager.saveRelationship(&amp;groupRelationship);</pre>
<a name="retrieving-relationships-between-contacts"></a>
<h3>Retrieving relationships between contacts</h3>
<p>The client requests the relationships that a particular contact is involved in from the manager in which the contact is stored.</p>
<pre>        connect(&amp;m_relationshipFetchRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(relationshipFetchRequestStateChanged(QContactAbstractRequest::State)));
        m_relationshipFetchRequest.setManager(m_manager);
        <span class="comment">// retrieve the list of relationships between the example group contact and the example member contact</span>
        <span class="comment">// where the group contact is the first contact in the relationship, and the member contact is the</span>
        <span class="comment">// second contact in the relationship.  In order to fetch all relationships between them, another</span>
        <span class="comment">// relationship fetch must be performed with their roles reversed, and the results added together.</span>
        m_relationshipFetchRequest.setFirst(exampleGroup.id());
        m_relationshipFetchRequest.setSecond(exampleGroupMember.id());
        m_relationshipFetchRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        QList&lt;QContactRelationship&gt; groupRelationships = m_manager.relationships(QContactRelationship::HasMember, exampleGroup.id(), QContactRelationship::First);
        QList&lt;QContactRelationship&gt; result;
        for (int i = 0; i &lt; groupRelationships.size(); i++) {
            if (groupRelationships.at(i).second() == exampleGroupMember.id()) {
                result.append(groupRelationships.at(i));
            }
        }</pre>
<p>When a contact is retrieved, it will contain a cache of the relationships in which it is involved at the point in time at which it was retrieved. This provides clients with a simple way to retrieve the relationships in which a contact is involved, but carries the risk that the cache is stale.</p>
<pre>        exampleGroup = m_manager.contact(exampleGroup.localId()); <span class="comment">// refresh the group contact</span>
        groupRelationships = exampleGroup.relationships(QContactRelationship::HasMember);
        for (int i = 0; i &lt; groupRelationships.size(); i++) {
            if (groupRelationships.at(i).second() == exampleGroupMember.id()) {
                result.append(groupRelationships.at(i));
            }
        }</pre>
<p>Clients can inform the manager that they do not require this cache of relationships to be populated when retrieving a contact, which can allow a manager to optimize contact retrieval. Other retrieval optimizations are also possible to specify, for example that they are only interested in certain types of details. The following code shows how the client can inform the manager that they are only interested in relationships of the <tt>HasMember</tt> type (groups):</p>
<pre>        QContactFetchHint hasMemberRelationshipsOnly;
        hasMemberRelationshipsOnly.setRelationshipTypesHint(QStringList(QContactRelationship::HasMember));

        m_contactFetchRequest.setManager(m_manager);
        m_contactFetchRequest.setFilter(QContactFilter()); <span class="comment">// all contacts</span>
        m_contactFetchRequest.setFetchHint(hasMemberRelationshipsOnly);
        m_contactFetchRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        QContactFetchHint hasMemberRelationshipsOnly;
        hasMemberRelationshipsOnly.setRelationshipTypesHint(QStringList(QContactRelationship::HasMember));

        <span class="comment">// retrieve all contacts, with no specified sort order, requesting that</span>
        <span class="comment">// HasMember relationships be included in the cache of result contacts</span>
        QList&lt;QContact&gt; allContacts = m_manager.contacts(QContactFilter(), QList&lt;QContactSortOrder&gt;(), hasMemberRelationshipsOnly);</pre>
<a name="removing-a-relationship-between-two-contacts"></a>
<h3>Removing a relationship between two contacts</h3>
<p>The client can remove a relationship directly from a manager.</p>
<pre>        connect(&amp;m_relationshipRemoveRequest, SIGNAL(stateChanged(QContactAbstractRequest::State)), this, SLOT(relationshipRemoveRequestStateChanged(QContactAbstractRequest::State)));
        m_relationshipRemoveRequest.setManager(m_manager);
        m_relationshipRemoveRequest.setRelationships(QList&lt;QContactRelationship&gt;() &lt;&lt; groupRelationship);
        m_relationshipRemoveRequest.start();</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        m_manager.removeRelationship(groupRelationship);</pre>
<p>Alternatively, when a contact which is involved in a relationship is removed, any relationships in which it is involved will be removed also.</p>
<a name="querying-the-schema-supported-by-a-manager"></a>
<h3>Querying the schema supported by a manager</h3>
<p>The client queries the schema supported by a manager, and checks to see if a particular detail definition supports a certain field.</p>
<pre>        m_definitionFetchRequest.setManager(m_manager);
        m_definitionFetchRequest.setDefinitionNames(QStringList(QContactName::DefinitionName));
        m_definitionFetchRequest.start();
        m_definitionFetchRequest.waitForFinished();
        QMap&lt;QString, QContactDetailDefinition&gt; definitions = m_definitionFetchRequest.definitions();
        qDebug() &lt;&lt; &quot;This manager&quot;
                 &lt;&lt; (definitions.value(QContactName::DefinitionName).fields().contains(QContactName::FieldCustomLabel) ? &quot;supports&quot; : &quot;does not support&quot;)
                 &lt;&lt; &quot;the custom label field of QContactName&quot;;</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        QMap&lt;QString, QContactDetailDefinition&gt; definitions = m_manager.detailDefinitions();
        qDebug() &lt;&lt; &quot;This manager&quot;
                 &lt;&lt; (definitions.value(QContactName::DefinitionName).fields().contains(QContactName::FieldCustomLabel) ? &quot;supports&quot; : &quot;does not support&quot;)
                 &lt;&lt; &quot;the custom label field of QContactName&quot;;</pre>
<a name="modifying-the-schema-supported-by-a-manager"></a>
<h3>Modifying the schema supported by a manager</h3>
<p>The client attempts to modify a particular detail definition by extending it so that it supports an extra field.</p>
<pre>        <span class="comment">// modify the name definition, adding a patronym field</span>
        QContactDetailDefinition nameDefinition = definitions.value(QContactName::DefinitionName);
        QContactDetailFieldDefinition fieldPatronym;
        fieldPatronym.setDataType(QVariant::String);
        nameDefinition.insertField(&quot;Patronym&quot;, fieldPatronym);

        <span class="comment">// save the updated definition in the manager if supported...</span>
        if (m_manager-&gt;hasFeature(QContactManager::MutableDefinitions)) {
            m_definitionSaveRequest.setManager(m_manager);
            m_definitionSaveRequest.setContactType(QContactType::TypeContact);
            m_definitionSaveRequest.setDefinitions(QList&lt;QContactDetailDefinition&gt;() &lt;&lt; nameDefinition);
            m_definitionSaveRequest.start();
        }</pre>
<p>The equivalent code using the synchronous API looks like:</p>
<pre>        <span class="comment">// modify the name definition, adding a patronym field</span>
        QContactDetailDefinition nameDefinition = definitions.value(QContactName::DefinitionName);
        QContactDetailFieldDefinition fieldPatronym;
        fieldPatronym.setDataType(QVariant::String);
        nameDefinition.insertField(&quot;Patronym&quot;, fieldPatronym);

        <span class="comment">// save the updated definition in the manager if supported...</span>
        if (m_manager.hasFeature(QContactManager::MutableDefinitions)) {
            m_manager.saveDetailDefinition(nameDefinition, QContactType::TypeContact);
        }</pre>
<p>Note that some managers do not support mutable definitions, and hence attempting to modify or remove detail definitions in those managers will fail.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2010 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.2</div></td>
</tr></table></div></address></body>
</html>
