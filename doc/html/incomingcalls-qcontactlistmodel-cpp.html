<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt Mobility Project 1.0: qcontactlistmodel.cpp Example File (incomingcalls/qcontactlistmodel.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">qcontactlistmodel.cpp Example File<br /><span class="small-subtitle">incomingcalls/qcontactlistmodel.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;qcontactlistmodel.h&quot;
    #include &quot;qcontactlistmodel_p.h&quot;

    #include &quot;qcontact.h&quot;
    #include &quot;qcontactmanager.h&quot;
    #include &quot;qcontactdetails.h&quot;
    #include &quot;qcontactrequests.h&quot;
    #include &quot;qcontactfilters.h&quot;

<span class="comment">    /*!
     * Constructs a new QContactListModel which will request data from the given \a manager
     * and cache approximately \a cacheSize contacts.
     *
     * \sa setManager(), setCacheSize()
     */</span>
    QContactListModel::QContactListModel(QContactManager* manager, int cacheSize)
            : QAbstractListModel(),
            d(new QContactListModelPrivate)
    {
        setCacheSize(cacheSize);
        setManager(manager);
    }

<span class="comment">    /*!
     * Constructs a new copy of the \a other model
     */</span>
    QContactListModel::QContactListModel(const QContactListModel&amp; other)
            : QAbstractListModel(), d(other.d)
    {
    }

<span class="comment">    /*!
     * Assigns this model to be equal to \a other
     */</span>
    QContactListModel&amp; QContactListModel::operator=(const QContactListModel&amp; other)
    {
        d = other.d;
        return *this;
    }

<span class="comment">    /*!
     * Cleans up any memory in use by the model
     */</span>
    QContactListModel::~QContactListModel()
    {
    }

<span class="comment">    /*!
     * Returns a pointer to the manager from which this model requests contact data
     */</span>
    QContactManager* QContactListModel::manager() const
    {
        return d-&gt;m_manager;
    }

<span class="comment">    /*!
     * Sets the manager from which this model requests contact data to \a manager.
     * Any requests made of the old manager will be cancelled and deleted.
     *
     * \sa backendChanged()
     */</span>
    void QContactListModel::setManager(QContactManager* manager)
    {
        <span class="comment">// first, cancel and delete any requests made of the old manager</span>
        QMap&lt;QContactAbstractRequest*, int&gt; updatedRequestCentreRows;
        QList&lt;QContactAbstractRequest*&gt; requests = d-&gt;m_requestCentreRows.keys();
        for (int i = 0; i &lt; requests.size(); i++) {
            QContactAbstractRequest* current = requests.at(i);
            if (current-&gt;manager() == d-&gt;m_manager) {
                current-&gt;cancel();
                delete current;
            } else {
                updatedRequestCentreRows.insert(current, d-&gt;m_requestCentreRows.value(current));
            }
        }
        d-&gt;m_requestCentreRows = updatedRequestCentreRows;

        <span class="comment">// secondly, disconnect the signals from the old manager</span>
        if (d-&gt;m_manager)
            d-&gt;m_manager-&gt;disconnect(this);

        <span class="comment">// then set up the new manager.</span>
        d-&gt;m_manager = manager;
        delete d-&gt;m_idRequest;
        d-&gt;m_idRequest = new QContactLocalIdFetchRequest;
        connect(d-&gt;m_idRequest, SIGNAL(progress(QContactLocalIdFetchRequest*,bool)), this, SLOT(contactIdFetchRequestProgress(QContactLocalIdFetchRequest*,bool)));
        d-&gt;m_idRequest-&gt;setManager(manager);
        if (manager) {
            connect(manager, SIGNAL(contactsAdded(QList&lt;QContactLocalId&gt;)), this, SLOT(backendChanged()));
            connect(manager, SIGNAL(contactsChanged(QList&lt;QContactLocalId&gt;)), this, SLOT(backendChanged()));
            connect(manager, SIGNAL(contactsRemoved(QList&lt;QContactLocalId&gt;)), this, SLOT(backendChanged()));
        }

        <span class="comment">// and kick of a request for the ids.</span>
        backendChanged();
    }

<span class="comment">    /*!
     * Returns the number of contacts that this model will cache
     */</span>
    int QContactListModel::cacheSize() const
    {
        return (d-&gt;m_halfCacheSize * 2);
    }

<span class="comment">    /*!
     * Sets the number of contacts that this model will cache to be approximately \a size contacts.
     * The exact size of the cache will be the next higher size which is divisible by 4, or
     * \a size if \a size is divisible by 4, unless the next higher size would cause integer overflow.
     * Returns true if the cache size was set successfully, and false if a non-positive \a size was
     * specified.
     *
     * \sa cacheSize()
     */</span>
    bool QContactListModel::setCacheSize(int size)
    {
        <span class="comment">// size will be rounded up to nearest where modulo 4 == 0,</span>
        <span class="comment">// except where doing so would result in integer overflow</span>
        <span class="comment">// (where it will be rounded down)</span>
        if (size &gt; 0) {
            <span class="comment">// if the cache size is odd, round up to nearest even then test modulo 4</span>
            <span class="comment">// this allows us to cache m_halfCacheSize rows either side of currentRow</span>
            int modulo4 = size % 4;
            if (modulo4 == 0) {
                d-&gt;m_halfCacheSize = size / 2;
                d-&gt;m_quarterCacheSize = size / 4;
            } else {
                int test = size + (4 - modulo4); <span class="comment">// avoid integer overflow.</span>
                d-&gt;m_halfCacheSize = (test &lt; 0 ? (size - modulo4) : (size + 4 - modulo4));
                d-&gt;m_halfCacheSize = d-&gt;m_halfCacheSize / 2;
                d-&gt;m_quarterCacheSize = d-&gt;m_halfCacheSize / 2;
            }
            return true;
        }

        return false;
    }

<span class="comment">    /*!
     * Returns the policy that the model uses to determine when asynchronous requests should be cleaned up.
     *
     * \sa setRequestPolicy()
     */</span>
    QContactListModel::AsynchronousRequestPolicy QContactListModel::requestPolicy() const
    {
        return d-&gt;m_requestPolicy;
    }

<span class="comment">    /*!
     * Sets the policy that the model uses to determine when to clean up asynchronous requests to \a policy.
     *
     * \sa requestPolicy()
     */</span>
    void QContactListModel::setRequestPolicy(QContactListModel::AsynchronousRequestPolicy policy)
    {
        d-&gt;m_requestPolicy = policy;
    }

<span class="comment">    /*!
     * Returns the definition name of the relevant data detail which is cached by the model
     *
     * \sa setRelevantDetailDefinitionAndFieldNames()
     */</span>
    QString QContactListModel::relevantDefinitionName() const
    {
        return d-&gt;m_relevantDefinitionName;
    }

<span class="comment">    /*!
     * Returns the name of the field of the relevant data detail which is cached by the model
     *
     * \sa setRelevantDetailDefinitionAndFieldNames()
     */</span>
    QString QContactListModel::relevantFieldName() const
    {
        return d-&gt;m_relevantFieldName;
    }

<span class="comment">    /*!
     * Sets the definition name of the relevant detail which is cached by the model to \a definitionName,
     * and the name of the field of such details which is cached to \a fieldName.
     *
     * \sa relevantDefinitionName(), relevantFieldName()
     */</span>
    bool QContactListModel::setRelevantDetailDefinitionAndFieldNames(const QString&amp; definitionName, const QString&amp; fieldName)
    {
        if (definitionName.isEmpty() || fieldName.isEmpty())
            return false;

        d-&gt;m_relevantDefinitionName = definitionName;
        d-&gt;m_relevantFieldName = fieldName;
        return true;
    }

<span class="comment">    /*!
     * \reimp
     */</span>
    int QContactListModel::rowCount(const QModelIndex&amp; parent) const
    {
        Q_UNUSED(parent);
        return d-&gt;m_rowsToIds.count();
    }

<span class="comment">    /*!
     * \reimp
     */</span>
    QVariant QContactListModel::data(const QModelIndex&amp; index, int role) const
    {
        if (index.row() == -1)
            return QVariant();

        d-&gt;m_currentRow = index.row();
        QContact currentContact = d-&gt;m_cache.value(d-&gt;m_currentRow);

        <span class="comment">// check to see if we need to update our cache</span>
        bool cacheUpdateRequired = d-&gt;m_cache.isEmpty();
        if ((d-&gt;m_halfCacheSize * 2) &lt; d-&gt;m_rowsToIds.count()) {
            <span class="comment">// we cannot fit the entire dataset into our cache; calculate window size.</span>
            int maxActiveCacheRow = d-&gt;m_currentRow + d-&gt;m_quarterCacheSize;
            int minActiveCacheRow = d-&gt;m_currentRow - d-&gt;m_quarterCacheSize;
            if (maxActiveCacheRow &lt;= d-&gt;m_lastCacheCentreRow) {
                cacheUpdateRequired = true;
            } else if (minActiveCacheRow &gt;= d-&gt;m_lastCacheCentreRow) {
                cacheUpdateRequired = true;
            }
        }

        if (cacheUpdateRequired) {
            <span class="comment">// the current row will be our new cache centre point.</span>
            d-&gt;m_lastCacheCentreRow = d-&gt;m_currentRow;

            <span class="comment">// update our cache - first calculate the new cache window.</span>
            int lowerBound = d-&gt;m_lastCacheCentreRow - d-&gt;m_halfCacheSize;
            int upperBound = d-&gt;m_lastCacheCentreRow + d-&gt;m_halfCacheSize;

            <span class="comment">// create a list of rows we need to cache</span>
            QList&lt;int&gt; newCacheRows;
            if ((upperBound - lowerBound) &gt;= d-&gt;m_rowsToIds.count()) {
                <span class="comment">// we can cache the entire dataset.</span>
                newCacheRows = d-&gt;m_rowsToIds.keys();
            } else {
                <span class="comment">// we can only cache a window of the entire dataset.</span>
                for (int i = lowerBound; i &lt;= upperBound; i++) {
                    <span class="comment">// wrap-around at top and bottom of cache.</span>
                    int rowNumber = i;
                    if (i &lt; 0)
                        rowNumber += d-&gt;m_rowsToIds.count();
                    if (i &gt;= d-&gt;m_rowsToIds.count())
                        rowNumber -= d-&gt;m_rowsToIds.count();
                    newCacheRows.append(rowNumber);
                }
            }

            <span class="comment">// clean up any old requests depending on policy</span>
            <span class="comment">// please note that this branching is _slow_; might be best to remove it</span>
            <span class="comment">// and just always do the default (cancel on cache centrepoint miss)...</span>
            if (d-&gt;m_requestPolicy != QContactListModel::NeverCancelPolicy) {
                QList&lt;QContactAbstractRequest*&gt; oldRequests = d-&gt;m_requestCentreRows.keys();
                bool cancelRequest = false;

                <span class="comment">// we could pull the conditionals outside the loop for better performance...</span>
                for (int i = 0; i &lt; oldRequests.size(); i++) {
                    QContactAbstractRequest* current = oldRequests.at(i);
                    if (d-&gt;m_requestPolicy == QContactListModel::CancelOnCacheUpdatePolicy) {
                        <span class="comment">// immediately cancel since update is required.</span>
                        cancelRequest = true;
                    } else if (d-&gt;m_requestPolicy == QContactListModel::CancelOnCacheMissPolicy) {
                        <span class="comment">// slow solution... should probably do bounds checking instead of .contains().</span>
                        if (!newCacheRows.contains(d-&gt;m_requestCentreRows.value(current))) {
                            cancelRequest = true;
                        }
                    } else {
                        int cacheSize = d-&gt;m_halfCacheSize * 2;
                        int requestCentre = d-&gt;m_requestCentreRows.value(current);
                        int requestWindowMax = (requestCentre + d-&gt;m_halfCacheSize) % cacheSize;
                        int requestWindowMin = (requestCentre - d-&gt;m_halfCacheSize) % cacheSize;
                        <span class="comment">// slow solution... should probably do bounds checking instead of .contains().</span>
                        if (!newCacheRows.contains(requestWindowMax) &amp;&amp; !newCacheRows.contains(requestWindowMin) &amp;&amp; !newCacheRows.contains(requestCentre)) {
                            cancelRequest = true;
                        }
                    }

                    <span class="comment">// cancel (and clean up) the request if required by the policy.</span>
                    if (cancelRequest) {
                        current-&gt;cancel();
                        d-&gt;m_requestCentreRows.remove(current);
                        delete current;
                    }

                    <span class="comment">// reset the control variable.</span>
                    cancelRequest = false;
                }
            }

            <span class="comment">// create &quot;spots&quot; for the cache entries in our cache map</span>
            QList&lt;int&gt; oldCacheRows = d-&gt;m_cache.keys();
            foreach (int row, newCacheRows) {
                if (!d-&gt;m_cache.contains(row)) {
                    QContact temp;
                    QContactName loadingName;
                    loadingName.setCustomLabel(QString(tr(&quot;Loading...&quot;)));
                    temp.saveDetail(&amp;loadingName);
                    d-&gt;m_cache.insert(row, temp);
                }
            }

            <span class="comment">// remove any out-of-cache-window contacts we have stored</span>
            <span class="comment">// and remove from the newCacheRows any rows we already have cached</span>
            foreach (int row, oldCacheRows) {
                if (row &lt; lowerBound || row &gt; upperBound) {
                    <span class="comment">// don't want to cache this row.</span>
                    d-&gt;m_cache.remove(row);
                }

                if (newCacheRows.contains(row)) {
                    <span class="comment">// already have this row in cache.</span>
                    newCacheRows.removeOne(row);
                }
            }

            <span class="comment">// ensure that the current row's contact is cached; if not create a placeholder.</span>
            if (!d-&gt;m_cache.contains(d-&gt;m_currentRow)) {
                QContactName loadingName;
                loadingName.setCustomLabel(QString(tr(&quot;Loading...&quot;)));
                currentContact.saveDetail(&amp;loadingName);
            }

            <span class="comment">// now fire off an asynchronous request to update our cache</span>
            QContactFetchRequest* req = new QContactFetchRequest;
            d-&gt;m_requestCentreRows.insert(req, d-&gt;m_lastCacheCentreRow);
            QContactLocalIdFilter idFil;
            QList&lt;QContactLocalId&gt; newCacheIds;
            for (int i = 0; i &lt; newCacheRows.size(); i++) {
                newCacheIds.append(d-&gt;m_rowsToIds.value(newCacheRows.at(i)));
            }
            idFil.setIds(newCacheIds);
            req-&gt;setFilter(idFil);
            req-&gt;setManager(d-&gt;m_manager);
            connect(req, SIGNAL(progress(QContactFetchRequest*, bool)), this, SLOT(contactFetchRequestProgress(QContactFetchRequest*,bool)));
            req-&gt;start();
        }

        <span class="comment">// now return the data being requested.</span>
        QVariant ret;
        switch (role) {
            case QContactListModel::DisplayLabelRole:
            {
                ret = currentContact.displayLabel();
            }
            break;

            case QContactListModel::IdRole:
            {
                ret = currentContact.id().localId();
            }
            break;

            case QContactListModel::AvatarRole:
            {
                ret = currentContact.detail(QContactAvatar::DefinitionName).value(QContactAvatar::FieldAvatar);
            }
            break;

            case QContactListModel::PresenceRole:
            {
                if (d-&gt;m_manager == 0) {
                    <span class="comment">// the manager has not been initialised.</span>
                    break;
                }

                <span class="comment">// grab the possible presence values; they should be in order from (unknown) to least present to most present.</span>
                QContactDetailDefinition presenceDef = d-&gt;m_manager-&gt;detailDefinition(QContactOnlineAccount::DefinitionName);
                QList&lt;QVariant&gt; allowablePresenceValues = presenceDef.fields().value(QContactOnlineAccount::FieldPresence).allowableValues();
                if (presenceDef.isEmpty() || allowablePresenceValues.isEmpty()) {
                    <span class="comment">// the manager does not support presence details.</span>
                    break;
                }

                <span class="comment">// calculate the &quot;global presence&quot; of the contact in a naive way.</span>
                int bestPresenceSoFar = 0; <span class="comment">// unknown</span>
                QList&lt;QContactDetail&gt; presenceDetails = currentContact.details(QContactOnlineAccount::DefinitionName);
                foreach (const QContactOnlineAccount&amp; pres, presenceDetails) {
                    int index = allowablePresenceValues.indexOf(pres.presence());
                    if (index &gt; bestPresenceSoFar) {
                        bestPresenceSoFar = index;
                    }
                }

                ret = QVariant(allowablePresenceValues.at(bestPresenceSoFar));
            }
            break;

            case QContactListModel::RelevantDataRole:
            {
                ret = currentContact.detail(d-&gt;m_relevantDefinitionName).value(d-&gt;m_relevantFieldName);
            }
            break;

            default:
            break;
        }

        <span class="comment">// return the requested data, or a default-constructed QVariant if not available.</span>
        return ret;
    }

<span class="comment">    /*!
     * \reimp
     */</span>
    QVariant QContactListModel::headerData(int section, Qt::Orientation orientation, int role) const
    {
        Q_UNUSED(section);
        Q_UNUSED(orientation);

        QVariant ret;
        switch (role) {
            case QContactListModel::DisplayLabelRole:
            {
                ret = QString(tr(&quot;Name&quot;));
            }
            break;

            case QContactListModel::IdRole:
            {
                ret = QString(tr(&quot;Id&quot;));
            }
            break;

            case QContactListModel::AvatarRole:
            {
                ret = QString(tr(&quot;Avatar&quot;));
            }
            break;

            case QContactListModel::PresenceRole:
            {
                ret = QString(tr(&quot;Presence&quot;));
            }
            break;

            case QContactListModel::RelevantDataRole:
            {
                <span class="comment">// todo: take this as an argument in setRelevant()</span>
                ret = QString(tr(&quot;Details&quot;));
            }
            break;

            default:
            break;
        }

        return ret;
    }

<span class="comment">    /*!
     * \reimp
     */</span>
    bool QContactListModel::insertRows(int row, int count, const QModelIndex&amp; parent)
    {
        beginInsertRows(parent, row, count);

        <span class="comment">// insertion code here.</span>

        endInsertRows();

        return false;
    }

<span class="comment">    /*!
     * \reimp
     */</span>
    bool QContactListModel::removeRows(int row, int count, const QModelIndex&amp; parent)
    {
        beginRemoveRows(parent, row, count);

        <span class="comment">// removal code here.</span>

        endRemoveRows();

        return false;
    }

<span class="comment">    /*!
     * Returns the row number at which the data of the contact with the given \a contactId is stored, or
     * -1 if no such contact exists in the model
     */</span>
    int QContactListModel::contactRow(const QContactLocalId&amp; contactId) const
    {
        return d-&gt;m_idsToRows.value(contactId, -1);
    }

<span class="comment">    /*!
     * Returns the entire contact which exists in the model at the specified \a index
     */</span>
    QContact QContactListModel::contact(const QModelIndex&amp; index) const
    {
        if (d-&gt;m_manager)
            return d-&gt;m_manager-&gt;contact(d-&gt;m_rowsToIds.value(index.row()));
        return QContact();
    }

<span class="comment">    /*!
     * Processes the progress of the \a request.
     * If the request is still valid, the results are placed in the cache at the required positions.
     * If the cache is updated, the dataChanged() signal is emitted.
     * This implementation ignores the \a appendOnly flag.
     */</span>
    void QContactListModel::contactFetchRequestProgress(QContactFetchRequest* request, bool appendOnly)
    {
        Q_UNUSED(appendOnly);

        <span class="comment">// first, check to make sure that the request is still valid.</span>
        if (d-&gt;m_manager != request-&gt;manager() || request-&gt;status() == QContactAbstractRequest::Cancelled) {
            d-&gt;m_requestCentreRows.remove(request);
            delete request;
            return; <span class="comment">// ignore these results.</span>
        }

        QMap&lt;int, int&gt; rowMap; <span class="comment">// sorted list of rows changed.</span>
        QList&lt;QContact&gt; fetched = request-&gt;contacts();
        foreach (const QContact&amp; c, fetched) {
            int fetchedRow = d-&gt;m_idsToRows.value(c.id().localId(), -1);

            <span class="comment">// see if this row should be cached</span>
            if (!d-&gt;m_cache.contains(fetchedRow))
                break; <span class="comment">// shouldn't cache this row (or already cached); ignore the contact.</span>

            <span class="comment">// we need to cache this contact.</span>
            d-&gt;m_cache.insert(fetchedRow, c);
            rowMap.insert(fetchedRow, fetchedRow);
        }

        <span class="comment">// check to see if the request status is &quot;finished&quot; - clean up.</span>
        if (request-&gt;status() == QContactAbstractRequest::Finished) {
            d-&gt;m_requestCentreRows.remove(request);
            delete request;
        }

        <span class="comment">// emit data changed for those that have changed.</span>
        QList&lt;int&gt; rows = rowMap.keys();
        while (rows.size() &gt; 0) {
            <span class="comment">// we want to emit the dataChanged signal as few times as possible</span>
            <span class="comment">// so, we coalesce the changes into lumps of contiguous changes.</span>
            int lowestIndex = rows.at(0);
            int highestIndex = rows.at(0);
            int nbrAccountedFor = 1;
            int nbrRows = rows.size();
            while (nbrAccountedFor &lt; nbrRows) {
                int temp = highestIndex;
                highestIndex = rows.at(nbrAccountedFor);
                if ((highestIndex - temp) &gt; 1) {
                    highestIndex = temp;
                    break;
                }
                nbrAccountedFor += 1;
            }

            while (nbrAccountedFor &gt; 0) {
                rows.removeFirst();
                nbrAccountedFor -= 1;
            }

            <span class="comment">// calculate the indices of the boundaries, and emit the signal.</span>
            QModelIndex lowerBound = QAbstractItemModel::createIndex(lowestIndex, 0);
            QModelIndex upperBound = QAbstractItemModel::createIndex(highestIndex, 0);
            emit dataChanged(lowerBound, upperBound);
        }
    }

<span class="comment">    /*!
     * Processes the results of a contact id fetch request.
     * If the \a appendOnly flag is set, the new data is appended to the existing data
     * and the dataChanged() signal is emitted; otherwise, the model emits the reset() signal
     * once the new data has been loaded.
     */</span>
    void QContactListModel::contactIdFetchRequestProgress(QContactLocalIdFetchRequest* request, bool appendOnly)
    {
        <span class="comment">// first, if it's not append only, we need to rebuild the entire list + cache.</span>
        if (!appendOnly) {
            d-&gt;m_cache.clear();
            d-&gt;m_rowsToIds.clear();
            d-&gt;m_idsToRows.clear();
        }

        <span class="comment">// then get the results, calculate the start and end indices, and fill our data structures.</span>
        QList&lt;QContactLocalId&gt; ids = request-&gt;ids();
        int startIndex = d-&gt;m_idsToRows.count();
        int endIndex = ids.size();
        for (int i = startIndex; i &lt; endIndex; i++) {
            d-&gt;m_rowsToIds.insert(i, ids.at(i));
            d-&gt;m_idsToRows.insert(ids.at(i), i);
        }

        <span class="comment">// and if we need to, emit the reset signals.</span>
        if (!appendOnly)
            reset();
        else
            emit dataChanged(QAbstractItemModel::createIndex(startIndex,0), QAbstractItemModel::createIndex(endIndex,0));
    }

<span class="comment">    /*!
     * Requests data from the new backend.
     */</span>
    void QContactListModel::backendChanged()
    {
        d-&gt;m_idRequest-&gt;start();
        d-&gt;m_idRequest-&gt;waitForFinished();
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.0</div></td>
</tr></table></div></address></body>
</html>
