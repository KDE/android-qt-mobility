<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qlandmarks.qdoc -->
  <title>Qt 1.1: Landmark Examples</title>
  <link rel="stylesheet" type="text/css" href="style/style.css"
 />  <!--[if IE]>
<meta name="MSSmartTagsPreventParsing" content="true">
<meta http-equiv="imagetoolbar" content="no">
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie6.css">
<![endif]-->
<!--[if IE 7]>
<link rel="stylesheet" type="text/css" href="style/style_ie7.css">
<![endif]-->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="style/style_ie8.css">
<![endif]-->
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
 <script src="./scripts/superfish.js" type="text/javascript"></script>
 <script src="./scripts/narrow.js" type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="style/superfish.css" />  <link rel="stylesheet" type="text/css" href="style/narrow.css" /></head>
<body class="" onload="CheckEmptyAndLoadList();">
 <div class="header" id="qtdocheader">
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Mobility Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://qt.nokia.com/developer">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
        <li class="nav-topright-shop"><a title="SHOP" href="http://shop.qt.nokia.com">SHOP</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Mobility 1.1</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://qt.nokia.com/doc/">ALL Qt VERSIONS        </a></li>
      </ul>
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="index.html#platform-compatibility">Platform Compatibility</a></li>
              <li class="defaultLink"><a href="qml-plugins.html">QML Plugins</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/">Qt 4.7</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/qt-basic-concepts.html">Basic Qt architecture</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/declarativeui.html">Device UI's &amp; Qt Quick</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/qt-gui-concepts.html">Desktop UI components</a></li>
              <li class="defaultLink"><a href="http://doc.qt.nokia.com/4.7-snapshot/platform-specific.html">Platform-specific info</a></li>
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li>Landmark Examples</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
          </div>
        </div>
        <div class="content">
<div class="toc">
<h3>Contents</h3>
<ul>
<li class="level1"><a href="#namespace">Namespace</a></li>
<li class="level1"><a href="#creating-categories-and-landmarks">Creating categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#creating-a-category"><b>Creating a category</b></a></li>
<li class="level3"><a href="#creating-landmark"><b>Creating landmark</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#creating-a-category"><b>Creating a category</b></a></li>
<li class="level3"><a href="#creating-a-landmark"><b>Creating a landmark</b></a></li>
<li class="level1"><a href="#retrieving-categories-and-landmarks">Retrieving categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#retrieving-categories"><b>Retrieving categories</b></a></li>
<li class="level3"><a href="#retrieving-landmarks"><b>Retrieving landmarks</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#retrieving-categories"><b>Retrieving categories</b></a></li>
<li class="level3"><a href="#retrieving-landmarks"><b>Retrieving landmarks</b></a></li>
<li class="level1"><a href="#deleting-categories-and-landmarks">Deleting categories and landmarks</a></li>
<li class="level2"><a href="#synchronous">Synchronous</a></li>
<li class="level3"><a href="#deleting-a-category"><b>Deleting a category</b></a></li>
<li class="level3"><a href="#deleting-a-landmark"><b>Deleting a landmark</b></a></li>
<li class="level2"><a href="#asynchronous">Asynchronous</a></li>
<li class="level3"><a href="#deleting-a-category"><b>Deleting a category</b></a></li>
<li class="level3"><a href="#deleting-a-landmark"><b>Deleting a landmark</b></a></li>
</ul>
</div>
<h1 class="title">Landmark Examples</h1>
<span class="subtitle"></span>
<div class="descr"/>
<p><b>Note:</b> This API and documentation is a <b>Technology Preview</b> and is still subject to change.</p>
<p>The Landmarks portion of the Location API facilitates the creation, retrieval, updating and deletion of landmarks from arbitrary data stores. The following page demonstrates how to perform these operations.</p>
<a name="namespace"></a>
<h2>Namespace</h2>
<p>The QtMobility APIs are placed into the <i>QtMobility</i> namespace. This is done to facilitate the future migration of Mobility APIs into Qt. See the <a href="quickstart.html">Quickstart guide</a> for an example on how the namespace impacts on application development.</p>
<a name="creating-categories-and-landmarks"></a>
<h2>Creating categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="creating-a-category"></a>
<h4><b>Creating a category</b></h4>
<p>The following example demonstrates how to synchronously add a category. We create a <a href="qlandmarkcategory.html">QLandmarkCategory</a> instance, set the desired properties and then use a <a href="qlandmarkmanager.html">QLandmarkManager</a> instance to save it. When the category is saved, it is assigned a <a href="qlandmarkcategoryid.html">QLandmarkCategoryId</a> which is why it passed as a pointer.</p>
<pre class="highlightedCode brush: cpp">     QLandmarkCategory cafes;
     cafes.setName(&quot;Cafes&quot;);
     cafes.setIconUrl(QUrl(&quot;cafe.png&quot;));
     lm-&gt;saveCategory(&amp;cafes);  <span class="comment">//lm is a QLandmarkManager *</span></pre>
<a name="creating-landmark"></a>
<h4><b>Creating landmark</b></h4>
<p>The following example demonstrate synchronously adding a landmark. We create a <a href="qlandmark.html">QLandmark</a> instance, set the desired properties and then use a QLandmarkMangerInstance to save it. When the landmark is saved, it is assigned a <a href="qlandmarkid.html">QLandmarkId</a>, which is why it is passed as a pointer.</p>
<pre class="highlightedCode brush: cpp">     QLandmark monks;
     monks.setName(&quot;Monk's cafe&quot;);
     monks.setCoordinate(QGeoCoordinate(40.81, 73.97));

     QGeoAddress address;
     address.setStreetNumber(&quot;2880&quot;);
     address.setStreet(&quot;112th Street&quot;);
     address.setCity(&quot;New York City&quot;);
     address.setState(&quot;New York&quot;);
     address.setCountry(&quot;United States&quot;);
     address.setCountryCode(&quot;US&quot;);
     monks.setAddress(address);

     monks.setDescription(&quot;Jerry's favourite diner&quot;);
     monks.addCategoryId(cafes.categoryId());

     lm-&gt;saveLandmark(&amp;monks); <span class="comment">//lm  is a QLandmarkManager*</span></pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="creating-a-category"></a>
<h4><b>Creating a category</b></h4>
<p>We create a <a href="qlandmarkcategory.html">QLandmarkCategory</a> instance and set the desired properties. Next we have an instance of a <a href="qlandmarkcategorysaverequest.html">QLandmarkCategorySaveRequest</a> and set its <a href="qlandmarkmanager.html">QLandmarkManager</a> and the append the category we want to save. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categorySaveRequest()
 {
     QLandmarkCategory cafes;
     cafes.setName(&quot;Cafes&quot;);
     cafes.setIconUrl(QUrl(&quot;cafe.png&quot;));

     <span class="comment">//catSaveRequest was created with catSaveRequest = new QLandmarkCategorySaveRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager *</span>
     catSaveRequest-&gt;setCategory(cafes);

     connect(catSaveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(categorySaveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!catSaveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to save category error code: &quot; &lt;&lt; catSaveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Saveing category; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the QLandmarkAbstractRequest::Finished state and see if there are any errors or not. We may reuse the <a href="qlandmarkcategorysaverequest.html">QLandmarkCategorySaveRequest</a> by setting another category and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categorySaveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (catSaveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Category save succesfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Category save was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="creating-a-landmark"></a>
<h4><b>Creating a landmark</b></h4>
<p>We create a <a href="qlandmark.html">QLandmark</a> instance and set the desired properties. Next we have an instance of a <a href="qlandmarksaverequest.html">QLandmarkSaveRequest</a> and set its <a href="qlandmarkmanager.html">QLandmarkManager</a> and the append the category we want to save. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkSaveRequest()
 {
     <span class="comment">//Creating and saving a landmark</span>
     QLandmark monks;
     monks.setName(&quot;Monk's cafe&quot;);
     monks.setCoordinate(QGeoCoordinate(40.81, 73.97));

     QGeoAddress address;
     address.setStreetNumber(&quot;2880&quot;);
     <span class="comment">// ...</span>
     address.setCountryCode(&quot;US&quot;);
     monks.setAddress(address);

     <span class="comment">//lmSaveRequest was created with lmSaveRequest = new QLandmarkSaveRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandamrkManager constructor</span>
     lmSaveRequest-&gt;setLandmark(monks);

     monks.setDescription(&quot;Jerry's favourite diner&quot;);

     connect(lmSaveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkSaveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmSaveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to save landmark error code: &quot; &lt;&lt; lmSaveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Saving landmark; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the QLandmarkAbstractRequest::Finished state and see if there are any errors or not. We may reuse the <a href="qlandmarksaverequest.html">QLandmarkSaveRequest</a> by setting another landmark and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkSaveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmSaveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark save succesfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark save was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="retrieving-categories-and-landmarks"></a>
<h2>Retrieving categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="retrieving-categories"></a>
<h4><b>Retrieving categories</b></h4>
<p>When retrieiving categories we may do so by the category ids. When the category data is needed we may use the id to retrieve a category object:</p>
<pre class="highlightedCode brush: cpp">     QList&lt;QLandmarkCategoryId&gt; categoryIds = lm-&gt;categoryIds();
     foreach(QLandmarkCategoryId id, categoryIds) {
         qDebug() &lt;&lt; &quot;Found category: &quot; &lt;&lt; lm-&gt;category(id).name();
     }</pre>
<p>Alternatively we could retrieve the category objects directly:</p>
<pre class="highlightedCode brush: cpp">     QList&lt;QLandmarkCategory&gt; categories = lm-&gt;categories();
     foreach(QLandmarkCategory category, categories) {
         qDebug() &lt;&lt; &quot;Found category: &quot; &lt;&lt; category.name();
     }</pre>
<a name="retrieving-landmarks"></a>
<h4><b>Retrieving landmarks</b></h4>
<p>To retrieve landmarks we create an appropriate filter, in this case a category filter, and use it with a sort order on a <a href="qlandmarkmanager.html">QLandmarkManager</a>. We can either retrieve the appropriate ids as shown below:</p>
<pre class="highlightedCode brush: cpp">     QLandmarkCategoryFilter filter;
     <span class="comment">//categoryId is a previously retrieved QLandmarkCategoryId</span>
     filter.setCategoryId(categoryId);

     <span class="comment">//retrieval via ids</span>
     QList&lt;QLandmarkId&gt; landmarkIds;
     QLandmarkNameSort sortOrder(Qt::AscendingOrder);
     landmarkIds = lm-&gt;landmarkIds(filter, -1, 0, sortOrder);
     foreach(QLandmarkId id, landmarkIds) {
         qDebug() &lt;&lt; &quot;Found landmark:&quot; &lt;&lt; lm-&gt;landmark(id).name();
     }</pre>
<p>Or alternatively retrieve the landmark objects directly:</p>
<pre class="highlightedCode brush: cpp">     QList&lt;QLandmark&gt; landmarks;
     landmarks = lm-&gt;landmarks(filter, -1, 0, sortOrder);
     foreach(QLandmark landmark, landmarks) {
         qDebug() &lt;&lt; &quot;Found landmark:&quot; &lt;&lt; landmark.name();
     }</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="retrieving-categories"></a>
<h4><b>Retrieving categories</b></h4>
<p>To retrieve categories we can use a <a href="qlandmarkcategoryfetchrequest.html">QLandmarkCategoryFetchRequest</a> (or if we wish to fetch id's then a <a href="qlandmarkcategoryidfetchrequest.html">QLandmarkCategoryIdFetchRequest</a>) and set its manager. The request's <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal is connected to a slot which detects whether the operation is complete. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//catFetchRequest was created with catFetchRequest = new QLandmarkCategoryFetchRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>

     connect(catFetchRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
             this, SLOT(categoryFetchRequestHandler(QLandmarkAbstractRequest::State)));

     if(!catFetchRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request categories, error code:&quot; &lt;&lt; catFetchRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested categories, awaiting results...&quot;;
     }</pre>
<p>For brevity, the slot does not process all the different request states. In our example, we watch for the QLandmarkAbstractRequest::Finished state and if there are no errors, print out the categories.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryFetchRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         previousLastIndex = 0;
         if (catFetchRequest-&gt;error() == QLandmarkManager::NoError) {
             QList&lt;QLandmarkCategory&gt; categories = catFetchRequest-&gt;categories();
             qDebug() &lt;&lt; &quot;Category fetch succesfully completed&quot;;
             for(int i=0; i &lt; categories.count(); ++i) {
                 qDebug() &lt;&lt; categories[i].name();
             }
         }
         else {
             qDebug() &lt;&lt; &quot;Category fetch was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="retrieving-landmarks"></a>
<h4><b>Retrieving landmarks</b></h4>
<p>To retrieve landmarks we create an appropriate filter, in this case a category filter, and use it with a sort order on a <a href="qlandmarkfetchrequest.html">QLandmarkFetchRequest</a>. (If we wanted to operate with ids we would use a <a href="qlandmarkidfetchrequest.html">QLandmarkIdFetchRequest</a>). We also set the manager of the request. The request's <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal is connected to a slot which detects whether the operation is complete. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a>.</p>
<pre class="highlightedCode brush: cpp">     QLandmarkCategoryFilter filter;
     QLandmarkNameSort sort(Qt::AscendingOrder);
     <span class="comment">//categoryId is a previously retrieved QLandmarkCategoryId</span>
     filter.setCategoryId(categoryId);

     <span class="comment">//lmFetchRequest was created with lmFetchRequest = new QLandmarkFetchRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManger *</span>
     lmFetchRequest-&gt;setFilter(filter);
     lmFetchRequest-&gt;setSorting(sort);

     connect(lmFetchRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
             this, SLOT(landmarkFetchRequestHandler(QLandmarkAbstractRequest::State)));

     if(!lmFetchRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request landmarks, error code:&quot; &lt;&lt; lmFetchRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested landmarks, awaiting results...&quot;;
     }</pre>
<p>For brevity, the slot does not process all the different request states. In our example, we watch for the QLandmarkAbstractRequest::Finished state and if there are no errors, print out the landmarks.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkFetchRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         previousLastIndex = 0;
         if (lmFetchRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark fetch succesfully completed&quot;;
             QList&lt;QLandmark&gt; landmarks = lmFetchRequest-&gt;landmarks();
             for(int i=0; i &lt; landmarks.count(); ++i) {
                 qDebug() &lt;&lt; landmarks[i].name();
             }
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark fetch was unsuccessful&quot;;
         }
     }
 }</pre>
<a name="deleting-categories-and-landmarks"></a>
<h2>Deleting categories and landmarks</h2>
<a name="synchronous"></a>
<h3>Synchronous</h3>
<a name="deleting-a-category"></a>
<h4><b>Deleting a category</b></h4>
<p>To remove a category we simply pass the category id to a <a href="qlandmarkmanager.html">QLandmarkManager</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//category is a previously retrieved QLandmarkCategory object</span>
     lm-&gt;removeCategory(category.categoryId());</pre>
<a name="deleting-a-landmark"></a>
<h4><b>Deleting a landmark</b></h4>
<p>To remove a landmark we simply passs the landmark id to a <a href="qlandmarkmanager.html">QLandmarkManager</a>.</p>
<pre class="highlightedCode brush: cpp">     <span class="comment">//landmark is a previously retrieved QLandmark object</span>
     lm-&gt;removeLandmark(landmark.landmarkId());</pre>
<a name="asynchronous"></a>
<h3>Asynchronous</h3>
<a name="deleting-a-category"></a>
<h4><b>Deleting a category</b></h4>
<p>To remove a category we use a <a href="qlandmarkcategoryremoverequest.html">QLandmarkCategoryRemoveRequest</a> and set its manager and the id of the category we want to remove. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryRemoveRequest()
 {
     <span class="comment">//catRemoveRequest was created with catRemoveRequest = new QLandmarkCategoryRemoveRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>
     catRemoveRequest-&gt;setCategoryId(category.categoryId()); <span class="comment">//category is a previously retrieved QLandmarkCategory</span>

     connect(catRemoveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
         this, SLOT(categoryRemoveRequestHandler(QLandmarkAbstractRequest::State)));

     if(!catRemoveRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request category removal, error code:&quot; &lt;&lt; catRemoveRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested category removal, awaiting results...&quot;;
     }
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the QLandmarkAbstractRequest::Finished state and see if there are any errors or not. We may reuse the <a href="qlandmarkcategoryremoverequest.html">QLandmarkCategoryRemoveRequest</a> by setting another category id and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::categoryRemoveRequest()
 {
     <span class="comment">//catRemoveRequest was created with catRemoveRequest = new QLandmarkCategoryRemoveRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>
     catRemoveRequest-&gt;setCategoryId(category.categoryId()); <span class="comment">//category is a previously retrieved QLandmarkCategory</span>

     connect(catRemoveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)),
         this, SLOT(categoryRemoveRequestHandler(QLandmarkAbstractRequest::State)));

     if(!catRemoveRequest-&gt;start()) {
         qDebug() &lt;&lt; &quot;Unable to request category removal, error code:&quot; &lt;&lt; catRemoveRequest-&gt;error();
         QCoreApplication::exit(0);
     } else {
         qDebug() &lt;&lt; &quot;Requested category removal, awaiting results...&quot;;
     }
 }</pre>
<a name="deleting-a-landmark"></a>
<h4><b>Deleting a landmark</b></h4>
<p>To remove a landmark we use a <a href="qlandmarkremoverequest.html">QLandmarkRemoveRequest</a> and set its manager and the id of the landmark we want to remove. We then connect the <a href="qlandmarkabstractrequest.html#stateChanged">stateChanged()</a> signal up to a slot which watches the state of the request. To begin the request we invoke <a href="qlandmarkabstractrequest.html#start">start()</a></p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkRemoveRequest()
 {
     <span class="comment">//lmRemoveRequest was created with lmRemoveRequest = new QLandmarkSaveRequest(lmManager)</span>
     <span class="comment">//in the ctor, where lmManager is a QLandmarkManager*</span>
     lmRemoveRequest-&gt;setLandmarkId(landmark.landmarkId());  <span class="comment">//landmark is a previously retrieved QLandmark</span>

     connect(lmRemoveRequest, SIGNAL(stateChanged(QLandmarkAbstractRequest::State)), this,
             SLOT(landmarkRemoveRequestHandler(QLandmarkAbstractRequest::State)));
     if (!lmRemoveRequest-&gt;start())
         qDebug() &lt;&lt; &quot;Unable to remove landmark, error code: &quot; &lt;&lt; lmSaveRequest-&gt;error();
     else
         qDebug() &lt;&lt; &quot;Removing landmark; awaiting results...&quot;;
 }</pre>
<p>For brevity, the slot does not process all the different request states. In our example we watch for the QLandmarkAbstractRequest::Finished state and see if there are any errors or not. We may reuse the <a href="qlandmarkremoverequest.html">QLandmarkRemoveRequest</a> by setting another category id and running <a href="qlandmarkabstractrequest.html#start">start()</a> again.</p>
<pre class="highlightedCode brush: cpp"> void RequestExample::landmarkRemoveRequestHandler(QLandmarkAbstractRequest::State state)
 {
     if (state == QLandmarkAbstractRequest::FinishedState) {
         if (lmRemoveRequest-&gt;error() == QLandmarkManager::NoError) {
             qDebug() &lt;&lt; &quot;Landmark removal succesfully completed&quot;;
         }
         else {
             qDebug() &lt;&lt; &quot;Landmark removal was unsuccessful&quot;;
         }
     }
 }</pre>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009-2010 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.1.0</div></td>
</tr></table></div></address>  <script src="scripts/functions.js" type="text/javascript"></script>
</body>
</html>
