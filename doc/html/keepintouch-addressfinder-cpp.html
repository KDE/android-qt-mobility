<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt Mobility Project 1.0: addressfinder.cpp Example File (keepintouch/addressfinder.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">addressfinder.cpp Example File<br /><span class="small-subtitle">keepintouch/addressfinder.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;addressfinder.h&quot;
    #include &lt;qmessageaddress.h&gt;
    #include &lt;QComboBox&gt;
    #include &lt;QDateTime&gt;
    #include &lt;QGroupBox&gt;
    #include &lt;QLabel&gt;
    #include &lt;QLayout&gt;
    #include &lt;QListWidget&gt;
    #include &lt;QPushButton&gt;
    #include &lt;QTimer&gt;
    #include &lt;QDebug&gt;
    #include &lt;QApplication&gt;
    #include &lt;QMenuBar&gt;
    #include &lt;QTabWidget&gt;

    AddressFinder::AddressFinder(QWidget *parent, Qt::WindowFlags flags)
        : QMainWindow(parent, flags),
          tabWidget(0),
          includePeriod(0),
          excludePeriod(0),
          searchAction(0),
          searchButton(0),
          addressList(0),
          messageCombo(0)
     {
        setupUi();

        connect(&amp;service, SIGNAL(stateChanged(QMessageServiceAction::State)), this, SLOT(stateChanged(QMessageServiceAction::State)));
        connect(&amp;service, SIGNAL(messagesFound(QMessageIdList)), this, SLOT(messagesFound(QMessageIdList)));
    }

    AddressFinder::~AddressFinder()
    {
    }

    void AddressFinder::includePeriodChanged(int selected)
    {
        <span class="comment">// Only allow smaller periods to be excluded</span>
        excludePeriod-&gt;clear();

        switch (selected) {
            case 0: excludePeriod-&gt;insertItem(0, &quot;9 Months&quot;); <span class="comment">// fall through:</span>
            case 1: excludePeriod-&gt;insertItem(0, &quot;6 Months&quot;);
            case 2: excludePeriod-&gt;insertItem(0, &quot;3 Months&quot;);
            case 3: excludePeriod-&gt;insertItem(0, &quot;Month&quot;);
            case 4: excludePeriod-&gt;insertItem(0, &quot;Week&quot;);
            case 5: excludePeriod-&gt;insertItem(0, &quot;Second&quot;);
            default: break;
        }

        excludePeriod-&gt;setCurrentIndex(0);
    }

    void AddressFinder::addressSelected(const QString &amp;address)
    {
        QString name;
        QString addressOnly;
        QMessageAddress::parseEmailAddress(address, &amp;name, &amp;addressOnly);
        messageCombo-&gt;clear();

        foreach (const QString &amp;message, addressMessages[addressOnly]) {
            messageCombo-&gt;addItem(message);
        }
    }

    void AddressFinder::searchMessages()
    {
        setSearchActionEnabled(false);

        addressList-&gt;clear();
        messageCombo-&gt;clear();
        excludedAddresses.clear();
        includedAddresses.clear();
        addressMessages.clear();

        QDateTime now(QDateTime::currentDateTime());

        QDateTime minimumDate(now);
        switch (includePeriod-&gt;currentIndex()) {
            case 0: minimumDate = minimumDate.addMonths(-12); break;
            case 1: minimumDate = minimumDate.addMonths(-9); break;
            case 2: minimumDate = minimumDate.addMonths(-6); break;
            case 3: minimumDate = minimumDate.addMonths(-3); break;
            case 4: minimumDate = minimumDate.addMonths(-1); break;
            case 5: minimumDate = minimumDate.addDays(-7); break;
            default: break;
        }

        QDateTime maximumDate(now);
        switch (excludePeriod-&gt;currentIndex()) {
            case 0: maximumDate = maximumDate.addSecs(-1); break;
            case 1: maximumDate = maximumDate.addDays(-7); break;
            case 2: maximumDate = maximumDate.addMonths(-1); break;
            case 3: maximumDate = maximumDate.addMonths(-3); break;
            case 4: maximumDate = maximumDate.addMonths(-6); break;
            case 5: maximumDate = maximumDate.addMonths(-9); break;
            default: break;
        }

        QMessageFilter includeFilter((QMessageFilter::byTimeStamp(minimumDate, QMessageDataComparator::GreaterThanEqual))
            | (QMessageFilter::byReceptionTimeStamp(minimumDate, QMessageDataComparator::GreaterThanEqual)));
        QMessageFilter excludeFilter((QMessageFilter::byTimeStamp(maximumDate, QMessageDataComparator::GreaterThanEqual))
            | (QMessageFilter::byReceptionTimeStamp(maximumDate, QMessageDataComparator::GreaterThanEqual)));
        QMessageFilter sentFilter(QMessageFilter::byStandardFolder(QMessage::SentFolder));

        <span class="comment">// Search for messages containing addresses to exclude</span>
        service.queryMessages(sentFilter &amp; excludeFilter);

        <span class="comment">// Create the filter needed to locate messages to search for addresses</span>
        inclusionFilter = (sentFilter &amp; includeFilter &amp; ~excludeFilter);
    }

    void AddressFinder::stateChanged(QMessageServiceAction::State s)
    {
        if (s == QMessageServiceAction::Successful) {
            if (!inclusionFilter.isEmpty()) {
                <span class="comment">// Now find the included messages</span>
                service.queryMessages(inclusionFilter);
                inclusionFilter = QMessageFilter();
            } else {
                <span class="comment">// We have found the message sets to process</span>
                if (!inclusionMessages.isEmpty()) {
                    QTimer::singleShot(0, this, SLOT(continueSearch()));
                } else {
                    searchAction-&gt;setEnabled(true);
    #ifndef _WIN32_WCE
                    searchButton-&gt;setEnabled(true);
    #endif
                }
            }
        } else if (s == QMessageServiceAction::Failed) {
            qWarning() &lt;&lt; &quot;Search failed!&quot;;
            setSearchActionEnabled(true);
        }
    }

    void AddressFinder::messagesFound(const QMessageIdList &amp;ids)
    {
        if (!inclusionFilter.isEmpty()) {
            exclusionMessages &lt;&lt; ids;
        } else {
            inclusionMessages &lt;&lt; ids;
        }
    }

    void AddressFinder::continueSearch()
    {
        QString name;
        QString addressOnly;
        if (!exclusionMessages.isEmpty()) {
            QMessageId id(exclusionMessages.takeFirst());
            const QMessage message(id);

            <span class="comment">// All recipient addresses are to be excluded</span>
            foreach (const QMessageAddress &amp;address, message.to() + message.cc() + message.bcc()) {
                QMessageAddress::parseEmailAddress(address.recipient(), &amp;name, &amp;addressOnly);
                if (!excludedAddresses.contains(addressOnly))
                    qDebug() &lt;&lt; &quot;Exclude&quot; &lt;&lt; addressOnly;
                excludedAddresses.insert(addressOnly);
            }
        } else if (!inclusionMessages.isEmpty()) {
            QMessageId id(inclusionMessages.takeFirst());
            const QMessage message(id);

            <span class="comment">// Determine the properties of the message</span>
            QString details(QString(&quot;[%1] %2&quot;).arg(message.date().toString(&quot;MMM d&quot;)).arg(message.subject()));

            foreach (const QMessageAddress &amp;address, message.to() + message.cc() + message.bcc()) {
                QString recipient(address.recipient());
                QMessageAddress::parseEmailAddress(address.recipient(), &amp;name, &amp;addressOnly);
                if (!includedAddresses.contains(addressOnly))
                    qDebug() &lt;&lt; &quot;Include&quot; &lt;&lt; addressOnly;
                includedAddresses.insert(addressOnly);
                if (!excludedAddresses.contains(addressOnly)) {
                    <span class="comment">// Link this message to this address</span>
                    qDebug() &lt;&lt; &quot;Exclude&quot; &lt;&lt; addressOnly;
                    QStringList &amp;messages = addressMessages[addressOnly];
                    if (messages.isEmpty()) {
                        addressList-&gt;addItem(recipient);
                    }
                    messages.append(details);
                }
            }
        }

        if (!exclusionMessages.isEmpty() || !inclusionMessages.isEmpty()) {
            QTimer::singleShot(0, this, SLOT(continueSearch()));
        } else {
            setSearchActionEnabled(true);
    #ifdef _WIN32_WCE
            tabChanged(1);
    #endif
            if (addressList-&gt;currentItem())
                addressSelected(addressList-&gt;currentItem()-&gt;text());
        }
    }

    #ifdef _WIN32_WCE
    void AddressFinder::tabChanged(int index)
    {
        QWidget* currentTab = tabWidget-&gt;currentWidget();
        QAction* action = 0;
        if(currentTab &amp;&amp; !currentTab-&gt;actions().isEmpty())
            action = currentTab-&gt;actions().first();
        menuBar()-&gt;setDefaultAction(action);
    }
    #endif

    void AddressFinder::setupUi()
    {
        setWindowTitle(tr(&quot;Keep In Touch&quot;));

    #ifdef _WIN32_WCE
        tabWidget = new QTabWidget(this);
        setCentralWidget(tabWidget);
        connect(tabWidget,SIGNAL(currentChanged(int)),this,SLOT(tabChanged(int)));
    #else
        QWidget* centralWidget = new QWidget(this);
        setCentralWidget(centralWidget);
        QVBoxLayout* centralLayout = new QVBoxLayout(centralWidget);
    #endif

        QGroupBox *inputGroup = new QGroupBox(tr(&quot;Find addresses&quot;));
        inputGroup-&gt;setAlignment(Qt::AlignLeft);
    #ifdef _WIN32_WCE
        tabWidget-&gt;addTab(inputGroup,&quot;Search&quot;);
    #else
        centralLayout-&gt;addWidget(inputGroup);
    #endif

        QGridLayout *filterLayout = new QGridLayout(inputGroup);

        QLabel *includeLabel = new QLabel(tr(&quot;Contacted this&quot;));
        filterLayout-&gt;addWidget(includeLabel, 0, 0);
        filterLayout-&gt;setAlignment(includeLabel, Qt::AlignRight);

        QLabel *excludeLabel = new QLabel(tr(&quot;But not last&quot;));
        filterLayout-&gt;addWidget(excludeLabel, 1, 0);
        filterLayout-&gt;setAlignment(excludeLabel, Qt::AlignRight);

        includePeriod = new QComboBox;
        filterLayout-&gt;addWidget(includePeriod, 0, 1);
        includePeriod -&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
        includePeriod-&gt;addItem(tr(&quot;Year&quot;));
        includePeriod-&gt;addItem(tr(&quot;9 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;6 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;3 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;Month&quot;));
        includePeriod-&gt;addItem(tr(&quot;Week&quot;));
        connect(includePeriod, SIGNAL(currentIndexChanged(int)), this, SLOT(includePeriodChanged(int)));

        excludePeriod = new QComboBox;
        excludePeriod -&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
        filterLayout-&gt;addWidget(excludePeriod, 1, 1);

    #ifndef _WIN32_WCE
        searchButton = new QPushButton(tr(&quot;Search&quot;));
        searchButton-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
        filterLayout-&gt;addWidget(searchButton,0,2,2,1,Qt::AlignVCenter | Qt::AlignHCenter);
        connect(searchButton, SIGNAL(clicked()), this, SLOT(searchMessages()), Qt::QueuedConnection);
    #endif

        addressList = new QListWidget(this);
        connect(addressList, SIGNAL(currentTextChanged(QString)), this, SLOT(addressSelected(QString)));

    #ifdef _WIN32_WCE
        QWidget* resultsWidget = new QWidget(this);
        QVBoxLayout* resultsLayout = new QVBoxLayout(resultsWidget);
        tabWidget-&gt;addTab(resultsWidget,&quot;Results&quot;);
    #else
        QVBoxLayout* resultsLayout = centralLayout;
    #endif

        QGroupBox *addressGroup = new QGroupBox(tr(&quot;Address&quot;));
        addressGroup-&gt;setAlignment(Qt::AlignLeft);
        addressGroup-&gt;setLayout(new QVBoxLayout);
        addressGroup-&gt;layout()-&gt;addWidget(addressList);
        resultsLayout-&gt;addWidget(addressGroup);

        QGroupBox *messageGroup = new QGroupBox(tr(&quot;Messages&quot;));
        messageGroup-&gt;setAlignment(Qt::AlignLeft);
        messageGroup-&gt;setLayout(new QHBoxLayout);
        resultsLayout-&gt;addWidget(messageGroup);

        messageCombo = new QComboBox;
        messageGroup-&gt;layout()-&gt;addWidget(messageCombo);

        searchAction = new QAction(&quot;Search&quot;,this);
        inputGroup-&gt;addAction(searchAction);
        connect(searchAction,SIGNAL(triggered()),this,SLOT(searchMessages()),Qt::QueuedConnection);
        QAction* quitAction = menuBar()-&gt;addAction(&quot;Quit&quot;);
        connect(quitAction,SIGNAL(triggered()),qApp,SLOT(quit()));

        includePeriodChanged(0);
    #ifdef _WIN32_WCE
        tabChanged(0);
    #endif
    }

    void AddressFinder::setSearchActionEnabled(bool val)
    {
        searchAction-&gt;setEnabled(val);
    #ifndef _WIN32_WCE
        searchButton-&gt;setEnabled(val);
    #endif
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0 (BETA)</div></td>
</tr></table></div></address></body>
</html>
