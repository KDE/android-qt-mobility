<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt Mobility Project 1.0: addressfinder.cpp Example File (keepintouch/addressfinder.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">addressfinder.cpp Example File<br /><span class="small-subtitle">keepintouch/addressfinder.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;addressfinder.h&quot;

    #include &lt;qcontactdetailfilter.h&gt;
    #include &lt;qcontactemailaddress.h&gt;
    #include &lt;qcontactmanager.h&gt;
    #include &lt;qcontactphonenumber.h&gt;
    #include &lt;qmessage.h&gt;
    #include &lt;qmessageserviceaction.h&gt;

    #include &lt;QComboBox&gt;
    #include &lt;QDateTime&gt;
    #include &lt;QGroupBox&gt;
    #include &lt;QLabel&gt;
    #include &lt;QLayout&gt;
    #include &lt;QListWidget&gt;
    #include &lt;QPushButton&gt;
    #include &lt;QTimer&gt;
    #include &lt;QDebug&gt;
    #include &lt;QApplication&gt;
    #include &lt;QMenuBar&gt;
    #include &lt;QTabWidget&gt;

    namespace {

    QString simpleAddress(const QString &amp;recipient)
    {
        QString name;
        QString addressOnly;

        QMessageAddress::parseEmailAddress(recipient, &amp;name, &amp;addressOnly);

        return addressOnly;
    }

    QString simpleAddress(const QMessageAddress &amp;address)
    {
        return simpleAddress(address.recipient());
    }

    QString contactDisplayName(const QMessageAddress &amp;address)
    {
        QString addressOnly(simpleAddress(address));

        <span class="comment">// See if we can match this address to a contact</span>
        QContactDetailFilter filter;
        if (address.type() == QMessageAddress::Email) {
            <span class="comment">// Match contacts on email address data</span>
            filter.setDetailDefinitionName(QContactEmailAddress::DefinitionName);
            filter.setValue(addressOnly);
            filter.setMatchFlags(QContactFilter::MatchContains);
        } else if (address.type() == QMessageAddress::Phone) {
            <span class="comment">// Match contacts on phone number data</span>
            filter.setDetailDefinitionName(QContactPhoneNumber::DefinitionName);
            filter.setValue(addressOnly);
            filter.setMatchFlags(QContactFilter::MatchPhoneNumber);
        }

        QContactManager manager;
        foreach (const QContactLocalId &amp;contactId, manager.contacts(filter)) {
            <span class="comment">// Any match is acceptable</span>
            const QContact &amp;contact(manager.contact(contactId));
            return contact.displayLabel();
        }

        <span class="comment">// We couldn't match anything, so return the original address</span>
        return address.recipient();
    }

    }

    AddressFinder::AddressFinder(QWidget *parent, Qt::WindowFlags flags)
        : QMainWindow(parent, flags),
          tabWidget(0),
          includePeriod(0),
          excludePeriod(0),
          searchAction(0),
          searchButton(0),
          contactList(0),
          messageCombo(0)
     {
        setupUi();

        connect(&amp;serviceAction, SIGNAL(stateChanged(QMessageServiceAction::State)), this, SLOT(stateChanged(QMessageServiceAction::State)));
        connect(&amp;serviceAction, SIGNAL(messagesFound(QMessageIdList)), this, SLOT(messagesFound(QMessageIdList)));
    }

    AddressFinder::~AddressFinder()
    {
    }

    void AddressFinder::includePeriodChanged(int selected)
    {
        <span class="comment">// Only allow smaller periods to be excluded</span>
        excludePeriod-&gt;clear();

        switch (selected) {
            case 0: excludePeriod-&gt;insertItem(0, &quot;9 Months&quot;); <span class="comment">// fall through:</span>
            case 1: excludePeriod-&gt;insertItem(0, &quot;6 Months&quot;);
            case 2: excludePeriod-&gt;insertItem(0, &quot;3 Months&quot;);
            case 3: excludePeriod-&gt;insertItem(0, &quot;Month&quot;);
            case 4: excludePeriod-&gt;insertItem(0, &quot;Week&quot;);
            default: break;
        }

        excludePeriod-&gt;setCurrentIndex(0);
    }

    void AddressFinder::addressSelected(const QString &amp;address)
    {
        messageCombo-&gt;clear();

        QString addressOnly(simpleAddress(address));

        <span class="comment">// Add the subject of each message to this address to the message pane</span>
        typedef QPair&lt;QString, QMessageId&gt; MessageDetails;
        foreach (const MessageDetails &amp;message, addressMessages[addressOnly]) {
            messageCombo-&gt;addItem(message.first);
        }
    }

    void AddressFinder::searchMessages()
    {
        setSearchActionEnabled(false);

        contactList-&gt;clear();
        messageCombo-&gt;clear();
        excludedAddresses.clear();
        addressList.clear();
        addressMessages.clear();

        QDateTime now(QDateTime::currentDateTime());

        <span class="comment">// Determine the dates that demarcate the selected range</span>
        QDateTime minimumDate(now);
        switch (includePeriod-&gt;currentIndex()) {
            case 0: minimumDate = minimumDate.addMonths(-12); break;
            case 1: minimumDate = minimumDate.addMonths(-9); break;
            case 2: minimumDate = minimumDate.addMonths(-6); break;
            case 3: minimumDate = minimumDate.addMonths(-3); break;
            case 4: minimumDate = minimumDate.addMonths(-1); break;
            case 5: minimumDate = minimumDate.addDays(-7); break;
            default: break;
        }

        QDateTime maximumDate(now);
        switch (excludePeriod-&gt;currentIndex()) {
            case 0: maximumDate = maximumDate.addDays(-7); break;
            case 1: maximumDate = maximumDate.addMonths(-1); break;
            case 2: maximumDate = maximumDate.addMonths(-3); break;
            case 3: maximumDate = maximumDate.addMonths(-6); break;
            case 4: maximumDate = maximumDate.addMonths(-9); break;
            default: break;
        }

        <span class="comment">// We will include addresses contacted following the minimum date</span>
        QMessageFilter includeFilter(QMessageFilter::byTimeStamp(minimumDate, QMessageDataComparator::GreaterThanEqual));

        <span class="comment">// We will exclude addresses contacted following the maximum date</span>
        QMessageFilter excludeFilter(QMessageFilter::byTimeStamp(maximumDate, QMessageDataComparator::GreaterThanEqual));

        <span class="comment">// Not sure why reception timestamp is relevant to sent messages...</span>
        includeFilter |= QMessageFilter::byReceptionTimeStamp(minimumDate, QMessageDataComparator::GreaterThanEqual);
        excludeFilter |= QMessageFilter::byReceptionTimeStamp(maximumDate, QMessageDataComparator::GreaterThanEqual);

        QMessageFilter exclusionFilter;

        <span class="comment">// We only want to match messages that we sent</span>
        QMessageFilter sentFilter(QMessageFilter::byStandardFolder(QMessage::SentFolder));

        <span class="comment">// Create the filter needed to locate messages whose address we will exclude</span>
        exclusionFilter = (sentFilter &amp; excludeFilter);

        <span class="comment">// Create the filter needed to locate messages to search for addresses to include</span>
        inclusionFilter = (sentFilter &amp; includeFilter &amp; ~excludeFilter);

        <span class="comment">// Start the search for messages containing addresses to exclude</span>
        serviceAction.queryMessages(exclusionFilter);
    }

    void AddressFinder::stateChanged(QMessageServiceAction::State s)
    {
        if (s == QMessageServiceAction::Successful) {
            if (!inclusionFilter.isEmpty()) {
                <span class="comment">// Now find the included messages</span>
                serviceAction.queryMessages(inclusionFilter);

                <span class="comment">// Clear the inclusion filter to indicate that we have searched for it</span>
                inclusionFilter = QMessageFilter();
            } else {
                <span class="comment">// We have found the exclusion and inclusion message sets</span>
                if (!inclusionMessages.isEmpty()) {
                    <span class="comment">// Begin processing the message sets</span>
                    QTimer::singleShot(0, this, SLOT(continueSearch()));
                } else {
                    searchAction-&gt;setEnabled(true);
    #ifdef USE_SEARCH_BUTTON
                    searchButton-&gt;setEnabled(true);
    #endif
                }
            }
        } else if (s == QMessageServiceAction::Failed) {
            qWarning() &lt;&lt; &quot;Search failed!&quot;;
            setSearchActionEnabled(true);
        }
    }

    void AddressFinder::messagesFound(const QMessageIdList &amp;ids)
    {
        <span class="comment">// Add these IDs to the relevant set</span>
        if (!inclusionFilter.isEmpty()) {
            exclusionMessages &lt;&lt; ids;
        } else {
            inclusionMessages &lt;&lt; ids;
        }
    }

    void AddressFinder::continueSearch()
    {
        if (!exclusionMessages.isEmpty()) {
            <span class="comment">// Take the first message whose addreses we should exclude</span>
            QMessageId id(exclusionMessages.takeFirst());
            const QMessage message(id);

            <span class="comment">// All recipient addresses are to be excluded</span>
            foreach (const QMessageAddress &amp;address, message.to() + message.cc() + message.bcc()) {
                excludedAddresses.insert(simpleAddress(address));
            }
        } else if (!inclusionMessages.isEmpty()) {
            <span class="comment">// Take the first message to inspect for suitable addresses</span>
            QMessageId id(inclusionMessages.takeFirst());
            const QMessage message(id);

            QString details;

            <span class="comment">// For each recipient of this message</span>
            foreach (const QMessageAddress &amp;address, message.to() + message.cc() + message.bcc()) {
                QString addressOnly(simpleAddress(address));

                <span class="comment">// Ignore recipients whose addresses we have added to the exclusion set</span>
                if (!excludedAddresses.contains(addressOnly)) {
                    <span class="comment">// Link this message to this address</span>
                    QList&lt;QPair&lt;QString, QMessageId&gt; &gt; &amp;messageList(addressMessages[addressOnly]);
                    if (messageList.isEmpty()) {
                        addressList.append(addressOnly);

                        <span class="comment">// Add the recipient to our visible list of contacts to keep in touch with</span>
                        contactList-&gt;addItem(contactDisplayName(address));
                    }

                    if (details.isEmpty()) {
                        <span class="comment">// Determine the properties of the message</span>
                        details = QString(&quot;[%1] %2&quot;).arg(message.date().toString(&quot;MMM d&quot;)).arg(message.subject());
                    }
                    messageList.append(qMakePair(details, id));
                }
            }
        }

        if (!exclusionMessages.isEmpty() || !inclusionMessages.isEmpty()) {
            <span class="comment">// There are more messages to process</span>
            QTimer::singleShot(0, this, SLOT(continueSearch()));
        } else {
            <span class="comment">// We're finished our search</span>
            setSearchActionEnabled(true);
    #ifndef USE_SEARCH_BUTTON
            tabChanged(1);
    #endif

            if (contactList-&gt;currentItem()) {
                <span class="comment">// Select the first address automatically</span>
                addressSelected(contactList-&gt;currentItem()-&gt;text());
            }
        }
    }

    #ifndef USE_SEARCH_BUTTON
    void AddressFinder::tabChanged(int index)
    {
        QWidget* currentTab = tabWidget-&gt;currentWidget();
        QAction* action = 0;
        if(currentTab &amp;&amp; !currentTab-&gt;actions().isEmpty())
            action = currentTab-&gt;actions().first();
        menuBar()-&gt;setDefaultAction(action);

        Q_UNUSED(index)
    }
    #endif

    void AddressFinder::setupUi()
    {
        setWindowTitle(tr(&quot;Keep In Touch&quot;));

    #ifndef USE_SEARCH_BUTTON
        tabWidget = new QTabWidget(this);
        setCentralWidget(tabWidget);
        connect(tabWidget,SIGNAL(currentChanged(int)),this,SLOT(tabChanged(int)));
    #else
        QWidget* centralWidget = new QWidget(this);
        setCentralWidget(centralWidget);
        QVBoxLayout* centralLayout = new QVBoxLayout(centralWidget);
    #endif

        QGroupBox *inputGroup = new QGroupBox(tr(&quot;Find addresses&quot;));
        inputGroup-&gt;setAlignment(Qt::AlignLeft);
    #ifndef USE_SEARCH_BUTTON
        tabWidget-&gt;addTab(inputGroup,&quot;Search&quot;);
    #else
        centralLayout-&gt;addWidget(inputGroup);
    #endif

        QGridLayout *filterLayout = new QGridLayout(inputGroup);

        QLabel *includeLabel = new QLabel(tr(&quot;Contacted this&quot;));
        filterLayout-&gt;addWidget(includeLabel, 0, 0);
        filterLayout-&gt;setAlignment(includeLabel, Qt::AlignRight);

        QLabel *excludeLabel = new QLabel(tr(&quot;But not last&quot;));
        filterLayout-&gt;addWidget(excludeLabel, 1, 0);
        filterLayout-&gt;setAlignment(excludeLabel, Qt::AlignRight);

        includePeriod = new QComboBox;
        includePeriod-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
        includePeriod-&gt;addItem(tr(&quot;Year&quot;));
        includePeriod-&gt;addItem(tr(&quot;9 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;6 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;3 Months&quot;));
        includePeriod-&gt;addItem(tr(&quot;Month&quot;));
        includePeriod-&gt;addItem(tr(&quot;Week&quot;));
        connect(includePeriod, SIGNAL(currentIndexChanged(int)), this, SLOT(includePeriodChanged(int)));
        filterLayout-&gt;addWidget(includePeriod, 0, 1);

        excludePeriod = new QComboBox;
        excludePeriod-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
        filterLayout-&gt;addWidget(excludePeriod, 1, 1);

    #ifdef USE_SEARCH_BUTTON
        searchButton = new QPushButton(tr(&quot;Search&quot;));
        searchButton-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
        connect(searchButton, SIGNAL(clicked()), this, SLOT(searchMessages()), Qt::QueuedConnection);
        filterLayout-&gt;addWidget(searchButton, 2, 1);
    #endif

        contactList = new QListWidget(this);
        connect(contactList, SIGNAL(currentTextChanged(QString)), this, SLOT(addressSelected(QString)));

    #ifndef USE_SEARCH_BUTTON
        QWidget* resultsWidget = new QWidget(this);
        QVBoxLayout* resultsLayout = new QVBoxLayout(resultsWidget);
        tabWidget-&gt;addTab(resultsWidget,&quot;Results&quot;);
    #else
        QVBoxLayout* resultsLayout = centralLayout;
    #endif

        QGroupBox *addressGroup = new QGroupBox(tr(&quot;Contacts&quot;));
        addressGroup-&gt;setAlignment(Qt::AlignLeft);
        addressGroup-&gt;setLayout(new QVBoxLayout);
        addressGroup-&gt;layout()-&gt;addWidget(contactList);
        resultsLayout-&gt;addWidget(addressGroup);

        QGroupBox *messageGroup = new QGroupBox(tr(&quot;Messages&quot;));
        messageGroup-&gt;setAlignment(Qt::AlignLeft);

        QVBoxLayout *groupLayout = new QVBoxLayout;

        messageCombo = new QComboBox;
        connect(messageCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(messageIndexChanged(int)));

        groupLayout-&gt;addWidget(messageCombo);

        showButton = new QPushButton(tr(&quot;Show...&quot;));
        showButton-&gt;setEnabled(false);
        connect(showButton, SIGNAL(clicked()), this, SLOT(showMessage()));

        forwardButton = new QPushButton(tr(&quot;Forward...&quot;));
        forwardButton-&gt;setEnabled(false);
        connect(forwardButton, SIGNAL(clicked()), this, SLOT(forwardMessage()));

        QHBoxLayout *buttonLayout = new QHBoxLayout;
        buttonLayout-&gt;addWidget(showButton);
        buttonLayout-&gt;addWidget(forwardButton);

        groupLayout-&gt;addLayout(buttonLayout);

        messageGroup-&gt;setLayout(groupLayout);
        resultsLayout-&gt;addWidget(messageGroup);

        searchAction = new QAction(&quot;Search&quot;,this);
        inputGroup-&gt;addAction(searchAction);
        connect(searchAction,SIGNAL(triggered()),this,SLOT(searchMessages()),Qt::QueuedConnection);
        QAction* quitAction = menuBar()-&gt;addAction(&quot;Quit&quot;);
        connect(quitAction,SIGNAL(triggered()),qApp,SLOT(quit()));

        includePeriodChanged(0);
    #ifndef USE_SEARCH_BUTTON
        tabChanged(0);
    #endif
    }

    void AddressFinder::setSearchActionEnabled(bool val)
    {
        searchAction-&gt;setEnabled(val);
    #ifdef USE_SEARCH_BUTTON
        searchButton-&gt;setEnabled(val);
    #endif
    }

    void AddressFinder::messageIndexChanged(int index)
    {
        bool messageSelected(index != -1);
        showButton-&gt;setEnabled(messageSelected);
        forwardButton-&gt;setEnabled(messageSelected);
    }

    void AddressFinder::showMessage()
    {
        int index = messageCombo-&gt;currentIndex();
        if (index != -1) {
            <span class="comment">// Find the address currently selected</span>
            const QString &amp;selectedAddress(addressList[contactList-&gt;currentRow()]);

            <span class="comment">// Show the message selected</span>
            QMessageId &amp;messageId((addressMessages[selectedAddress])[index].second);
            serviceAction.show(messageId);
        }
    }

    void AddressFinder::forwardMessage()
    {
        int index = messageCombo-&gt;currentIndex();
        if (index != -1) {
            <span class="comment">// Find the address currently selected</span>
            const QString &amp;selectedAddress(addressList[contactList-&gt;currentRow()]);

            <span class="comment">// Find the selected message</span>
            QMessageId &amp;messageId((addressMessages[selectedAddress])[index].second);
            QMessage original(messageId);

            <span class="comment">// Create a message which forwards the selected message to the same recipient</span>
            QMessage fwd(original.createResponseMessage(QMessage::Forward));
            fwd.setTo(original.to());
            serviceAction.compose(fwd);
        }
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.0</div></td>
</tr></table></div></address></body>
</html>
