<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>mainwindow.cpp Example File (serviceactions/mainwindow.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">mainwindow.cpp Example File<br /><span class="small-subtitle">serviceactions/mainwindow.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;mainwindow.h&quot;
    #include &quot;qmessageserviceaction.h&quot;
    #include &lt;QComboBox&gt;
    #include &lt;QListWidget&gt;
    #include &lt;QVBoxLayout&gt;
    #include &lt;QLabel&gt;
    #include &lt;QTabWidget&gt;
    #include &lt;QPointer&gt;
    #include &lt;QPushButton&gt;
    #include &lt;QDebug&gt;
    #include &lt;QLineEdit&gt;
    #include &lt;QTextEdit&gt;
    #include &quot;attachmentlistwidget.h&quot;
    #include &lt;QFileDialog&gt;
    #include &lt;QTimer&gt;
    #include &lt;QMessageBox&gt;
    #include &lt;QThread&gt;
    #include &lt;QStackedLayout&gt;
    #include &lt;QPair&gt;
    #include &lt;QScrollArea&gt;
    #include &lt;QMenuBar&gt;
    #include &lt;QApplication&gt;
    #include &lt;QStackedWidget&gt;
    #include &lt;QMutex&gt;
    #include &lt;qmessagestore.h&gt;

    typedef QPointer&lt;QMessageServiceAction&gt; QMessageServiceActionPtr;

    static const QSize WindowGeometry(400,300);
    static const QString WindowTitle(&quot;Service-actions Example&quot;);

    typedef QPair&lt;QMessageId,QString&gt; IdSubjectPair;
    typedef QList&lt;IdSubjectPair&gt; MessageIdSubjectList;

    class AccountsWidget : public QWidget
    {
        Q_OBJECT

    private:
        class Loader : public QThread
        {
        public:
            Loader(AccountsWidget* parent);
            void run();

        private:
            AccountsWidget* m_parent;
        };

    public:
        AccountsWidget(QWidget* parent = 0);
        QMessageAccountId currentAccount() const;
        QString currentAccountName() const;
        bool isEmpty() const;

    signals:
        void accountChanged();

    protected:
        void showEvent(QShowEvent* e);
        void hideEvent(QHideEvent* e);

    private slots:
        void load();
        void loadStarted();
        void loadFinished();

    private:
        void setupUi();
        void setIds(const QMessageAccountIdList&amp; ids);
        QMessageAccountIdList ids() const;

    private:
        QStackedLayout* m_stackedLayout;
        QComboBox* m_accountsCombo;
        QLabel* m_busyLabel;

        Loader m_loader;
        mutable QMutex m_loadMutex;
        QMessageAccountIdList m_ids;
    };

    AccountsWidget::Loader::Loader(AccountsWidget* parent)
    :
    QThread(parent),
    m_parent(parent)
    {
    }

    void AccountsWidget::Loader::run()
    {
        QMessageAccountIdList ids = QMessageStore::instance()-&gt;queryAccounts();
        m_parent-&gt;setIds(ids);
    }

    AccountsWidget::AccountsWidget(QWidget* parent)
    :
    QWidget(parent),
    m_stackedLayout(0),
    m_accountsCombo(0),
    m_busyLabel(0),
    m_loader(this)
    {
        setupUi();

        connect(&amp;m_loader,SIGNAL(started()),this,SLOT(loadStarted()));
        connect(&amp;m_loader,SIGNAL(finished()),this,SLOT(loadFinished()));
    }

    QMessageAccountId AccountsWidget::currentAccount() const
    {
        QMessageAccountId result;
        if(m_loader.isFinished() &amp;&amp; m_accountsCombo-&gt;count())
        {
            int index = m_accountsCombo-&gt;currentIndex();
            return ids().at(index);
        }

        return result;
    }

    QString AccountsWidget::currentAccountName() const
    {
        if(m_loader.isFinished() &amp;&amp; m_accountsCombo-&gt;count())
            return m_accountsCombo-&gt;itemData(m_accountsCombo-&gt;currentIndex()).toString();
        return QString();
    }

    bool AccountsWidget::isEmpty() const
    {
        return m_accountsCombo-&gt;count() == 0;
    }

    void AccountsWidget::showEvent(QShowEvent* e)
    {
        load();
        QWidget::showEvent(e);
    }

    void AccountsWidget::hideEvent(QHideEvent* e)
    {
        if(m_loader.isRunning())
            m_loader.exit();
        QWidget::hideEvent(e);
    }

    void AccountsWidget::load()
    {
        static bool runonce = false;
        if(!runonce)
            m_loader.start();
        runonce = true;
    }

    void AccountsWidget::loadStarted()
    {
    #ifndef _WIN32_WCE
        setCursor(Qt::BusyCursor);
    #endif
        m_stackedLayout-&gt;setCurrentWidget(m_busyLabel);
    }

    void AccountsWidget::loadFinished()
    {
        m_accountsCombo-&gt;clear();

        QMessageAccountIdList accountIds = ids();

        if(!accountIds.isEmpty())
        {
            for(int i = 0; i &lt; accountIds.count(); ++i)
            {
                QMessageAccount account(accountIds[i]);
                m_accountsCombo-&gt;addItem(QString(&quot;%1 - %2&quot;).arg(i+1).arg(account.name()),account.name());
            }

            m_stackedLayout-&gt;setCurrentWidget(m_accountsCombo);
        }
        else
            m_busyLabel-&gt;setText(&quot;No accounts!&quot;);

    #ifndef _WIN32_WCE
        setCursor(Qt::ArrowCursor);
    #endif
    }

    void AccountsWidget::setupUi()
    {
        m_stackedLayout = new QStackedLayout(this);

        m_accountsCombo = new QComboBox(this);
        m_stackedLayout-&gt;addWidget(m_accountsCombo);
        connect(m_accountsCombo,SIGNAL(currentIndexChanged(int)),this,SIGNAL(accountChanged()));

        m_busyLabel = new QLabel(&quot;Loading...&quot;);
        m_stackedLayout-&gt;addWidget(m_busyLabel);
    }

    void AccountsWidget::setIds(const QMessageAccountIdList&amp; ids)
    {
        QMutexLocker mutex(&amp;m_loadMutex);

        m_ids = ids;
    }

    QMessageAccountIdList AccountsWidget::ids() const
    {
        QMutexLocker mutex(&amp;m_loadMutex);
        return m_ids;
    }

    class RecentMessagesWidget : public QWidget
    {
        Q_OBJECT

    private:
        static const int MessageIdRole = Qt::UserRole + 1;

        class Loader : public QThread
        {
        public:
            Loader(RecentMessagesWidget* parent);
            void run();

        private:
            RecentMessagesWidget* m_parent;
        };

    public:
        RecentMessagesWidget(QWidget* parent = 0, unsigned int maxRecent = 10);

        IdSubjectPair currentItem() const;

    protected:
        void showEvent(QShowEvent* e);
        void hideEvent(QHideEvent* e);

    private slots:
        void load();
        void loadStarted();
        void loadFinished();

    private:
        void setupUi();
        void setIds(const MessageIdSubjectList&amp; list);
        MessageIdSubjectList ids() const;

    private:
        QListWidget* m_messageListWidget;
        QLabel* m_busyLabel;
        QStackedLayout* m_layout;
        Loader m_loader;
        mutable QMutex m_loadMutex;
        MessageIdSubjectList m_ids;
        bool m_loaded;
        unsigned int m_maxRecent;
    };

    RecentMessagesWidget::Loader::Loader(RecentMessagesWidget* parent)
    :
    QThread(parent),
    m_parent(parent)
    {
    }

    void RecentMessagesWidget::Loader::run()
    {
        QMessageIdList lastTenMessages = QMessageStore::instance()-&gt;queryMessages(QMessageFilter(),QMessageOrdering::byReceptionTimeStamp(Qt::DescendingOrder),m_parent-&gt;m_maxRecent,0);

        MessageIdSubjectList ids;

        foreach(const QMessageId&amp; id, lastTenMessages)
        {
            QMessage message(id);
            IdSubjectPair result(id,message.subject());
            ids.append(result);
        }

        m_parent-&gt;setIds(ids);
    }

    RecentMessagesWidget::RecentMessagesWidget(QWidget* parent, unsigned int maxRecent)
    :
    QWidget(parent),
    m_messageListWidget(0),
    m_busyLabel(0),
    m_layout(0),
    m_loader(this),
    m_loaded(false),
    m_maxRecent(maxRecent)
    {
        setupUi();
        connect(&amp;m_loader,SIGNAL(started()),this,SLOT(loadStarted()));
        connect(&amp;m_loader,SIGNAL(finished()),this,SLOT(loadFinished()));
    }

    IdSubjectPair RecentMessagesWidget::currentItem() const
    {
        IdSubjectPair result;

        if(m_loader.isFinished() &amp;&amp; !m_ids.isEmpty())
            result = ids().at(m_messageListWidget-&gt;currentRow());
        return result;
    }

    void RecentMessagesWidget::showEvent(QShowEvent* e)
    {
        load();
        QWidget::showEvent(e);
    }

    void RecentMessagesWidget::hideEvent(QHideEvent* e)
    {
        if(m_loader.isRunning())
        {
            m_loader.exit();
            m_loaded = false;
        }
        QWidget::hideEvent(e);
    }

    void RecentMessagesWidget::load()
    {
        if(!m_loaded)
            m_loader.start();
        m_loaded = true;
    }

    void RecentMessagesWidget::loadStarted()
    {
    #ifndef _WIN32_WCE
        setCursor(Qt::BusyCursor);
    #endif
        m_layout-&gt;setCurrentWidget(m_busyLabel);
    }

    void RecentMessagesWidget::loadFinished()
    {
        m_messageListWidget-&gt;clear();

        MessageIdSubjectList lastTenMessages = ids();

        if(lastTenMessages.isEmpty())
        {
            m_busyLabel-&gt;setText(&quot;No messages found!&quot;);
            return;
        }

        for(int index =  0 ; index &lt;= lastTenMessages.count()-1; index++)
        {
            IdSubjectPair result(lastTenMessages[index]);
            QListWidgetItem* newItem = new QListWidgetItem(result.second);
            newItem-&gt;setData(MessageIdRole,result.first.toString());
            m_messageListWidget-&gt;addItem(newItem);
        }

        m_layout-&gt;setCurrentWidget(m_messageListWidget);
    #ifndef _WIN32_WCE
        setCursor(Qt::ArrowCursor);
    #endif
    }

    void RecentMessagesWidget::setupUi()
    {
        m_layout = new QStackedLayout(this);

        m_messageListWidget = new QListWidget(this);
        m_layout-&gt;addWidget(m_messageListWidget);

        m_busyLabel = new QLabel(&quot;Loading...&quot;,this);
        m_busyLabel-&gt;setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
        m_busyLabel-&gt;setFrameStyle(QFrame::Box);
        m_layout-&gt;addWidget(m_busyLabel);

    }

    void RecentMessagesWidget::setIds(const MessageIdSubjectList&amp; list)
    {
        QMutexLocker mutex(&amp;m_loadMutex);
        m_ids = list;
    }

    MessageIdSubjectList RecentMessagesWidget::ids() const
    {
        QMutexLocker mutex(&amp;m_loadMutex);
        return m_ids;
    }

    class ComposeSendWidget : public QWidget
    {
        Q_OBJECT

    public:
        ComposeSendWidget(QMessageServiceAction* service, QWidget* parent = 0);

    signals:
        void actionsChanged();

    private slots:
        void composeButtonClicked();
        void sendButtonClicked();
        void addAttachmentButtonClicked();
        void accountChanged();

    private:
        void setupUi();
        QMessage constructQMessage(bool asHtml = false) const;

    private:
        QStackedLayout* m_layoutStack;
        QMessageServiceAction* m_service;
        AccountsWidget* m_accountsWidget;
        QLineEdit* m_toEdit;
        QLineEdit* m_ccEdit;
        QLabel* m_ccLabel;
        QLineEdit* m_bccEdit;
        QLabel* m_bccLabel;
        QLineEdit* m_subjectEdit;
        QLabel* m_subjectLabel;
        QTextEdit* m_bodyEdit;
        AttachmentListWidget* m_attachmentList;
        QAction* m_attachmentsAction;
        QAction* m_sendAsHTMLAction;
    };

    ComposeSendWidget::ComposeSendWidget(QMessageServiceAction* service, QWidget* parent)
    :
    QWidget(parent),
    m_layoutStack(0),
    m_service(service),
    m_accountsWidget(0),
    m_toEdit(0),
    m_ccEdit(0),
    m_ccLabel(0),
    m_bccEdit(0),
    m_bccLabel(0),
    m_subjectEdit(0),
    m_subjectLabel(0),
    m_bodyEdit(0),
    m_attachmentList(0),
    m_attachmentsAction(0),
    m_sendAsHTMLAction(0)
    {
        setupUi();
    }

    void ComposeSendWidget::composeButtonClicked()
    {
        QMessage message(constructQMessage());
        m_service-&gt;compose(message);
    }

    void ComposeSendWidget::sendButtonClicked()
    {
        bool asHtml = (sender() == m_sendAsHTMLAction);
        QMessage message(constructQMessage(asHtml));
        m_service-&gt;send(message);
    }

    void ComposeSendWidget::addAttachmentButtonClicked()
    {
        QStringList filenames = QFileDialog::getOpenFileNames(this,tr(&quot;Select attachments&quot;));
        m_attachmentList-&gt;addAttachments(filenames);
    }

    void ComposeSendWidget::accountChanged()
    {
    #ifdef _WIN32_WCE
        bool isSmsAccount = m_accountsWidget-&gt;currentAccountName() == &quot;SMS&quot;;

        foreach(QWidget* emailSpecificWidget , QList&lt;QWidget*&gt;() &lt;&lt; m_bccEdit &lt;&lt; m_bccLabel &lt;&lt;
                                                                    m_ccEdit &lt;&lt;  m_ccLabel &lt;&lt;
                                                                    m_subjectEdit &lt;&lt; m_subjectLabel) {
            emailSpecificWidget-&gt;setVisible(!isSmsAccount);
        }

        m_attachmentsAction-&gt;setEnabled(!isSmsAccount);
        m_sendAsHTMLAction-&gt;setEnabled(!isSmsAccount);
    #endif
    }

    void ComposeSendWidget::setupUi()
    {
        QGridLayout* gl = new QGridLayout(this);

        QLabel* accountLabel = new QLabel(&quot;Account:&quot;,this);
        gl-&gt;addWidget(accountLabel,0,0);

        m_accountsWidget = new AccountsWidget(this);
        gl-&gt;addWidget(m_accountsWidget,0,1);
        connect(m_accountsWidget,SIGNAL(accountChanged()),this,SLOT(accountChanged()));

        QLabel* toLabel = new QLabel(&quot;To:&quot;,this);
        gl-&gt;addWidget(toLabel,1,0);

        m_toEdit = new QLineEdit(this);
        gl-&gt;addWidget(m_toEdit,1,1);

        m_ccLabel = new QLabel(&quot;Cc:&quot;,this);
        gl-&gt;addWidget(m_ccLabel,2,0);

        m_ccEdit = new QLineEdit(this);
        gl-&gt;addWidget(m_ccEdit,2,1);

        m_bccLabel = new QLabel(&quot;Bcc&quot;,this);
        gl-&gt;addWidget(m_bccLabel,3,0);

        m_bccEdit = new QLineEdit(this);
        gl-&gt;addWidget(m_bccEdit,3,1);

        m_subjectLabel = new QLabel(&quot;Subject:&quot;,this);
        gl-&gt;addWidget(m_subjectLabel,4,0);

        m_subjectEdit = new QLineEdit(this);
        gl-&gt;addWidget(m_subjectEdit,4,1);

        m_bodyEdit = new QTextEdit(this);
        gl-&gt;addWidget(m_bodyEdit,5,0,1,2);

        m_attachmentList = new AttachmentListWidget(this);
        gl-&gt;addWidget(m_attachmentList,6,0,1,2);
        m_attachmentList-&gt;hide();

        QAction* composeAction = new QAction(&quot;Compose&quot;,this);
        connect(composeAction,SIGNAL(triggered()),this,SLOT(composeButtonClicked()));
        addAction(composeAction);

        QAction* sendAction = new QAction(&quot;Send&quot;,this);
        connect(sendAction,SIGNAL(triggered()),this,SLOT(sendButtonClicked()));
        addAction(sendAction);

        m_sendAsHTMLAction = new QAction(&quot;Send as HTML&quot;,this);
        connect(m_sendAsHTMLAction,SIGNAL(triggered()),this,SLOT(sendButtonClicked()));
        addAction(m_sendAsHTMLAction);

        QAction* separator = new QAction(this);
        separator-&gt;setSeparator(true);
        addAction(separator);

        m_attachmentsAction = new QAction(&quot;Add attachment&quot;,this);
        connect(m_attachmentsAction,SIGNAL(triggered()),this,SLOT(addAttachmentButtonClicked()));
        addAction(m_attachmentsAction);
    }

    QMessage ComposeSendWidget::constructQMessage(bool asHtml) const
    {
        QMessage message;

        if(m_accountsWidget-&gt;isEmpty())
        {
            QMessageBox::critical(const_cast&lt;ComposeSendWidget*&gt;(this),&quot;No Accounts&quot;,&quot;Cannot send a message without any available accounts&quot;);
            return message;
        }

        QMessageAccountId selectedAccountId = m_accountsWidget-&gt;currentAccount();
    #ifdef _WIN32_WCE
        QMessageAccount selectedAccount(selectedAccountId);
        bool composingSms = selectedAccount.name() == &quot;SMS&quot;;
    #else
        bool composingSms = false;
    #endif

        QMessageAddressList toList;
        QMessageAddressList ccList;
        QMessageAddressList bccList;

        QMessageAddress::Type addressType = QMessageAddress::Email;
        if(composingSms)
        {
            addressType = QMessageAddress::Phone;
            message.setType(QMessage::Sms);
        }

        foreach(QString s, m_toEdit-&gt;text().split(QRegExp(&quot;\\s&quot;),QString::SkipEmptyParts))
            toList.append(QMessageAddress(s,addressType));
        message.setTo(toList);

        if(!composingSms)
        {
            foreach(QString s, m_ccEdit-&gt;text().split(QRegExp(&quot;\\s&quot;),QString::SkipEmptyParts))
                ccList.append(QMessageAddress(s,QMessageAddress::Email));
            message.setCc(ccList);

            foreach(QString s, m_bccEdit-&gt;text().split(QRegExp(&quot;\\s&quot;),QString::SkipEmptyParts))
                bccList.append(QMessageAddress(s,QMessageAddress::Email));
            message.setBcc(bccList);
            message.setSubject(m_subjectEdit-&gt;text());

            message.setType(QMessage::Email);

            message.appendAttachments(m_attachmentList-&gt;attachments());
        }

        message.setParentAccountId(selectedAccountId);

        if(!composingSms &amp;&amp; asHtml) {
            <span class="comment">//create html body</span>
            QString htmlBody(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 align=center&gt;%1&lt;/h2&gt;&lt;hr&gt;%2&lt;/body&gt;&lt;/html&gt;&quot;);
            message.setBody(htmlBody.arg(message.subject()).arg(m_bodyEdit-&gt;toPlainText()),&quot;text/html&quot;);
        }
        else
            message.setBody(m_bodyEdit-&gt;toPlainText());

        return message;
    }

    class RetrieveWidget : public QWidget
    {
    public:
        RetrieveWidget(QMessageServiceAction* service, QWidget* parent = 0);

    private:
        QMessageServiceAction* m_service;
    };

    RetrieveWidget::RetrieveWidget(QMessageServiceAction* service, QWidget* parent)
    :
    QWidget(parent),
    m_service(service)
    {
    }

    class ShowWidget : public QWidget
    {
        Q_OBJECT

    public:
        ShowWidget(QMessageServiceAction* service, QWidget* parent = 0);

    private slots:
        void showButtonClicked();

    private:
        void setupUi();

    private:
        QMessageServiceAction* m_service;
        RecentMessagesWidget* m_recentMessagesWidget;
    };

    ShowWidget::ShowWidget(QMessageServiceAction* service, QWidget* parent)
    :
    QWidget(parent),
    m_service(service),
    m_recentMessagesWidget(0)
    {
        setupUi();
    }

    void ShowWidget::showButtonClicked()
    {
        <span class="comment">//get the selected account</span>

        if(m_recentMessagesWidget-&gt;currentItem().first.isValid())
        {
            IdSubjectPair result = m_recentMessagesWidget-&gt;currentItem();
            QMessageId selectedId(result.first);
            m_service-&gt;show(selectedId);
        }
    }

    void ShowWidget::setupUi()
    {
        QVBoxLayout* vbl = new QVBoxLayout(this);

        vbl-&gt;addWidget(new QLabel(&quot;Last 10 messages:&quot;,this));

        m_recentMessagesWidget = new RecentMessagesWidget(this,30);
        vbl-&gt;addWidget(m_recentMessagesWidget);

        QAction* showAction = new QAction(&quot;Show&quot;,this);
        connect(showAction,SIGNAL(triggered()),this,SLOT(showButtonClicked()));
        addAction(showAction);
    }

    class QueryWidget : public QWidget
    {
    public:
        QueryWidget(QMessageServiceAction* service, QWidget* parent = 0);

    private:
        QMessageServiceAction* m_service;
    };

    QueryWidget::QueryWidget(QMessageServiceAction* service, QWidget* parent)
    :
    QWidget(parent),
    m_service(service)
    {
    }

    class StoreSignalsWidget : public QWidget
    {
        Q_OBJECT

    public:
        StoreSignalsWidget(QWidget* parent = 0);

    private slots:
        void messageAdded(const QMessageId&amp;, const QMessageStore::NotificationFilterIdSet&amp;);
        void messageUpdated(const QMessageId&amp;, const QMessageStore::NotificationFilterIdSet&amp;);
        void messageRemoved(const QMessageId&amp;, const QMessageStore::NotificationFilterIdSet&amp;);

    private:
        void setupUi();
        void appendString(const QString&amp; message);

    private:
        QListWidget* m_activityListWidget;
        QMessageStore::NotificationFilterId m_notificationFilterId;
    };

    StoreSignalsWidget::StoreSignalsWidget(QWidget* parent)
    :
    QWidget(parent),
    m_activityListWidget(0)
    {
        setupUi();
    }

    void StoreSignalsWidget::messageAdded(const QMessageId&amp; id, const QMessageStore::NotificationFilterIdSet&amp; filterSet)
    {
        if(!filterSet.contains(m_notificationFilterId))
            return;

        QMessage message(id);

        QString msg = QString(&quot;Added: %1&quot;).arg(message.subject());
        m_activityListWidget-&gt;addItem(msg);
    }

    void StoreSignalsWidget::messageUpdated(const QMessageId&amp; id, const QMessageStore::NotificationFilterIdSet&amp; filterSet)
    {
        if(!filterSet.contains(m_notificationFilterId))
            return;

        QMessage message(id);

        QString msg = QString(&quot;Updated: %1&quot;).arg(message.subject());
        m_activityListWidget-&gt;addItem(msg);
    }

    void StoreSignalsWidget::messageRemoved(const QMessageId&amp; id, const QMessageStore::NotificationFilterIdSet&amp; filterSet)
    {
        if(!filterSet.contains(m_notificationFilterId))
            return;

        QString idString(id.toString());
        idString.truncate(10);

        QString msg = QString(&quot;Removed ID: %1 ...&quot;).arg(idString);
        m_activityListWidget-&gt;addItem(msg);
    }

    void StoreSignalsWidget::setupUi()
    {
        m_activityListWidget = new QListWidget(this);
        QVBoxLayout* l = new QVBoxLayout(this);
        l-&gt;setSpacing(0);
        l-&gt;setContentsMargins(0,0,0,0);
        l-&gt;addWidget(m_activityListWidget);

        connect(QMessageStore::instance(),
                SIGNAL(messageAdded(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)),
                this,
                SLOT(messageAdded(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)));

        connect(QMessageStore::instance(),
                SIGNAL(messageRemoved(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)),
                this,
                SLOT(messageRemoved(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)));

        connect(QMessageStore::instance(),
                SIGNAL(messageUpdated(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)),
                this,
                SLOT(messageUpdated(const QMessageId&amp;,const QMessageStore::NotificationFilterIdSet&amp;)));

        m_notificationFilterId = QMessageStore::instance()-&gt;registerNotificationFilter(QMessageFilter());

        QAction* clearAction = new QAction(&quot;Clear&quot;,this);
        connect(clearAction,SIGNAL(triggered(bool)),m_activityListWidget,SLOT(clear()));
        addAction(clearAction);

    }

    MainWindow::MainWindow(QWidget* parent, Qt::WindowFlags f)
    :
    QMainWindow(parent,f),
    m_tabWidget(0)
    {

        m_serviceAction = new QMessageServiceAction(this);

        connect(m_serviceAction,SIGNAL(stateChanged(QMessageServiceAction::State)),
                this,SLOT(serviceStateChanged(QMessageServiceAction::State)));

        <span class="comment">//example widgets</span>

        m_widgetStack = new QStackedWidget(this);
        setCentralWidget(m_widgetStack);

        foreach(QWidget* exampleWidget, QWidgetList() &lt;&lt; new ComposeSendWidget(m_serviceAction,this)
                                                      &lt;&lt; new ShowWidget(m_serviceAction,this)
                                                      &lt;&lt; new RetrieveWidget(m_serviceAction,this)
                                                      &lt;&lt; new QueryWidget(m_serviceAction,this)
                                                      &lt;&lt; new StoreSignalsWidget(this)) {
            m_widgetStack-&gt;addWidget(exampleWidget);
    #ifdef _WIN32_WCE
            exampleWidget-&gt;installEventFilter(this);
    #endif
        }

        <span class="comment">//main menu</span>
    #ifndef _WIN32_WCE
        QMenu* fileMenu = new QMenu(&quot;File&quot;,this);
    #endif

        int index = 0;
        foreach(QAction* viewAction, QList&lt;QAction*&gt;() &lt;&lt; new QAction(&quot;Compose\\Send&quot;,this)
                                                       &lt;&lt; new QAction(&quot;Show&quot;,this)
                                                       &lt;&lt; new QAction(&quot;Retrieve&quot;,this)
                                                       &lt;&lt; new QAction(&quot;Query&quot;,this)
                                                       &lt;&lt; new QAction(&quot;Store Signals&quot;,this))
        {
            connect(viewAction,SIGNAL(triggered()),this,SLOT(viewSelected()));
    #ifndef _WIN32_WCE
            fileMenu-&gt;addAction(viewAction);
    #else
            menuBar()-&gt;addAction(viewAction);
    #endif
            viewAction-&gt;setData(index);
            index++;
        }
    #ifndef _WIN32_WCE
        fileMenu-&gt;addSeparator();
    #else
        menuBar()-&gt;addSeparator();
    #endif

        QAction* quitAction = new QAction(&quot;Quit&quot;,this);
        connect(quitAction,SIGNAL(triggered()),qApp,SLOT(quit()));
    #ifndef _WIN32_WCE
        fileMenu-&gt;addAction(quitAction);
        menuBar()-&gt;addMenu(fileMenu);
    #else
        menuBar()-&gt;addAction(quitAction);
    #endif

        QTimer::singleShot(0,this,SLOT(viewSelected()));

        <span class="comment">//window properties</span>

        setWindowTitle(WindowTitle);
        resize(WindowGeometry);
    }

    #ifdef _WIN32_WCE
    bool MainWindow::eventFilter(QObject* source, QEvent* e)
    {
        bool actionChanged = (m_widgetStack-&gt;currentWidget() == source) &amp;&amp; e-&gt;type() == QEvent::ActionChanged;
        if(actionChanged)
            viewSelected(); <span class="comment">//update the menu items</span>
        return false;
    }
    #endif

    void MainWindow::serviceStateChanged(QMessageServiceAction::State state)
    {
        if(state == QMessageServiceAction::Failed)
            QMessageBox::critical(this,&quot;Error&quot;,&quot;One or more service actions failed&quot;);
    }

    void MainWindow::viewSelected()
    {
        static QMenu* actionMenu = 0;

        if(!actionMenu)
        {
            actionMenu = new QMenu(&quot;Action&quot;,this);
    #ifndef _WIN32_WCE
            menuBar()-&gt;addMenu(actionMenu);
    #endif
        }
        QAction* senderAction = qobject_cast&lt;QAction*&gt;(sender());
        if(senderAction)
            m_widgetStack-&gt;setCurrentIndex(senderAction-&gt;data().toInt());

        bool currentViewHasActions = m_widgetStack-&gt;currentWidget() &amp;&amp; !m_widgetStack-&gt;currentWidget()-&gt;actions().isEmpty();
        actionMenu-&gt;clear();
        if(currentViewHasActions)
        {
            foreach(QAction* a, m_widgetStack-&gt;currentWidget()-&gt;actions())
                actionMenu-&gt;addAction(a);
        }
    #ifdef _WIN32_WCE
        static QAction* leftSoftButton = new QAction(&quot;Action&quot;,this);
        leftSoftButton-&gt;setMenu(actionMenu);
        menuBar()-&gt;setDefaultAction(leftSoftButton);
    #endif
    }

    #include &lt;mainwindow.moc&gt;</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td align="right"><div align="right">Qt Mobility API</div></td>
</tr></table></div></address></body>
</html>
