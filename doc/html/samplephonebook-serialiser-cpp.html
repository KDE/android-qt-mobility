<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Qt Mobility Project 1.0: serialiser.cpp Example File (samplephonebook/serialiser.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">serialiser.cpp Example File<br /><span class="small-subtitle">samplephonebook/serialiser.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;serialiser.h&quot;
    #include &lt;QUuid&gt;

    QString Serialiser::escaped(const QString&amp; input)
    {
        QString retn = &quot;&quot;;
        for (int i = 0; i &lt; input.length(); i++) {
            QChar currChar = input.at(i);
            if (currChar == '\\' ||
                    currChar == '=' ||
                    currChar == ',' ||
                    currChar == ';' ||
                    currChar == ':') {
                <span class="comment">// we need to escape this character.</span>
                retn += '\\'; <span class="comment">// escape with a single backslash.</span>
            }
            retn += currChar;
        }

        return retn;
    }

    QString Serialiser::convertDetail(const QContact&amp; contact, const QContactDetail&amp; detail, const QString&amp; vcardField)
    {
        <span class="comment">// the format of the converted detail will be:</span>
        <span class="comment">// X-com-nokia-mobility-contacts-vcard-detail-UUID;vcardField;definitionName;key=value,key=value;preferredFor=actionId,actionId</span>
        <span class="comment">// where each of the elements are escaped strings.</span>
        QString retn = &quot;X-com-nokia-mobility-contacts-vcard-detail-&quot;;
        retn += escaped(QUuid::createUuid().toString());
        retn += &quot;:&quot;;
        retn += escaped(vcardField);
        retn += &quot;;&quot;;
        retn += escaped(detail.definitionName());
        retn += &quot;;&quot;;

        QVariantMap vals = detail.values();
        foreach (const QString&amp; key, vals.keys()) {
            retn += escaped(key);
            retn += &quot;=&quot;;
            retn += escaped(vals.value(key).toString());
            retn += &quot;,&quot;;
        }
        retn.chop(1);
        retn += &quot;;&quot;;

        retn += &quot;preferredFor=&quot;;
        foreach(const QContactActionDescriptor&amp; actionDescr, contact.availableActions(QString())) {
            if (contact.isPreferredDetail(actionDescr.actionName(), detail)) {
                retn += escaped(actionDescr.actionName()) + &quot;,&quot;;
            }
        }

        if (retn.endsWith(&quot;,&quot;))
            retn.chop(1);

        return retn;
    }

    QStringList Serialiser::findActionIdsFromCustomString(const QString&amp; customString)
    {
        QString pref = &quot;preferredFor=&quot;;
        int startPos = customString.indexOf(pref) + pref.length();
        if (startPos &lt;= pref.length() || startPos &gt;= customString.length())
            return QStringList();

        QStringList retn;
        QString currentActionId = &quot;&quot;;
        for (int i = startPos; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);
            if (currChar == '\\') {
                i += 1;
                currentActionId += customString.at(i);
            } else if (currChar == ',') {
                if (currentActionId.length() &gt; 0) {
                    retn &lt;&lt; currentActionId;
                }

                currentActionId = &quot;&quot;;
            }
        }

        if (currentActionId.length() &gt; 0)
            retn &lt;&lt; currentActionId;

        return retn;
    }

    QString Serialiser::findLinkStringFromCustomString(const QString&amp; customString)
    {
        <span class="comment">// check to see if the custom detail was put there by us.</span>
        if (customString.indexOf(&quot;X-com-nokia-mobility-contacts-vcard-detail-&quot;) != 0) {
            return QString(); <span class="comment">// no link.</span>
        }

        <span class="comment">// parse the detail.  In this implementation, we ignore the linked vcard field.</span>
        int sectionCount = 0;
        QString linkString = &quot;&quot;;
        for (int i = 0; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);

            <span class="comment">// the second section is the link string.  grab it.</span>
            if (sectionCount &gt; 0) {
                if (currChar == '\\') {
                    linkString += customString.at(i+1);
                } else {
                    linkString += currChar;
                }
            }

            if (currChar == ';' || currChar == ':') {
                <span class="comment">// check to see whether we've finished copying the link string.</span>
                sectionCount += 1;
                if (sectionCount == 2) {
                    linkString.chop(1); <span class="comment">// chop off the trailing ';'</span>
                    return linkString;
                }
            } else if (currChar == '\\') {
                <span class="comment">// skip the escaped character.</span>
                i += 1;
            }
        }

        return QString(); <span class="comment">// no link.</span>
    }

    QContactDetail Serialiser::convertCustomString(const QString&amp; customString)
    {
        int nextSection = 0;
        int oldNextSection = 0;

        <span class="comment">// check to see if the custom detail was put there by us.</span>
        if (customString.indexOf(&quot;X-com-nokia-mobility-contacts-vcard-detail-&quot;) != 0) {
            return QContactDetail();
        }

        <span class="comment">// parse the detail.  In this implementation, we ignore the linked vcard field.</span>
        int sectionCount = 0;
        for (int i = nextSection; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);
            if (currChar == ';' || currChar == ':') {
                <span class="comment">// check to see whether we've finished skipping past the unused sections.</span>
                sectionCount += 1;
                if (sectionCount == 2) {
                    nextSection = i + 1;
                    break;
                }
            } else if (currChar == '\\') {
                <span class="comment">// skip the escaped character.</span>
                i += 1;
            }
        }

        <span class="comment">// then, we parse the definitionName from the string.</span>
        QString definitionName = &quot;&quot;;
        for (int i = nextSection; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);
            if (currChar == ';') {
                nextSection = i + 1;
                break;
            } else if (currChar == '\\') {
                <span class="comment">// the next character is escaped.</span>
                i += 1;
            }
            definitionName += customString.at(i);
        }

        <span class="comment">// check to see whether this custom string was built by us</span>
        if (nextSection == oldNextSection) {
            <span class="comment">// nope; just return an empty detail.</span>
            return QContactDetail();
        }

        <span class="comment">// then, we parse the values.</span>
        QVariantMap values;
        QString currKey = &quot;&quot;;
        QString currVal = &quot;&quot;;
        for (int i = nextSection; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);
            if (currChar == ';') {
                <span class="comment">// finished with the key/value pairs.</span>
                nextSection = i+1;
                break;
            } else if (currChar == '=') {
                <span class="comment">// we have found the key.  now find the value</span>
                for (int j = i + 1; j &lt; customString.length(); j++) {
                    currChar = customString.at(j);
                    if (currChar == ',') {
                        <span class="comment">// finished with this key/value pair</span>
                        i = j;
                        break;
                    } else if (currChar == ';') {
                        <span class="comment">// finished with all key/value pairs.</span>
                        i = j - 1; <span class="comment">// we want to see this char next time around.</span>
                        break;
                    } else if (currChar == '\\') {
                        j += 1;
                        currVal += customString.at(j);
                    } else {
                        currVal += currChar;
                    }
                }

                <span class="comment">// and insert it into the map</span>
                values.insert(currKey, currVal);
                currKey = &quot;&quot;;
                currVal = &quot;&quot;;
            } else if (currChar == ',') {
                <span class="comment">// finished with this key/value pair.</span>
                <span class="comment">// this should have been handled in the above case...</span>
                currKey = &quot;&quot;;
                currVal = &quot;&quot;;
            } else if (currChar == '\\') {
                <span class="comment">// an escaped character in the key</span>
                i += 1;
                currKey += customString.at(i);
            } else {
                <span class="comment">// a normal character in the key.</span>
                currKey += currChar;
            }
        }

        <span class="comment">// check to see whether this custom string was built by us</span>
        if (nextSection == oldNextSection) {
            <span class="comment">// nope; just return an empty detail.</span>
            return QContactDetail();
        }

        <span class="comment">// we parse the attributes.</span>
        QMap&lt;QString, QString&gt; attrs;
        currKey = &quot;&quot;;
        QString currAttr = &quot;&quot;;
        for (int i = nextSection; i &lt; customString.length(); i++) {
            QChar currChar = customString.at(i);
            if (currChar == ';') {
                <span class="comment">// finished with the key/value pairs.</span>
                nextSection = i+1;
                break;
            } else if (currChar == '=') {
                <span class="comment">// we have found the key.  now find the value</span>
                for (int j = i + 1; j &lt; customString.length(); j++) {
                   currChar = customString.at(j);
                    if (currChar == ',') {
                        <span class="comment">// finished with this key/value pair</span>
                        i = j;
                        break;
                    } else if (currChar == ';') {
                        <span class="comment">// finished with all key/value pairs.</span>
                        i = j - 1; <span class="comment">// we want to see this char next time around.</span>
                        break;
                    } else if (currChar == '\\') {
                        j += 1;
                        currAttr += customString.at(j);
                    } else {
                        currAttr += currChar;
                    }
                }

                <span class="comment">// and insert it into the map</span>
                values.insert(currKey, currAttr);
                currKey = &quot;&quot;;
                currAttr = &quot;&quot;;
           } else if (currChar == ',') {
                <span class="comment">// finished with this key/value pair.</span>
                <span class="comment">// this should have been handled in the above case...</span>
                currKey = &quot;&quot;;
                currVal = &quot;&quot;;
            } else if (currChar == '\\') {
                <span class="comment">// an escaped character in the key</span>
                i += 1;
                currKey += customString.at(i);
            } else {
                <span class="comment">// a normal character in the key.</span>
                currKey += currChar;
            }
        }

        <span class="comment">// check to see whether this custom string was built by us</span>
        if (nextSection == oldNextSection) {
            <span class="comment">// nope; just return an empty detail.</span>
            return QContactDetail();
        }

        <span class="comment">// having parsed the definitionName, values, attributes, and preferences we build the detail.</span>
        QContactDetail retn(definitionName);
        QStringList keys = values.keys();
        foreach (const QString&amp; key, keys)
            retn.setValue(key, values.value(key));
        return retn;
    }

    QContact Serialiser::convertVcard(const QStringList&amp; vcardLines)
    {
        QMultiMap&lt;QString, QContactDetail&gt; vcardDetails;  <span class="comment">// details built from vcard-supported fields</span>
        QMultiMap&lt;QString, QContactDetail&gt; customDetails; <span class="comment">// details built from x-custom fields which are linked to vcardDetails</span>
        QList&lt;QContactDetail&gt; unlinkedCustomDetails;      <span class="comment">// details built from x-custom fields</span>

        QMap&lt;QString, QContactDetail&gt; customPreferredForUuid; <span class="comment">// map of detail uuid to detail which has some associated preference information.</span>
        QMap&lt;QString, QStringList&gt; customPreferredFor;  <span class="comment">// map of detail uuid to list of actionds for which the detail is preferred.</span>
        QList&lt;QContactDetail&gt; vcardPreferredFor;  <span class="comment">// list of details build from vcard-supported fields which had the pref flag set.</span>

        QContact retn;
        QStringList strippedVcardLines = removeClutter(vcardLines);
        foreach (const QString&amp; line, strippedVcardLines) {
            if (line.startsWith(&quot;X-com-nokia-mobility-contacts-vcard-detail-&quot;)) {
                QContactDetail det = convertCustomString(line);
                if (!det.isEmpty()) {
                    <span class="comment">// the line was a custom detail that we saved.</span>
                    QString linkString = findLinkStringFromCustomString(line);
                    if (linkString.isEmpty()) {
                        unlinkedCustomDetails.append(det);
                    } else {
                        customDetails.insert(linkString, det);
                    }

                    QString detailUuid = QUuid::createUuid().toString();
                    customPreferredForUuid.insert(detailUuid, det);
                    customPreferredFor.insert(detailUuid, findActionIdsFromCustomString(line));
                }
            } else {
                QContactDetail det = parsePropertyType(line);
                QString defId = det.definitionName();
                if (defId.isEmpty()) {
                    <span class="comment">// this must be another program's custom field.  ignore it.</span>
                } else {
                    <span class="comment">// this is a built-in vcard supported field.  build the detail.</span>
                    QStringList contexts = parseContext(line);
                    if (!contexts.isEmpty())
                        det.setContexts(contexts);
                    if (defId == QContactPhoneNumber::DefinitionName) {
                        det.setValue(QContactPhoneNumber::FieldSubTypes, parseAttributes(line));
                        det.setValue(QContactPhoneNumber::FieldNumber, parseValue(line));
                        vcardDetails.insert(&quot;TEL&quot;, det);
                    } else if (defId == QContactEmailAddress::DefinitionName) {
                        det.setValue(QContactEmailAddress::FieldEmailAddress, parseValue(line));
                        vcardDetails.insert(&quot;EMAIL&quot;, det);
                    } else if (defId == &quot;Url&quot;) {
                        det.setValue(QContactUrl::FieldSubType, parseAttributes(line));
                        det.setValue(QContactUrl::DefinitionName, parseValue(line));
                        vcardDetails.insert(&quot;URL&quot;, det);
                    } else if (defId == QContactAvatar::DefinitionName) {
                        det.setValue(QContactAvatar::FieldSubType, parseAttributes(line));
                        det.setValue(QContactAvatar::FieldAvatar, parseValue(line));
                        vcardDetails.insert(&quot;PHOTO&quot;, det);
                    } else if (defId == QContactGuid::DefinitionName) {
                        det.setValue(QContactGuid::FieldGuid, parseValue(line));
                        vcardDetails.insert(&quot;UID&quot;, det);
                    } else if (defId == QContactAddress::DefinitionName) {
                        det.setValue(QContactAddress::FieldSubTypes, parseAttributes(line));
                        QStringList fieldValues = parseValue(line).split(&quot;;&quot;);
                        <span class="comment">// ignore values 0 and 1 (extended and postal address) in this implementation</span>
                        det.setValue(QContactAddress::FieldStreet, fieldValues.value(2));
                        det.setValue(QContactAddress::FieldLocality, fieldValues.value(3));
                        det.setValue(QContactAddress::FieldRegion, fieldValues.value(4));
                        det.setValue(QContactAddress::FieldPostcode, fieldValues.value(5));
                        det.setValue(QContactAddress::FieldCountry, fieldValues.value(6));
                        vcardDetails.insert(&quot;ADR&quot;, det);
                    } else if (defId == QContactName::DefinitionName) {
                        QStringList fieldValues = parseValue(line).split(&quot;;&quot;);
                        if (vcardDetails.contains(&quot;N&quot;)) {
                            <span class="comment">// modify the existing name</span>
                            QContactDetail currName = vcardDetails.value(&quot;N&quot;);
                            currName.setValue(QContactName::FieldPrefix, fieldValues.value(3));
                            currName.setValue(QContactName::FieldFirst, fieldValues.value(1));
                            currName.setValue(QContactName::FieldMiddle, fieldValues.value(2));
                            currName.setValue(QContactName::FieldLast, fieldValues.value(0));
                            currName.setValue(QContactName::FieldSuffix, fieldValues.value(4));
                            vcardDetails.replace(&quot;N&quot;, currName);
                        } else {
                            <span class="comment">// create a new name if no existing name stored.</span>
                            det.setValue(QContactName::FieldPrefix, fieldValues.value(3));
                            det.setValue(QContactName::FieldFirst, fieldValues.value(1));
                            det.setValue(QContactName::FieldMiddle, fieldValues.value(2));
                            det.setValue(QContactName::FieldLast, fieldValues.value(0));
                            det.setValue(QContactName::FieldSuffix, fieldValues.value(4));
                            vcardDetails.insert(&quot;N&quot;, det);
                        }
                    } else {
                        <span class="comment">// we don't know how to map this value type.  Ignore the line.</span>
                        continue;
                    }

                    if (parsePreferred(line)) {
                        vcardPreferredFor.append(det);
                    }
                }
            }
       }

        <span class="comment">// at this stage, we have built two sets of details</span>
        <span class="comment">// the first set is built from our custom lines, which contain all the information</span>
        <span class="comment">// the second set is built from the vcard-builtin lines.</span>
        <span class="comment">// we now want to reconcile the two sets by throwing out any custom-set details</span>
        <span class="comment">//     which are not related to any built-in line but should be.</span>
        foreach (const QString&amp; linkString, customDetails.keys()) {
            foreach (const QContactDetail&amp; linkedDetail, customDetails.values(linkString)) {
                bool found = false;
                QContactDetail toRemove;
                foreach (const QContactDetail&amp; vcardDetail, vcardDetails.values(linkString)) {
                    if (linkedDetail.values() == vcardDetail.values()) {
                        toRemove = vcardDetail;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    <span class="comment">// this supposedly linked detail has no corresponding vcard detail.</span>
                    <span class="comment">// it is an orphan.  ignore it.</span>
                } else {
                    <span class="comment">// remove the vcard detail from the map</span>!
                    vcardDetails.remove(linkString, toRemove);
                    vcardPreferredFor.removeOne(toRemove);

                    <span class="comment">// save the more verbose (ie, built from custom string) detail.</span>
                    toRemove = linkedDetail; <span class="comment">// copy so we can call non-const function.</span>
                    retn.saveDetail(&amp;toRemove);
                }
            }
        }

        <span class="comment">// any details which are left in the vcardDetails map should be included</span>
        foreach (const QContactDetail&amp; det, vcardDetails.values()) {
            QContactDetail temp = det;
            retn.saveDetail(&amp;temp);
        }

        <span class="comment">// as should any unlinked custom details.</span>
        foreach (const QContactDetail&amp; det, unlinkedCustomDetails) {
            QContactDetail temp = det;
            retn.saveDetail(&amp;temp);
        }

        <span class="comment">// now set any preferences found in the vcard should be set</span>
        <span class="comment">//foreach (const QContactDetail&amp; det, vcardPreferredFor) {</span>
            <span class="comment">// there is no granularity here; hence, we assume that if any detail is listed as preferred,</span>
            <span class="comment">// then it is the preferred detail for every action available to it.</span>

            <span class="comment">// new:</span>
            <span class="comment">//foreach (QContactAbstractAction* impl, QContactAbstractAction::implementations()) {</span>
            <span class="comment">//    foreach (const QString&amp; actionId, impl-&gt;actionsForDetail(det)) {</span>
            <span class="comment">//        retn.setPreferredDetail(actionId, det);</span>
            <span class="comment">//    }</span>
            <span class="comment">//}</span>

            <span class="comment">// old:</span>
            <span class="comment">//foreach (const QString&amp; actionId, QContactManager::availableActions(det.definitionName())) {</span>
            <span class="comment">//    retn.setPreferredDetail(actionId, det);</span>
            <span class="comment">//}</span>
        <span class="comment">//}</span>

        <span class="comment">// and now we set any preferences saved in the custom strings</span>
        foreach (const QString&amp; detailUuid, customPreferredForUuid.keys()) {
            QContactDetail det = customPreferredForUuid.value(detailUuid);
            foreach (const QStringList&amp; actionIds, customPreferredFor.values(detailUuid)) {
                foreach (const QString&amp; actionId, actionIds) {
                    retn.setPreferredDetail(actionId, det);
                }
            }
        }

        return retn;
    }

    QStringList Serialiser::removeClutter(const QStringList&amp; vcard)
    {
        QStringList copy;

        foreach (QString line, vcard) {
            QString firstBit = line.split(&quot;:&quot;, QString::SkipEmptyParts).value(0);
            if (firstBit == &quot;BEGIN&quot; || firstBit == &quot;VERSION&quot; || firstBit == &quot;CLASS&quot; || firstBit == &quot;PRODID&quot; || firstBit == &quot;REV&quot; || firstBit == &quot;END&quot;) {
                <span class="comment">// ignore this line.</span>
            } else {
                copy.append(line);
            }
        }

        return copy;
    }

    QContactDetail Serialiser::parsePropertyType(const QString&amp; line)
    {
        <span class="comment">// depending on the line signature, return a QContact&lt;PropertyType&gt; object.</span>
        QStringList semiColonSplit = line.split(&quot;;&quot;);
        QStringList colonSplit = line.split(&quot;:&quot;);
        if (semiColonSplit.size() == 0 &amp;&amp; colonSplit.size() == 0)
            return QContactDetail();

        if (semiColonSplit.size() != 0) {
            if (semiColonSplit.at(0) == &quot;TEL&quot;) {
                return QContactPhoneNumber();
            } else if (semiColonSplit.at(0) == &quot;EMAIL&quot;) {
                return QContactEmailAddress();
            } else if (semiColonSplit.at(0) == &quot;ADR&quot;) {
                return QContactAddress();
            } else if (semiColonSplit.at(0) == &quot;PHOTO&quot;) {
                return QContactAvatar();
            } else if (semiColonSplit.at(0) == &quot;UID&quot;) {
                return QContactGuid();
            }
        }

        <span class="comment">// ok, so we have dealt with the cases where a semi colon proceeds the first token.</span>
        <span class="comment">// Now we must deal with the fields where the first token is proceeded by a colon.</span>
        if (colonSplit.size() != 0) {
            if (colonSplit.at(0) == &quot;URL&quot;) {
                return QContactDetail(&quot;Url&quot;);
            } else if (colonSplit.at(0) == &quot;N&quot;) {
                QContactName name;
                return name;
            } else if (colonSplit.at(0) == &quot;FN&quot;) {
                QContactDisplayLabel label;
                return label;
            }
        }

        <span class="comment">// otherwise, it's an unknown or custom field.</span>
        return QContactDetail();
    }

    QStringList Serialiser::parseContext(const QString&amp; line)
    {
        <span class="comment">// depending on the TYPE= section, return a context (work/home/...)</span>
        <span class="comment">// returns the first one found.</span>
        QStringList result;
        QStringList contexts;
        contexts &lt;&lt; QContactDetail::ContextHome &lt;&lt; QContactDetail::ContextWork &lt;&lt; QContactDetail::ContextOther;
        QStringList semiColonSplit = line.split(&quot;;&quot;);
        for (int i = 0; i &lt; semiColonSplit.size(); i++) {
            QString currSplit = semiColonSplit.at(i);
            if (currSplit.startsWith(&quot;TYPE=&quot;)) {
                for (int j = 0; j &lt; contexts.size(); j++) {
                    QString currContext = contexts.at(j);
                    if (currSplit.contains(currContext.toLower()) &amp;&amp; !result.contains(currContext)) {
                        result.append(currContext);
                        return result;
                    }
                }
            }
       }

        return result;
    }

    QString Serialiser::parseValue(const QString&amp; line)
    {
        <span class="comment">// return the settable value of this field</span>
        QStringList colonSplit = line.split(&quot;:&quot;);
        if (colonSplit.size() != 2) {
            return QString();
        }

        return colonSplit.at(1);
    }

    QString Serialiser::parseAttributes(const QString&amp; line)
    {
        <span class="comment">// return any special attributes of this field</span>
        QString result = &quot;&quot;;
        QStringList contexts;
        contexts &lt;&lt; QContactDetail::ContextHome &lt;&lt; QContactDetail::ContextWork &lt;&lt; QContactDetail::ContextOther;
        QStringList semiColonSplit = line.split(&quot;;&quot;);
        for (int i = 0; i &lt; semiColonSplit.size(); i++) {
            QString currSplit = semiColonSplit.at(i);
            if (currSplit.startsWith(&quot;TYPE=&quot;)) {
                <span class="comment">// get rid of the TYPE= preamble, then remove any Contexts/Pref</span>
                QString possibleAttrs = currSplit.remove(0,5);
                int startIndex = -1;

                <span class="comment">// firstly, remove pref if it exists.</span>
                startIndex = possibleAttrs.indexOf(&quot;pref&quot;);
                if (startIndex != -1)
                     possibleAttrs = possibleAttrs.remove(startIndex, 4);

                <span class="comment">// then, remove any contexts</span>
                for (int j = 0; j &lt; contexts.size(); j++) {
                    startIndex = possibleAttrs.indexOf(contexts.at(j).toLower());
                    if (startIndex != -1) {
                        possibleAttrs = possibleAttrs.remove(startIndex, contexts.at(j).length());
                    }
                }

                <span class="comment">// finally, remove any value</span>
                startIndex = possibleAttrs.indexOf(&quot;:&quot;);
                if (startIndex != -1) {
                    possibleAttrs = possibleAttrs.left(startIndex);
                }

                <span class="comment">// now we should be left with just attributes, separated by &quot;,&quot;.</span>
                QStringList attributes = possibleAttrs.split(&quot;,&quot;, QString::SkipEmptyParts);
                foreach (QString attribute, attributes) {
                    <span class="comment">// special cases: deal with the vcard TYPE attributes that don't</span>
                    <span class="comment">// map directly to our QContactDetail SubType attributes.</span>
                    if (attribute == &quot;cell&quot;) {
                        result += &quot;Mobile,&quot;;
                    } else if (attribute == &quot;fax&quot;) {
                        result += &quot;Facsimile,&quot;;
                    } else if (attribute == &quot;msg&quot;) {
                        result += &quot;Messaging,&quot;;
                    } else if (attribute == &quot;dom&quot;) {
                        result += &quot;Domestic,&quot;;
                    } else if (attribute == &quot;intl&quot;) {
                        result += &quot;International,&quot;;
                    } else {
                        QString firstLetter = &quot;&quot;;
                        firstLetter += attribute.at(0);
                        firstLetter = firstLetter.toUpper();
                        QString rest = attribute.remove(0,1);
                        result += firstLetter + rest + &quot;,&quot;;
                    }
                }

                <span class="comment">// remove the trailing `,'</span>
                result.chop(1);
            }
        }

        return result;
    }

    bool Serialiser::parsePreferred(const QString&amp; line)
    {
        <span class="comment">// return whether this field is preferred</span>
        QStringList semiColonSplit = line.split(&quot;;&quot;);
        for (int i = 0; i &lt; semiColonSplit.size(); i++) {
            QString currSplit = semiColonSplit.at(i);
            if (currSplit.startsWith(&quot;TYPE=&quot;)) {
                if (currSplit.contains(&quot;pref&quot;)) {
                    return true;
                }
            }
        }

        return false;
    }

    bool Serialiser::detailIsPreferredForAnything(const QContact&amp; contact, const QContactDetail&amp; detail)
    {
        foreach (const QContactActionDescriptor&amp; actionDescr, contact.availableActions(QString())) {
            if (contact.isPreferredDetail(actionDescr.actionName(), detail)) {
                return true;
            }
        }

        return false;
    }

    QStringList Serialiser::convertContact(const QContact&amp; contact)
    {
        QStringList vcard;
        QContact c = contact;

        QDateTime curr = QDateTime::currentDateTime();
        QString entry = &quot;REV:&quot; + curr.toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        vcard &lt;&lt; &quot;BEGIN:VCARD&quot; &lt;&lt; &quot;VERSION:3.0&quot; &lt;&lt; &quot;CLASS:PUBLIC&quot; &lt;&lt; &quot;PRODID:-<span class="comment">//qcontactvcardserializer from Nokia.com//NONSGML Version 1//EN&quot; &lt;&lt; entry;</span>

        QStringList customVcardFields;

        QStringList vcardFieldsWithValues;
        foreach (const QContactDetail&amp; det, contact.details()) {
            <span class="comment">// we look at each detail of the contact</span>
            <span class="comment">// if the detail can be mapped to a non-singular vcard field, we create the vcard entry and the custom entry</span>
            <span class="comment">// if the detail can be mapped to a singular vcard field, we check to see that another detail which also</span>
            <span class="comment">//     maps to the same vcard field hasn't been saved as the vcard entry before doing the above.</span>
            QString definitionName = det.definitionName();
            if (definitionName == QContactName::DefinitionName) {
                bool saved = false;

                <span class="comment">// only one name is allowed</span>
                if (!vcardFieldsWithValues.contains(&quot;N&quot;)) {
                    entry = &quot;N:&quot; + det.value(QContactName::FieldLast) + &quot;;&quot; + det.value(QContactName::FieldFirst) + &quot;;&quot; + det.value(QContactName::FieldMiddle) + &quot;;&quot; + det.value(QContactName::FieldPrefix) + det.value(QContactName::FieldSuffix);
                    vcardFieldsWithValues &lt;&lt; &quot;N&quot;;
                    vcard &lt;&lt; entry;
                    customVcardFields &lt;&lt; convertDetail(contact, det, &quot;N&quot;);
                    saved = true;
                }

                <span class="comment">// if not already saved, save as a generic custom field.</span>
                if (!saved) {
                    customVcardFields &lt;&lt; convertDetail(contact, det);
                }
            } else if (definitionName == QContactDisplayLabel::DefinitionName) {
                <span class="comment">// only one formatted name is allowed</span>
                if (!vcardFieldsWithValues.contains(&quot;FN&quot;)) {
                    entry = &quot;FN:&quot; + det.value(QContactDisplayLabel::FieldLabel);
                    vcard &lt;&lt; entry;
                    vcardFieldsWithValues &lt;&lt; &quot;FN&quot;;
                    customVcardFields &lt;&lt; convertDetail(contact, det, &quot;FN&quot;);
                }
            } else if (definitionName == QContactAddress::DefinitionName) {
                <span class="comment">// any number of address fields are allowed.</span>
                entry = &quot;ADR;TYPE=&quot;;
                QString typestr = &quot;&quot;;
                QStringList subTypes = det.value&lt;QStringList&gt;(QContactAddress::FieldSubTypes);
                QStringList contexts = det.contexts();
                if (contexts.contains(QContactDetail::ContextHome)) typestr += &quot;home,&quot;;
                if (contexts.contains(QContactDetail::ContextWork)) typestr += &quot;work,&quot;;
                if (contexts.contains(QContactDetail::ContextOther)) typestr += &quot;other,&quot;;
                if (subTypes.contains(QContactAddress::SubTypeDomestic)) typestr += &quot;dom,&quot;;
                if (subTypes.contains(QContactAddress::SubTypeInternational)) typestr += &quot;intl,&quot;;
                if (subTypes.contains(QContactAddress::SubTypeParcel)) typestr += &quot;parcel,&quot;;
                if (subTypes.contains(QContactAddress::SubTypePostal)) typestr += &quot;postal,&quot;;
                if (detailIsPreferredForAnything(contact, det)) typestr += &quot;pref,&quot;;
                typestr.chop(1);
                entry += typestr + &quot;:;;&quot; + det.value(QContactAddress::FieldStreet) + &quot;;&quot; + det.value(QContactAddress::FieldLocality) + &quot;;&quot; + det.value(QContactAddress::FieldRegion) + &quot;;&quot; + det.value(QContactAddress::FieldPostcode) + &quot;;&quot; + det.value(QContactAddress::FieldCountry);
                vcard &lt;&lt; entry;
                <span class="comment">//entry = &quot;LABEL;TYPE=&quot; + typestr + &quot;:&quot; + det.value(QContactAddress::FieldDisplayLabel);</span>
                <span class="comment">//vcard &lt;&lt; entry;</span>
                vcardFieldsWithValues &lt;&lt; &quot;ADR&quot;;
                vcardFieldsWithValues &lt;&lt; &quot;LABEL&quot;;
                customVcardFields &lt;&lt; convertDetail(contact, det, &quot;ADR&quot;);
            } else if (definitionName == &quot;Url&quot;) {
                <span class="comment">// any number of Url fields are allowed.</span>
                entry = &quot;URL:&quot; + det.value(&quot;Url&quot;);
                vcard &lt;&lt; entry;
                vcardFieldsWithValues &lt;&lt; &quot;URL&quot;;
                customVcardFields &lt;&lt; convertDetail(contact, det, &quot;URL&quot;);
            } else if (definitionName == QContactEmailAddress::DefinitionName) {
                <span class="comment">// any number of email address fields are allowed.</span>
                entry = &quot;EMAIL;TYPE=internet&quot;;
                if (detailIsPreferredForAnything(contact, det)) entry += &quot;,pref&quot;;
                entry += &quot;:&quot; + det.value(QContactEmailAddress::FieldEmailAddress);
                vcard &lt;&lt; entry;
                vcardFieldsWithValues &lt;&lt; &quot;EMAIL&quot;;
                customVcardFields &lt;&lt; convertDetail(contact, det, &quot;EMAIL&quot;);
            } else if (definitionName == QContactPhoneNumber::DefinitionName) {
                <span class="comment">// any number of telephone fields are allowed.</span>
                entry = &quot;TEL;TYPE=&quot;;
                QString typeStr = &quot;&quot;;
                QStringList subTypes = det.value&lt;QStringList&gt;(QContactPhoneNumber::FieldSubTypes);
                QStringList contexts = det.contexts();
                if (subTypes.contains(QContactPhoneNumber::SubTypeMobile)) typeStr += &quot;cell,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeFacsimile)) typeStr += &quot;fax,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeVideo)) typeStr += &quot;video,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypePager)) typeStr += &quot;pager,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeModem)) typeStr += &quot;modem,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeBulletinBoardSystem)) typeStr += &quot;bbs,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeMessagingCapable)) typeStr += &quot;msg,&quot;;
                if (subTypes.contains(QContactPhoneNumber::SubTypeLandline) || typeStr.isEmpty()) typeStr += &quot;voice,&quot;;
                if (contexts.contains(QContactDetail::ContextHome)) typeStr = &quot;home,&quot; + typeStr;
                if (contexts.contains(QContactDetail::ContextWork)) typeStr = &quot;work,&quot; + typeStr;
                if (contexts.contains(QContactDetail::ContextOther)) typeStr = &quot;other,&quot; + typeStr;
                if (detailIsPreferredForAnything(contact, det)) typeStr += &quot;pref,&quot;;
                typeStr.chop(1);
                entry += typeStr + &quot;:&quot; + det.value(QContactPhoneNumber::FieldNumber);
                vcard &lt;&lt; entry;
                vcardFieldsWithValues &lt;&lt; &quot;TEL&quot;;
                customVcardFields &lt;&lt; convertDetail(contact, det, &quot;TEL&quot;);
            } else if (definitionName == QContactAvatar::DefinitionName) {
                <span class="comment">// only one photo field is allowed per vcard, according to the spec</span>
                if (vcardFieldsWithValues.contains(&quot;PHOTO&quot;)) {
                    <span class="comment">// vcard already contains a photo field; save this one as a custom field only.</span>
                    customVcardFields &lt;&lt; convertDetail(contact, det);
                } else {
                    <span class="comment">// vcard does not yet contain a photo field; save this as the photo field.</span>
                    vcardFieldsWithValues &lt;&lt; &quot;PHOTO&quot;;
                    entry = &quot;PHOTO;VALUE=uri:&quot; + det.value(QContactAvatar::FieldAvatar);
                    customVcardFields &lt;&lt; convertDetail(contact, det, &quot;PHOTO&quot;);
                }
            } else if (definitionName == QContactGuid::DefinitionName) {
                <span class="comment">// only one UID field is allowed per vcard, according to the spec</span>
                if (vcardFieldsWithValues.contains(&quot;UID&quot;)) {
                    <span class="comment">// vcard already contains a photo field; save this one as a custom field only.</span>
                    customVcardFields &lt;&lt; convertDetail(contact, det);
                } else {
                    <span class="comment">// vcard does not yet contain a UID field; save this as the UID field.</span>
                    vcardFieldsWithValues &lt;&lt; &quot;UID&quot;;
                    entry = &quot;UID:&quot; + det.value(QContactGuid::FieldGuid);
                    customVcardFields &lt;&lt; convertDetail(contact, det, &quot;UID&quot;);
                }
            } else {
                <span class="comment">// there is no vcard field mapping for this detail;</span>
                <span class="comment">// so, simply save it as a custom field.</span>
                customVcardFields &lt;&lt; convertDetail(contact, det); <span class="comment">// doesn't map to any vcard field</span>
            }
        }

        <span class="comment">// now append our custom vcard fields and end the vcard.</span>
        vcard &lt;&lt; customVcardFields;
        vcard &lt;&lt; &quot;END:VCARD&quot;;

        return vcard;
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td width="20%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td align="right"><div align="right">Qt Mobility Project 1.0.0 (Technical Preview)</div></td>
</tr></table></div></address></body>
</html>
