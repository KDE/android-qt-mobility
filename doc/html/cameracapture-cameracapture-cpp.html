<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>cameracapture.cpp Example File (cameracapture/cameracapture.cpp)</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://qt.nokia.com/"><img src="images/qtlogo.png" align="left" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">All&nbsp;Functions</font></a>&nbsp;&middot;</td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">cameracapture.cpp Example File<br /><span class="small-subtitle">cameracapture/cameracapture.cpp</span>
</h1>
<pre><span class="comment">    /****************************************************************************
    **
    ** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
    ** All rights reserved.
    ** Contact: Nokia Corporation (qt-info@nokia.com)
    **
    ** This file is part of the Qt Mobility Components.
    **
    ** $QT_BEGIN_LICENSE:LGPL$
    ** No Commercial Usage
    ** This file contains pre-release code and may not be distributed.
    ** You may use this file in accordance with the terms and conditions
    ** contained in the Technology Preview License Agreement accompanying
    ** this package.
    **
    ** GNU Lesser General Public License Usage
    ** Alternatively, this file may be used under the terms of the GNU Lesser
    ** General Public License version 2.1 as published by the Free Software
    ** Foundation and appearing in the file LICENSE.LGPL included in the
    ** packaging of this file.  Please review the following information to
    ** ensure the GNU Lesser General Public License version 2.1 requirements
    ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
    **
    ** In addition, as a special exception, Nokia gives you certain additional
    ** rights.  These rights are described in the Nokia Qt LGPL Exception
    ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
    **
    ** If you have questions regarding the use of this file, please contact
    ** Nokia at qt-info@nokia.com.
    **
    **
    **
    **
    **
    **
    **
    **
    ** $QT_END_LICENSE$
    **
    ****************************************************************************/</span>

    #include &quot;cameracapture.h&quot;
    #include &quot;ui_cameracapture.h&quot;
    #include &quot;settings.h&quot;

    #include &lt;qmediaservice.h&gt;
    #include &lt;qmediarecorder.h&gt;
    #include &lt;experimental/qcamera.h&gt;
    #include &lt;qvideowidget.h&gt;

    #include &lt;QtGui&gt;

    CameraCapture::CameraCapture(QWidget *parent) :
        QMainWindow(parent),
        ui(new Ui::CameraCapture),
        mediaRecorder(0),
        camera(0),
        service(0),
        videoWidget(0)
    {
        ui-&gt;setupUi(this);

        outputDir = QDir::currentPath();

        <span class="comment">//camera devices</span>
        QByteArray cameraDevice;

        ui-&gt;actionCamera-&gt;setMenu(new QMenu(this));
        QActionGroup *videoDevicesGroup = new QActionGroup(this);
        videoDevicesGroup-&gt;setExclusive(true);
        foreach(const QByteArray &amp;deviceName, QCamera::availableDevices()) {
            QString description = deviceName+&quot; &quot;+camera-&gt;deviceDescription(deviceName);
            QAction *videoDeviceAction = new QAction(description, videoDevicesGroup);
            videoDeviceAction-&gt;setCheckable(true);
            videoDeviceAction-&gt;setData(QVariant(deviceName));
            if (cameraDevice.isEmpty()) {
                cameraDevice = deviceName;
                videoDeviceAction-&gt;setChecked(true);
            }
            ui-&gt;actionCamera-&gt;menu()-&gt;addAction(videoDeviceAction);
        }

        connect(videoDevicesGroup, SIGNAL(triggered(QAction*)), this, SLOT(updateCameraDevice(QAction*)));

        ui-&gt;actionAudio-&gt;setMenu(new QMenu(this));

        setCamera(cameraDevice);
    }

    CameraCapture::~CameraCapture()
    {
        delete mediaRecorder;
        delete videoWidget;
        delete camera;
    }

    void CameraCapture::setCamera(const QByteArray &amp;cameraDevice)
    {
        delete mediaRecorder;
        delete videoWidget;
        delete camera;

        if (cameraDevice.isEmpty())
            camera = new QCamera;
        else
            camera = new QCamera(cameraDevice);

        connect(camera, SIGNAL(stateChanged(QCamera::State)), this, SLOT(updateCameraState(QCamera::State)));

        service = camera-&gt;service();

        <span class="comment">//audio devices</span>
        ui-&gt;actionAudio-&gt;menu()-&gt;clear();
        QActionGroup *audioDevicesGroup = new QActionGroup(this);
        audioDevicesGroup-&gt;setExclusive(true);

        if (service) {
            mediaRecorder = new QMediaRecorder(camera);

            foreach(const QString deviceName, service-&gt;supportedEndpoints(QMediaService::AudioDevice)) {
                QString description = service-&gt;endpointDescription(QMediaService::AudioDevice, deviceName);
                QAction *audioDeviceAction = new QAction(deviceName+&quot; &quot;+description, audioDevicesGroup);
                audioDeviceAction-&gt;setData(QVariant(deviceName));
                audioDeviceAction-&gt;setCheckable(true);

                ui-&gt;actionAudio-&gt;menu()-&gt;addAction(audioDeviceAction);

                if (service-&gt;activeEndpoint(QMediaService::AudioDevice) == deviceName)
                    audioDeviceAction-&gt;setChecked(true);
            }
        } else {
            qWarning() &lt;&lt; &quot;Camera service is not available&quot;;
        }

        connect(audioDevicesGroup, SIGNAL(triggered(QAction*)), this, SLOT(updateAudioDevice(QAction*)));

        mediaRecorder-&gt;setOutputLocation(QUrl(&quot;test.mkv&quot;));

        connect(mediaRecorder, SIGNAL(durationChanged(qint64)), this, SLOT(updateRecordTime()));
        connect(mediaRecorder, SIGNAL(error(QMediaRecorder::Error)), this, SLOT(displayErrorMessage()));

        camera-&gt;setMetaData(QtMedia::Title, QVariant(QLatin1String(&quot;Test Title&quot;)));

        videoWidget = new QVideoWidget(mediaRecorder);
        ui-&gt;stackedWidget-&gt;addWidget(videoWidget);

        updateCameraState(camera-&gt;state());

        connect(camera, SIGNAL(readyForCaptureChanged(bool)), ui-&gt;imageCaptureBox, SLOT(setEnabled(bool)));
        connect(camera, SIGNAL(imageCaptured(QString,QImage)), this, SLOT(processCapturedImage(QString,QImage)));

    }

    void CameraCapture::updateRecordTime()
    {
        QString str = QString(&quot;Recorded %1 sec&quot;).arg(mediaRecorder-&gt;duration()/1000);
        ui-&gt;statusbar-&gt;showMessage(str);
    }

    void CameraCapture::processCapturedImage(const QString&amp; fname, const QImage&amp; img)
    {
        Q_UNUSED(img);
        qDebug() &lt;&lt; &quot;image captured:&quot; &lt;&lt; fname;
    }

    void CameraCapture::settings()
    {
        Settings settingsDialog(mediaRecorder);

        settingsDialog.setAudioSettings(mediaRecorder-&gt;audioSettings());
        settingsDialog.setVideoSettings(mediaRecorder-&gt;videoSettings());
        settingsDialog.setFormat(mediaRecorder-&gt;format());

        if (settingsDialog.exec()) {
            mediaRecorder-&gt;setEncodingSettings(
                    settingsDialog.audioSettings(),
                    settingsDialog.videoSettings(),
                    settingsDialog.format());
        }
    }

    void CameraCapture::record()
    {
        mediaRecorder-&gt;record();
        updateRecordTime();
    }

    void CameraCapture::pause()
    {
        mediaRecorder-&gt;pause();
    }

    void CameraCapture::stop()
    {
        mediaRecorder-&gt;stop();
    }

    void CameraCapture::takeImage()
    {
        int lastImage = 0;
        foreach( QString fileName, outputDir.entryList(QStringList() &lt;&lt; &quot;img_*.jpg&quot;) ) {
            int imgNumber = fileName.mid(4, fileName.size()-8).toInt();
            lastImage = qMax(lastImage, imgNumber);
        }

        camera-&gt;capture(QString(&quot;img_%1.jpg&quot;).arg(lastImage+1,
                                                  4, <span class="comment">//fieldWidth</span>
                                                  10,
                                                  QLatin1Char('0')));
    }

    void CameraCapture::toggleCamera()
    {
        if (camera-&gt;state() == QCamera::ActiveState)
            camera-&gt;stop();
        else
            camera-&gt;start();
    }

    void CameraCapture::updateCameraState(QCamera::State state)
    {
        if (state == QCamera::ActiveState) {
            ui-&gt;actionCamera-&gt;setEnabled(false);
            ui-&gt;actionAudio-&gt;setEnabled(false);
            ui-&gt;actionSettings-&gt;setEnabled(false);

            ui-&gt;startCameraButton-&gt;setText(tr(&quot;Stop Camera&quot;));
            ui-&gt;startCameraButton-&gt;setChecked(true);
            ui-&gt;videoCaptureBox-&gt;setEnabled(true);
        } else {
            ui-&gt;actionCamera-&gt;setEnabled(true);
            ui-&gt;actionAudio-&gt;setEnabled(true);
            ui-&gt;actionSettings-&gt;setEnabled(true);

            ui-&gt;startCameraButton-&gt;setText(tr(&quot;Start Camera&quot;));
            ui-&gt;startCameraButton-&gt;setChecked(false);
            ui-&gt;imageCaptureBox-&gt;setEnabled(false);
            ui-&gt;videoCaptureBox-&gt;setEnabled(false);
        }

        if (camera-&gt;service()) {
            ui-&gt;startCameraButton-&gt;setEnabled(true);
        } else {
            ui-&gt;startCameraButton-&gt;setEnabled(false);
            ui-&gt;startCameraButton-&gt;setText(tr(&quot;Camera is not available&quot;));
        }
    }

    void CameraCapture::displayErrorMessage()
    {
        QMessageBox::warning(this, &quot;Capture error&quot;, mediaRecorder-&gt;errorString());
    }

    void CameraCapture::updateCameraDevice(QAction *action)
    {
        setCamera(action-&gt;data().toByteArray());
    }

    void CameraCapture::updateAudioDevice(QAction *action)
    {
        service-&gt;setActiveEndpoint(QMediaService::AudioDevice, action-&gt;data().toString());
    }</pre>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td align="right"><div align="right">Qt Mobility API</div></td>
</tr></table></div></address></body>
</html>
