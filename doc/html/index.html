<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- ./index.qdoc -->
<head>
  <title>Bearer Management Library Developer Resources</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a></td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">Bearer Management Library Developer Resources<br /><span class="subtitle"></span>
</h1>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#the-api-in-details">The API in details</a></li>
<ul><li><a href="#service-networks">Service networks</a></li>
<li><a href="#managing-network-sessions">Managing network sessions</a></li>
<li><a href="#roaming">Roaming</a></li>
<li><a href="#platform-capabilities">Platform capabilities</a></li>
</ul>
<li><a href="#building-and-compiling">Building and compiling</a></li>
<li><a href="#reference-documentation">Reference documentation</a></li>
<ul><li><a href="#main-classes">Main classes</a></li>
</ul>
</ul>
<a name="introduction"></a>
<h2>Introduction</h2>
<p>The Bearer Management API controls the system's connectivity state. This incorporates simple information such as whether the device is online and how many interfaces there are as well as enables the application developer to start, stop network interfaces and influences other connection specific details. Depending on the platform's capabilities it may even provide session management so that a network interface remains up for as long as clients have a registered interest in them while at the same time optimizes the interface's uptime. This API is a key enabler for HTTP level roaming in <a href="http://doc.trolltech.com/doc/qt/qnetworkmanager.html">QNetworkAccessManager</a>.</p>
<p>This API does not provide support for management of network configurations themselves. It is up to the platform to provide infrastructure which enables to user to create, edit or delete network configurations.</p>
<a name="the-api-in-details"></a>
<h2>The API in details</h2>
<p>Computer systems manage their network interfaces via a set of configurations. Each configuration describes a set of parameters which instruct the system how a particular network interface is started. One of the most simplistic examples might be an Ethernet configuration that links a network card to a DHCP server. A more complex example might be a Wireless LAN configuration which may comprise of hardware details such as the WLAN card address, WLAN access point details (e.g ESSID, encryption details) and user specific information (for example username and password). Once the network interface was configured and started according to the configuration blue print, multiple applications are free to use this link layer connection/session for their own socket operations. This API carefully distinguishes a network session and the network connections (represented by socket sessions) which it supports.</p>
<p>The distinction between physical network interfaces, their mappping to multiple configurations, how such a mapping can create an active link layer connection and a network connection that can be created once the session has been established is important to understand the various elements of this API. The Bearer Management API in conjunction with QNetworkInterface follows the same principle. QNetworkInterface already provides the required abstraction for physical network interface. In addition <a href="qnetworkconfiguration.html">QNetworkConfiguration</a> encapsulates a network configuration which can be used to create, destroy and monitor link layer connections (represented by <a href="qnetworksession.html">QNetworkSession</a> object).</p>
<a name="service-networks"></a>
<h3>Service networks</h3>
<p>Some mobile platforms use the concept of grouped access points (also called SNAP or Service Network Access Point). In principle multiple configurations are grouped together and possibly even prioritized when compared to each other. This is useful for use cases where all configurations serve a similar purpose or context. A common context could be that they provide access to the public Internet or possibly only to the office Intranet. By providing a pool of configurations the system can make a decision based on given priorities which usually map to factors such as speed, availability and cost. Furthermore the system can automatically roam from one access point to the next one while ensuring minimal impact on the user experience.</p>
<p>The <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::Type</a> flag specifies to what category a configuration belongs. The <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::InternetAccessPoint</a> type is the most common example. It represents a configuration that can be used to create a session. The above mentioned grouping behavior is provided by <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::ServiceNetwork</a> configurations. Service networks are place holders until such time when the user attempts to <a href="qnetworksession.html#open">open()</a> a new session. At that point in time the system determines which of the configurations <a href="qnetworkconfiguration.html#children">QNetworkConfiguration::children</a>() is best to use. A service network can only have one level of indirection which implies children can only be of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::InternetAccessPoint</a>.</p>
<p>Most systems allow the user to define the systems default configuration. Usually the default behavior is either a service network, a particular internet access point or the user instructs the platform to ask the user once an application requests the network. User interaction is generally implemented by some sort of system dialog which shows up at the appropriate point in time. The application does not have to handle the user input. This API provides the <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>() call which serves a similar purpose. The subsequent code snippet provides a quick way how an application can quickly create a new network session without having to interact with the user:</p>
<pre>    QNetworkConfigurationManager manager;
    const bool canStartIAP = (manager.capabilities() &amp; QNetworkConfigurationManager::BearerManagement);
    QNetworkConfiguration cfg = manager.defaultConfiguration();
    if (!cfg.isValid() || !canStartIAP)
        return;
    switch(cfg.type()) {
        case QNetworkConfiguration::InternetAccessPoint:
            <span class="comment">// no user interaction -&gt; system starts IAP immediately</span>
            break;
        case QNetworkConfiguration::ServiceNetwork:
            <span class="comment">// no user interaction -&gt; system determines best IAP in group and starts it</span>
            break;
        case QNetworkConfiguration::UserChoice:
            <span class="comment">// IAP resolved by asking user as part of QNetworkSession::open()</span>
            break;
    }
    QNetworkSession* session = new QNetworkSession(cfg);
    session-&gt;open();</pre>
<p>To accommodate the &quot;Ask user&quot; use case the default configuration can be of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::UserChoice</a>. A user choice configuration is resolved as part of the <a href="qnetworksession.html#open">QNetworkSession::open</a>() call. Note that a <a href="qnetworkconfiguration.html#Type-enum">UserChoice</a> configuration is only ever returned via <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>() and not <a href="qnetworkconfigurationmanager.html#allConfigurations">QNetworkConfigurationManager::allConfigurations</a>().</p>
<p>On systems which do not maintain a list of <a href="qnetworkconfigurationmanager.html#defaultConfiguration">defaultConfiguration()</a> an invalid configuration is returned. A possible workaround could be to implement a custom dialog which is populated based on what <a href="qnetworkconfigurationmanager.html#allConfigurations">QNetworkConfigurationManager::allConfigurations</a>() returns.</p>
<a name="managing-network-sessions"></a>
<h3>Managing network sessions</h3>
<p>A <a href="qnetworksession.html">QNetworkSession</a> object separates a <a href="qnetworksession.html#state">state()</a> and an <a href="qnetworksession.html#isActive">isActive()</a> condition. The state() attribute enables developers to detect whether the system currently maintains a global network session for the given <a href="qnetworkconfiguration.html">QNetworkConfiguration</a>. If <a href="qnetworksession.html#isActive">isActive()</a> returns true the <a href="qnetworksession.html">QNetworkSession</a> instance at hand was at least one of the entities requesting the global network session. This distinction is required to support the notion of session registrations. For as long as there are one or more active <a href="qnetworksession.html">QNetworkSession</a> instances the underlying network interface is not shut down. Therefore the session <a href="qnetworksession.html#state">state()</a> can be used to monitor the state of network interfaces.</p>
<p>An active session is created by calling <a href="qnetworksession.html#open">QNetworkSession::open</a>() and closed via <a href="qnetworksession.html#close">QNetworkSession::close</a>(), respectively. If the session is <a href="qnetworksession.html#State-enum">disconnected</a> at the time of the <a href="qnetworksession.html#open">open()</a> call the underlying interface is started; otherwise only the reference counter against the global session is incremeted. The opposite behavior can be observed when using <a href="qnetworksession.html#close">close()</a>. In some use cases it may be necessary to turn the interface off despite of active sessions. This can be achieved by calling <a href="qnetworksession.html#stop">stop()</a>. An example use case could be a network manager type of application allowing the user to control the overall state of the devices connectivity.</p>
<p>Global (inter-process) session support is platform dependent and can be detected via <a href="qnetworkconfigurationmanager.html#CapabilityFlag-enum">QNetworkConfigurationManager::SystemSessionSupport</a>. If the system does not support global session calling <a href="qnetworksession.html#close">close()</a> never stops the interface.</p>
<a name="roaming"></a>
<h3>Roaming</h3>
<a name="platform-capabilities"></a>
<h3>Platform capabilities</h3>
<a name="building-and-compiling"></a>
<h2>Building and compiling</h2>
<p>This library requires Qt 4.5 to be installed.</p>
<p>To build the library, run <tt>qmake</tt> and <tt>make</tt>.</p>
<a name="reference-documentation"></a>
<h2>Reference documentation</h2>
<a name="main-classes"></a>
<h3>Main classes</h3>
<ul>
<li><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></li>
<li><a href="qnetworkconfigurationmanager.html">QNetworkConfigurationManager</a></li>
<li><a href="qnetworksession.html">QNetworkSession</a></li>
</ul>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td align="right"><div align="right">Bearer management API</div></td>
</tr></table></div></address></body>
</html>
