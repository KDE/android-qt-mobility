<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- ./index.qdoc -->
<head>
  <title>Qt Mobility Developer Resources</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><img src="images/qtlogo.png" align="left" border="0" /></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a></td>
<td align="right" valign="top" width="230"><img src="images/codeless.png"  border="0" /></td></tr></table><h1 class="title">Qt Mobility Developer Resources<br /><span class="subtitle"></span>
</h1>
<ul><li><a href="#qt-service-framework">Qt Service Framework</a></li>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#using-the-framework">Using the framework</a></li>
<ul><li><a href="#verbose-lookup">Verbose lookup</a></li>
<li><a href="#default-lookup">Default lookup</a></li>
<li><a href="#header-lookup">Header lookup</a></li>
</ul>
<li><a href="#service-scope">Service scope</a></li>
<ul><li><a href="#user-scope">User scope</a></li>
<li><a href="#system-scope">System scope</a></li>
</ul>
<li><a href="#adding-and-removing-of-services">Adding and removing of services</a></li>
<ul><li><a href="#xml-format">XML format</a></li>
</ul>
<li><a href="#tools-for-xml-generation">Tools for XML generation</a></li>
<li><a href="#installing-the-service-at-runtime">Installing the service at runtime</a></li>
<li><a href="#identifying-services">Identifying services</a></li>
<li><a href="#upgrading-services">Upgrading services</a></li>
</ul>
<li><a href="#bearer-management">Bearer Management</a></li>
<ul><li><a href="#the-api-in-details">The API in details</a></li>
<ul><li><a href="#service-networks">Service networks</a></li>
<li><a href="#managing-network-sessions">Managing network sessions</a></li>
<li><a href="#roaming">Roaming</a></li>
<li><a href="#platform-capabilities">Platform capabilities</a></li>
</ul>
</ul>
<li><a href="#location">Location</a></li>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#requesting-location-data-from-data-sources">Requesting location data from data sources</a></li>
<ul><li><a href="#controlling-aspects-of-data-sources">Controlling aspects of data sources</a></li>
<li><a href="#reading-nmea-data">Reading NMEA data</a></li>
</ul>
<li><a href="#creating-a-custom-location-data-source">Creating a custom location data source</a></li>
</ul>
<li><a href="#building-and-compiling">Building and compiling</a></li>
<li><a href="#reference-documentation">Reference documentation</a></li>
<ul><li><a href="#main-classes">Main classes</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</ul>
<a name="qt-service-framework"></a>
<h2>Qt Service Framework</h2>
<a name="introduction"></a>
<h3>Introduction</h3>
<p>The Qt Service framework provides a set of APIs that allows clients to discover and instantiate arbitrary services. This is achieved by defining a unified way of finding, implementing and accessing services across multiple platforms. Due to the service frameworks knowledge of service interfaces, their versions and <a href="http://qt.nokia.com/doc/4.5/qobject.html">QObject</a>-based introspection it may even be used to unify and access multiple platform specific service implementations via the same Qt-based client application.</p>
<a name="overview"></a>
<h3>Overview</h3>
<p>A service is an independent component that allows a client to perform a well-defined operation. Clients can find services based on their name and version as well as the interface that is implemented by the service object. Once the service has been identified the framework starts the service and returns a pointer to it. <a href="qservicemanager.html">QServiceManager</a> is the main interface through which clients can access the mentioned framework functionality. In addition services themselves may also act as clients to the service framework by requesting other services installed on the system.</p>
<p>Service provider are implemented via plug-ins. <a href="qserviceplugininterface.html">QServicePluginInterface</a> defines the main interface for each plug-in. In order to avoid that clients have to link against service specific libraries each service object must be derived from <a href="http://qt.nokia.com/doc/4.5/qobject.html">QObject</a>. Therefore the <a href="http://qt.nokia.com/doc/4.5/qmetaobject.html">QMetaObject</a> system can be used to dynamically discover and invoke the service's capabilities. To achieve the best level of access via the Qt meta object system services should be implemented in such a way that their entire functionality is accessable via the signals, slots, properties or invokable functions (see <a href="http://qt.nokia.com/doc/4.5/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a> macro for more details).</p>
<p>Each service plug-in implements one service only but can provide multiple implementations for multiple interfaces. Therefore a service (plug-in) can retain a certain level of backwards compatibility even if the main service interface breaks in such a way that a new interface name has to be used. Existing clients can still use the previous version of service interface whereas new clients can utilize the new interface.</p>
<p>Future versions of this framework may also enable access to out-of-process service provider.</p>
<a name="using-the-framework"></a>
<h3>Using the framework</h3>
<p>This section assumes that the user wants to access the <i>FileManager</i> service which offers an implementation for the <i>com.nokia.qt.examples.FileStorage</i> interface The service framework enables multiple ways of accessing those implementations.</p>
<p><a href="qservicemanager.html">QServiceManager</a> is the main class to lookup and instantiate services. Services can be found by constraining the search via service meta data or by using the default lookup mechanism.</p>
<a name="verbose-lookup"></a>
<h4>Verbose lookup</h4>
<p>The client code has precise knowledge of the service and its interfaces.</p>
<pre>    QServiceManager manager;
    QServiceFilter filter(&quot;com.nokia.qt.examples.FileStorage&quot;);
    filter.setServiceName(&quot;FileManager&quot;);

<span class="comment">    // find services complying with filter</span>
    QList&lt;QServiceInterfaceDescriptor&gt; foundServices
    foundServices = manager.findInterfaces(filter);
    Q_ASSERT(foundServices.count());

<span class="comment">    // instantiate the FileStorage object</span>
    QObject *fileStorage;
    fileStorage = manager.loadInterface(foundServices.at(0));</pre>
<a name="default-lookup"></a>
<h4>Default lookup</h4>
<p>The client code has knowledge of the interface and doesn't really care about the service that implements the interface. In such cases the default service lookup can be utilized to create a service object instance. If the same service provides multiple versions of the same interface the latest version is returned. Therefore subsequent versions of the same interface must always be binary compatible to previous versions.</p>
<pre>    QServiceManager manager;
    QObject *storage;
    storage = manager.loadInterface(&quot;com.nokia.qt.examples.FileStorage&quot;);</pre>
<a name="header-lookup"></a>
<h4>Header lookup</h4>
<p>So far all lookup mechanism returned a <a href="http://qt.nokia.com/doc/4.5/qobject.html">QObject</a> pointer. This pointer can be utilised by introspecting the object using Qt's meta object system. Therefore the client does not have to have any knowledge of the object header or symbols. However in some use cases it may be more convenient to directly interact with the service object by including the service header and/or linking against the service provider. The subsequent code snippet demonstrates how this may look like:</p>
<pre>    #include &lt;filestorage.h&gt;
    ...
    QServiceManager manager;
    FileStorage *storage = 0;
    ...
    manager.setInterfaceDefault(&quot;FileManager&quot;, &quot;com.nokia.qt.examples.FileStorage&quot;);
    storage = manager.getInterface&lt;FileStorage&gt;(&quot;com.nokia.qt.examples.FileStorage&quot;);</pre>
<a name="service-scope"></a>
<h3>Service scope</h3>
<p>The <a href="qservicemanager.html">QServiceManager</a> operates in either <a href="qservicemanager.html#Scope-enum">User scope</a> or <a href="qservicemanager.html#Scope-enum">System scope</a>. By default, it operates in user scope. The choice of scope affects whether registered services are available system-wide or only to the current user, and whether service and interface lookups are limited to system-wide service or whether the current user's together with system service configurations are considered.</p>
<a name="user-scope"></a>
<h4>User scope</h4>
<p>In user scope, services are registered in a storage location specific to the current user. When a default service is set for an interface using <a href="qservicemanager.html#setInterfaceDefault">setInterfaceDefault()</a>, the referenced service can be either a user-specific or system-wide service.</p>
<p>For service and interface lookups, a manager will first search the user-specific services; if the requested component is not found, the manager then searches the system-wide services, if the user has sufficient permissions to do so.</p>
<p>The <a href="qservicemanager.html#serviceAdded">QServiceManager::serviceAdded</a>() and <a href="qservicemanager.html#serviceRemoved">QServiceManager::serviceRemoved</a>() notifications are emitted when services are added or removed from either the user-specific or system-wide services. These signals have a <tt>scope</tt> parameter to indicate the scope in which the service was added or removed. (Note the system-wide service notifications are only available if the user has sufficient permissions to access the system-wide service storage.)</p>
<a name="system-scope"></a>
<h4>System scope</h4>
<p>In system scope, services are registered in a system-wide storage location. The manager does not access user-specific services for any operations. Service and interface lookups fail if the requested services are not found in the system-wide service storage. Service registration is performed in the system-wide storage.</p>
<p>If <a href="qservicemanager.html#setInterfaceDefault">setInterfaceDefault()</a> is called for a user-specific service, the operation fails.</p>
<p>Also, the <a href="qservicemanager.html#serviceAdded">QServiceManager::serviceAdded</a>() and <a href="qservicemanager.html#serviceRemoved">QServiceManager::serviceRemoved</a>() notifications are only emitted for system-wide services.</p>
<a name="adding-and-removing-of-services"></a>
<h3>Adding and removing of services</h3>
<p>New services can be installed and removed at runtime. An XML file is used to describe the service meta data and links the service code to its meta description.</p>
<a name="xml-format"></a>
<h4>XML format</h4>
<p>Services are installed via an XML file which describes the meta data and location of the service. The xml file can be described via the following DTD:</p>
<pre>        &lt;!ELEMENT service ( name, filepath, description?, interface+ ) &gt;
        &lt;!ELEMENT description ( #CDATA ) &gt;
        &lt;!ELEMENT filepath ( #PCDATA ) &gt;
        &lt;!ELEMENT interface ( name, version, description?, capabilities?, customproperty* ) &gt;
        &lt;!ELEMENT capabilities ( #PCDATA ) &gt;
        &lt;!ELEMENT name ( #PCDATA ) &gt;
        &lt;!ELEMENT version ( #PCDATA ) &gt;
        &lt;!ELEMENT customproperty ( #CDATA ) &gt;
        &lt;!ATTLIST customproperty key NMTOKEN #REQUIRED &gt;</pre>
<p>The elements and attributes have the following meanings:</p>
<p><table class="generic" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Element</th><th>SubElement</th><th>Description</th></tr></thead>
<tr valign="top" class="odd"><td>service</td><td></td><td>The <i>service</i> tag can contain an arbitrary number of <i>interface</i> tags and one description tag.</td></tr>
<tr valign="top" class="even"><td>&quot;</td><td>description</td><td>A user readable description of the purpose of the service.</td></tr>
<tr valign="top" class="odd"><td>&quot;</td><td>filepath</td><td>The absolute path and name of the plug-in to be loaded when this service is requested. Alternatively if the plug-in name only is provided the standard library paths (see <a href="http://qt.nokia.com/doc/4.5/qcoreapplication.html#libraryPaths">QCoreApplication::libraryPaths</a>()) are used to find the plug-in. Note that if the plugin name is given only, platform specific parts such as the suffix &quot;.dll&quot; and &quot;.so&quot; or plugin prefix &quot;lib&quot; should be removed to enable cross platform resolution. <a href="http://qt.nokia.com/doc/4.5/qlibrary.html">QLibrary</a> is used to determine the platform specific parts of the plugin.</td></tr>
<tr valign="top" class="even"><td>&quot;</td><td>name</td><td>The name of the service.</td></tr>
<tr valign="top" class="odd"><td>interface</td><td></td><td>The <i>interface</i> describes the properties of the interface.</td></tr>
<tr valign="top" class="even"><td>&quot;</td><td>capabilities</td><td>This property is a list of arbitrary strings which are interpreted as permissions/capabilities. This list can be empty.</td></tr>
<tr valign="top" class="odd"><td>&quot;</td><td>name</td><td>The name of the interface using the Java class name notation. (e.g&#x2e; com.nokia.qt.TestService)</td></tr>
<tr valign="top" class="even"><td>&quot;</td><td>version</td><td>This property contains the interface and implementation version. The version tag follows the <i>major.minor</i> notation. The major version indicates the interface version the minor version the implementation version.<p>The version number <b>must</b> be greater than 1.0&#x2e; The version cannot be less than 1.0 because the Service Framework is dependent on the fact that services must be binary compatible between major versions, and services with versions less than 1.0 are unlikely to be binary compatible with later versions.</p>
</td></tr>
<tr valign="top" class="odd"><td>&quot;</td><td>description</td><td>A user readable description of the purpose of the interface.</td></tr>
<tr valign="top" class="even"><td>&quot;</td><td>customproperty</td><td>An implementation specific key value pair which can be used for filtering or as description.</td></tr>
</table></p>
<p>An example for a valid XML service description could be the following <i>TestService</i>:</p>
<pre>        &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
        &lt;service&gt;
            &lt;name&gt;TestService&lt;/name&gt;
            &lt;filepath&gt;testserviceplugin&lt;/filepath&gt;
            &lt;description&gt;Test service description&lt;/description&gt;
            &lt;interface&gt;
                &lt;name&gt;com.nokia.qt.ILocation&lt;/name&gt;
                &lt;version&gt;1.4&lt;/version&gt;
                &lt;capabilities&gt;&lt;/capabilities&gt;
                &lt;description&gt;Interface that provides location support&lt;/description&gt;
            &lt;/interface&gt;
            &lt;interface&gt;
                &lt;name&gt;com.nokia.qt.ILocation&lt;/name&gt;
                &lt;version&gt;1.5&lt;/version&gt;
                &lt;capabilities&gt;&lt;/capabilities&gt;
                &lt;description&gt;Interface that provides location support&lt;/description&gt;
            &lt;/interface&gt;
            &lt;interface&gt;
                &lt;name&gt;com.nokia.qt.ISysInfo&lt;/name&gt;
                &lt;capabilities&gt;ReadUserData&lt;/capabilities&gt;
                &lt;version&gt;2.3&lt;/version&gt;
                &lt;description&gt;Interface that provides system information support&lt;/description&gt;
                &lt;customproperty key=&quot;key1&quot;&gt;value1&lt;/customproperty&gt;
                &lt;customproperty key=&quot;key2&quot;&gt;value2&lt;/customproperty&gt;
            &lt;/interface&gt;
        &lt;/service&gt;</pre>
<a name="tools-for-xml-generation"></a>
<h3>Tools for XML generation</h3>
<p>The framework includes a GUI tool under <tt>tools/servicexmlgen</tt> for generating and inspecting service XML files. This makes it easy to enter service metadata and interface details and generate the appropriate XML to describe the service. It can also be used to load and inspect existing service XML files.</p>
<p>Here is a screenshot of the application, loaded with the <i>TestService</i> XML description provided above.</p>
<p align="center"><img src="images/servicexmlgen.png" /></p><a name="installing-the-service-at-runtime"></a>
<h3>Installing the service at runtime</h3>
<p>New services can be added and removed at any time via <a href="qservicemanager.html#addService">QServiceManager::addService</a>() and <a href="qservicemanager.html#removeService">QServiceManager::removeService</a>().</p>
<a name="identifying-services"></a>
<h3>Identifying services</h3>
<p>Each implementation is identified by a service name, an interface name and its version. This information is encapsulated by <a href="qserviceinterfacedescriptor.html">QServiceInterfaceDescriptor</a> which can be used to request references to service objects.</p>
<p><a href="qservicefilter.html">QServiceFilter</a> simplifies the lookup of already installed services. Developers specifies the criteria used during the meta data lookup. The subsequent example demonstrates the interaction between <a href="qserviceinterfacedescriptor.html">QServiceInterfaceDescriptor</a> and <a href="qservicefilter.html">QServiceFilter</a> by creating references to all services that implement the interface <i>com.nokia.qt.ILocation</i>:</p>
<pre>        QServiceManager mgr;
        QServiceFilter filter;
        filter.setInterfaceName(&quot;com.nokia.qt.ILocation&quot;);
        QList&lt;QServiceInterfaceDescriptor&gt; list = mgr.findInterfaces(filter);
        for(int i = 0; i &lt; list.size(); i++) {
            QObject *serviceObject;
            serviceObject = mgr.loadInterface(list[i]);

            <span class="comment">// returned object owned by client</span>
            if (serviceObject)
                serviceObject-&gt;setParent(this);
        }</pre>
<a name="upgrading-services"></a>
<h3>Upgrading services</h3>
<p>There are two ways in which to upgrade a service. The first is an incremental approach whereby <a href="qservicemanager.html#addService">QServiceManager::addService</a>() is used to register an XML descriptor whose service name already exists but defines new interface implementations. For example an already existing service, &quot;ovi&quot; may define version 1.0 of interface,&quot;IDownload&quot;. <a href="qservicemanager.html#addService">QServiceManager::addService</a>() is then called with an XML descriptor that declares itself as belonging the &quot;ovi&quot; service, but implements version 1.1 of the interface &quot;IDownload&quot;. Both implementation versions will be available for use.</p>
<p>The second method is a replacement approach whereby an existing service is completely removed and replaced by a new service. As an example the already existing &quot;ovi&quot; service may implement interface &quot;IDownload&quot; version 1.0, the new &quot;ovi&quot; service may implement &quot;IDownload&quot; version 1.0 and version 1.1&#x2e; In this case the old service implementation must be first be removed using <a href="qservicemanager.html#removeService">QServiceManager::removeService</a>() to make way for the new service implementation.</p>
<a name="bearer-management"></a>
<h2>Bearer Management</h2>
<p>The Bearer Management API controls the system's connectivity state. This incorporates simple information such as whether the device is online and how many interfaces there are as well as enables the application developer to start, stop network interfaces and influences other connection specific details. Depending on the platform's capabilities it may even provide session management so that a network interface remains up for as long as clients have a registered interest in them while at the same time optimizes the interface's uptime. This API is a key enabler for HTTP level roaming in <a href="http://doc.trolltech.com/doc/qt/qnetworkmanager.html">QNetworkAccessManager</a>.</p>
<p>This API does not provide support for management of network configurations themselves. It is up to the platform to provide infrastructure which enables to user to create, edit or delete network configurations.</p>
<a name="the-api-in-details"></a>
<h3>The API in details</h3>
<p>Computer systems manage their network interfaces via a set of configurations. Each configuration describes a set of parameters which instruct the system how a particular network interface is started. One of the most simplistic examples might be an Ethernet configuration that links a network card to a DHCP server. A more complex example might be a Wireless LAN configuration which may comprise of hardware details such as the WLAN card address, WLAN access point details (e.g ESSID, encryption details) and user specific information (for example username and password). Once the network interface was configured and started according to the configuration blue print, multiple applications are free to use this link layer connection/session for their own socket operations. This API carefully distinguishes a network session and the network connections (represented by socket sessions) which it supports.</p>
<p>The distinction between physical network interfaces, their mappping to multiple configurations, how such a mapping can create an active link layer connection and a network connection that can be created once the session has been established is important to understand the various elements of this API. The Bearer Management API in conjunction with <a href="http://qt.nokia.com/doc/4.5/qnetworkinterface.html">QNetworkInterface</a> follows the same principle. <a href="http://qt.nokia.com/doc/4.5/qnetworkinterface.html">QNetworkInterface</a> already provides the required abstraction for physical network interface. In addition <a href="qnetworkconfiguration.html">QNetworkConfiguration</a> encapsulates a network configuration which can be used to create, destroy and monitor link layer connections (represented by <a href="qnetworksession.html">QNetworkSession</a> object).</p>
<a name="service-networks"></a>
<h4>Service networks</h4>
<p>Some mobile platforms use the concept of grouped access points (also called SNAP or Service Network Access Point). In principle multiple configurations are grouped together and possibly even prioritized when compared to each other. This is useful for use cases where all configurations serve a similar purpose or context. A common context could be that they provide access to the public Internet or possibly only to the office Intranet. By providing a pool of configurations the system can make a decision based on given priorities which usually map to factors such as speed, availability and cost. Furthermore the system can automatically roam from one access point to the next one while ensuring minimal impact on the user experience.</p>
<p>The <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::Type</a> flag specifies to what category a configuration belongs. The <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::InternetAccessPoint</a> type is the most common example. It represents a configuration that can be used to create a session. The above mentioned grouping behavior is provided by <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::ServiceNetwork</a> configurations. Service networks are place holders until such time when the user attempts to <a href="qnetworksession.html#open">open()</a> a new session. At that point in time the system determines which of the configurations <a href="qnetworkconfiguration.html#children">QNetworkConfiguration::children</a>() is best to use. A service network can only have one level of indirection which implies children can only be of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::InternetAccessPoint</a>.</p>
<p>Most systems allow the user to define the systems default configuration. Usually the default behavior is either a service network, a particular internet access point or the user instructs the platform to ask the user once an application requests the network. User interaction is generally implemented by some sort of system dialog which shows up at the appropriate point in time. The application does not have to handle the user input. This API provides the <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>() call which serves a similar purpose. The subsequent code snippet provides a quick way how an application can quickly create a new network session without having to interact with the user:</p>
<pre>        QNetworkConfigurationManager manager;
        const bool canStartIAP = (manager.capabilities() &amp; QNetworkConfigurationManager::BearerManagement);
        QNetworkConfiguration cfg = manager.defaultConfiguration();
        if (!cfg.isValid() || !canStartIAP)
            return;
        switch(cfg.type()) {
            case QNetworkConfiguration::InternetAccessPoint:
                <span class="comment">// no user interaction -&gt; system starts IAP immediately</span>
                break;
            case QNetworkConfiguration::ServiceNetwork:
                <span class="comment">// no user interaction -&gt; system determines best IAP in group and starts it</span>
                break;
            case QNetworkConfiguration::UserChoice:
                <span class="comment">// IAP resolved by asking user as part of QNetworkSession::open()</span>
                break;
        }
        QNetworkSession* session = new QNetworkSession(cfg);
        session-&gt;open();</pre>
<p>To accommodate the &quot;Ask user&quot; use case the default configuration can be of type <a href="qnetworkconfiguration.html#Type-enum">QNetworkConfiguration::UserChoice</a>. A user choice configuration is resolved as part of the <a href="qnetworksession.html#open">QNetworkSession::open</a>() call. Note that a <a href="qnetworkconfiguration.html#Type-enum">UserChoice</a> configuration is only ever returned via <a href="qnetworkconfigurationmanager.html#defaultConfiguration">QNetworkConfigurationManager::defaultConfiguration</a>() and not <a href="qnetworkconfigurationmanager.html#allConfigurations">QNetworkConfigurationManager::allConfigurations</a>().</p>
<p>On systems which do not maintain a list of <a href="qnetworkconfigurationmanager.html#defaultConfiguration">defaultConfiguration()</a> an invalid configuration is returned. A possible workaround could be to implement a custom dialog which is populated based on what <a href="qnetworkconfigurationmanager.html#allConfigurations">QNetworkConfigurationManager::allConfigurations</a>() returns.</p>
<a name="managing-network-sessions"></a>
<h4>Managing network sessions</h4>
<p>A <a href="qnetworksession.html">QNetworkSession</a> object separates a <a href="qnetworksession.html#state">state()</a> and an <a href="qnetworksession.html#isActive">isActive()</a> condition. The state() attribute enables developers to detect whether the system currently maintains a global network session for the given <a href="qnetworkconfiguration.html">QNetworkConfiguration</a>. If <a href="qnetworksession.html#isActive">isActive()</a> returns true the <a href="qnetworksession.html">QNetworkSession</a> instance at hand was at least one of the entities requesting the global network session. This distinction is required to support the notion of session registrations. For as long as there are one or more active <a href="qnetworksession.html">QNetworkSession</a> instances the underlying network interface is not shut down. Therefore the session <a href="qnetworksession.html#state">state()</a> can be used to monitor the state of network interfaces.</p>
<p>An active session is created by calling <a href="qnetworksession.html#open">QNetworkSession::open</a>() and closed via <a href="qnetworksession.html#close">QNetworkSession::close</a>(), respectively. If the session is <a href="qnetworksession.html#State-enum">disconnected</a> at the time of the <a href="qnetworksession.html#open">open()</a> call the underlying interface is started; otherwise only the reference counter against the global session is incremeted. The opposite behavior can be observed when using <a href="qnetworksession.html#close">close()</a>. In some use cases it may be necessary to turn the interface off despite of active sessions. This can be achieved by calling <a href="qnetworksession.html#stop">stop()</a>. An example use case could be a network manager type of application allowing the user to control the overall state of the devices connectivity.</p>
<p>Global (inter-process) session support is platform dependent and can be detected via <a href="qnetworkconfigurationmanager.html#CapabilityFlag-enum">QNetworkConfigurationManager::SystemSessionSupport</a>. If the system does not support global session calling <a href="qnetworksession.html#close">close()</a> never stops the interface.</p>
<a name="roaming"></a>
<h4>Roaming</h4>
<a name="platform-capabilities"></a>
<h4>Platform capabilities</h4>
<p>Some API features are not available on all platforms. The <a href="qnetworkconfigurationmanager.html#CapabilityFlag-enum">QNetworkConfigurationManager::CapabilityFlag</a> should be used to detect platform features at runtime. The following table lists the various platform API's being used by this API. This may assist in the process of determining the feature support:</p>
<p><table class="generic" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Platform</th><th>Backend capabilities</th></tr></thead>
<tr valign="top" class="odd"><td>Linux&#xae;</td><td>Linux uses the <a href="http://projects.gnome.org/NetworkManager">NetworkManager API</a> which supports interface notifications and starting and stopping of network interfaces.</td></tr>
<tr valign="top" class="even"><td>Windows&#xae; XP</td><td>This platform supports interface notifications without active polling.</td></tr>
<tr valign="top" class="odd"><td>Windows XP SP2+Hotfixes, Windows XP SP3, Windows Vista, Windows 7</td><td>In addition to standard Windows XP wifi access point monitoring has been improved which includes the ability to start and stop wifi interfaces. This requires Windows to manage the wifi interfaces.</td></tr>
<tr valign="top" class="even"><td>Symbian&#xae; Platform &amp; S60 3.1</td><td>Symbian support is based on Symbian platforms RConnection. In addition to interface notifications, starting and stopping of network it provides system wide session support and direct connection routing.</td></tr>
<tr valign="top" class="odd"><td>Symbian Platform &amp; S60 3.2+</td><td>This platform enjoys the most comprehensive feature set. In addition to the features support by the S60 3.1 Network roaming is supported.</td></tr>
<tr valign="top" class="even"><td>All other platforms (*nix, Mac OS&#xae;, Windows Mobile)</td><td>This backend is the fallback for all platforms supports network interface notifications via active polling only.</td></tr>
</table></p>
<a name="location"></a>
<h2>Location</h2>
<a name="introduction"></a>
<h3>Introduction</h3>
<p>The Location API provides a library for distributing and receiving location data using arbitrary data sources.</p>
<p>Location data involves a precisely specified position on the Earth's surface &#x2014; as provided by a latitude-longitude coordinate &#x2014; along with associated data, such as:</p>
<ul>
<li>The date and time at which the position was reported</li>
<li>The velocity of the device that reported the position</li>
<li>The altitude of the reported position (height above sea level)</li>
<li>The bearing of the device in degrees, relative to true north</li>
</ul>
<p>This data can be extracted through a variety of methods. One of the most well known methods of positioning is GPS (Global Positioning System), a publicly available system that uses radiowave signals received from Earth-orbiting satellites to calculate the precise position and time of the receiver. Another popular method is Cell ID positioning, which uses the cell ID of the cell site that is currently serving the receiving device to calculate its approximate location. These and other positioning methods can all be used with the Location API; the only requirement for a location data source within the API is that it provides a latitude-longitude coordinate with a date/time value, with the option of providing the other attributes listed above.</p>
<p>Location data sources are created by subclassing <a href="qgeopositioninfosource.html">QGeoPositionInfoSource</a> and providing <a href="qgeopositioninfo.html">QGeoPositionInfo</a> objects through the <a href="qgeopositioninfosource.html#positionUpdated">QGeoPositionInfoSource::positionUpdated</a>() signal. Clients that require location data can connect to the <a href="qgeopositioninfosource.html#positionUpdated">positionUpdated()</a> signal and call <a href="qgeopositioninfosource.html#startUpdates">startUpdates()</a> or <a href="qgeopositioninfosource.html#requestUpdate">requestUpdate()</a> to trigger the distribution of location data.</p>
<p>A default position source may be available on some platforms. Call <a href="qgeopositioninfosource.html#createSource">QGeoPositionInfoSource::createSource</a>() to create an instance of the default position source; the method returns 0 if no default source is available for the platform.</p>
<p>The <a href="qgeoareamonitor.html">QGeoAreaMonitor</a> class enables client applications to be notified when the receiving device has moved in or out of a particular area, as specified by a coordinate and radius. If the platform provides built-in support for area monitoring, <a href="qgeoareamonitor.html#createMonitor">QGeoAreaMonitor::createMonitor</a>() returns an instance of the default area monitor.</p>
<p>Satellite information can also be distributed through the <a href="qsatelliteinfosource.html">QSatelliteInfoSource</a> class. Call <a href="qsatelliteinfosource.html#createSource">QSatelliteInfoSource::createSource</a>() to create an instance of the default satellite data source for the platform, if one is available. Alternatively, clients can subclass it to provide a custom satellite data source.</p>
<a name="requesting-location-data-from-data-sources"></a>
<h3>Requesting location data from data sources</h3>
<p>To receive data from a source, connect to its <a href="qgeopositioninfosource.html#positionUpdated">positionUpdated()</a> signal, then call either <a href="qgeopositioninfosource.html#startUpdates">startUpdates()</a> or <a href="qgeopositioninfosource.html#requestUpdate">requestUpdate()</a> to begin.</p>
<p>Here is an example of a client that receives data from the default location data source, as returned by <a href="qgeopositioninfosource.html#createSource">QGeoPositionInfoSource::createSource</a>():</p>
<pre>    class MyClass : public QObject
    {
        Q_OBJECT
    public:
        MyClass(QObject *parent = 0)
            : QObject(parent)
        {
            QGeoPositionInfoSource *source = QGeoPositionInfoSource::createSource();
            if (source) {
                connect(source, SIGNAL(positionUpdated(QGeoPositionInfo)),
                        this, SLOT(positionUpdated(QGeoPositionInfo)));
                source-&gt;startUpdates();
            }
        }

    private slots:
        void positionUpdated(const QGeoPositionInfo &amp;info)
        {
            qDebug() &lt;&lt; &quot;Position updated:&quot; &lt;&lt; info;
        }
    };</pre>
<a name="controlling-aspects-of-data-sources"></a>
<h4>Controlling aspects of data sources</h4>
<p>The <a href="qgeopositioninfosource.html#setUpdateInterval">QGeoPositionInfoSource::setUpdateInterval</a>() method can be used to control the rate at which position updates are received. For example, if the client application only requires updates once every 30 seconds, it can call <tt>setUpdateInterval(30000)</tt>. (If no update interval is set, or setUpdateInterval() is called with a value of 0, the source uses a default interval or some other internal logic to determine when updates should be provided.)</p>
<p><a href="qgeopositioninfosource.html#setPreferredPositioningMethods">QGeoPositionInfoSource::setPreferredPositioningMethods</a>() enables client applications to request that a certain type of positioning method be used. For example, if the application prefers to use only satellite positioning, which offers fairly precise outdoor positioning but can be a heavy user of power resources, it can call this method with the <a href="qgeopositioninfosource.html#PositioningMethod-enum">QGeoPositionInfoSource::SatellitePositioningMethods</a> value. However, this method should only be used in specialized client applications; in most cases, the default positioning methods should not be changed, as a source may internally use a variety of positioning methods that can be useful to the application.</p>
<a name="reading-nmea-data"></a>
<h4>Reading NMEA data</h4>
<p><a href="http://en.wikipedia.org/wiki/NMEA_0183">NMEA</a> is a common text-based protocol for specifying navigational data. For convenience, the <a href="qnmeapositioninfosource.html">QNmeaPositionInfoSource</a> is provided to enable client applications to read and distribute NMEA data in either real-time mode (for example, when streaming from a GPS device) or simulation mode (for example, when reading from a NMEA log file). In simulation mode, the source will emit updates according to the time stamp of each NMEA sentence to produce a &quot;replay&quot; of the recorded data.</p>
<a name="creating-a-custom-location-data-source"></a>
<h3>Creating a custom location data source</h3>
<p>Generally, the capabilities provided by the default position source as returned by <a href="qgeopositioninfosource.html#createSource">QGeoPositionInfoSource::createSource</a>(), along with the <a href="qnmeapositioninfosource.html">QNmeaPositionInfoSource</a> class, are sufficient for retrieving location data. However, in some cases developers may wish to write their own custom location data sources.</p>
<p>The <tt>LogFilePositionSource</tt> class in <tt>examples/logfilepositionsource</tt> shows how to subclass <a href="qgeopositioninfosource.html">QGeoPositionInfoSource</a> to create a custom location data source.</p>
<p>This example class reads location data from a text file, <i>log.txt</i>. The file specifies location data using a simple text format: it contains one location update per line, where each line contains a date/time, a latitude and a longitude, separated by spaces. The date/time is in ISO 8601 format and the latitude and longitude are in degrees decimal format. Here is an excerpt from <i>log.txt</i>:</p>
<pre>        2009-08-24T22:25:01 -27.576082 153.092415
        2009-08-24T22:25:02 -27.576223 153.092530
        2009-08-24T22:25:03 -27.576364 153.092648</pre>
<p>The class reads this data and distributes it via the <a href="qgeopositioninfosource.html#positionUpdated">positionUpdated()</a> signal.</p>
<p>Here is the definition of the <tt>LogFilePositionSource</tt> class:</p>
<pre>    class LogFilePositionSource : public QGeoPositionInfoSource
    {
        Q_OBJECT
    public:
        LogFilePositionSource(QObject *parent = 0);

        QGeoPositionInfo lastKnownPosition(bool fromSatellitePositioningMethodsOnly = false) const;

        PositioningMethods supportedPositioningMethods() const;
        int minimumUpdateInterval() const;

    public slots:
        virtual void startUpdates();
        virtual void stopUpdates();

        virtual void requestUpdate(int timeout = 5000);

    private slots:
        void readNextPosition();

    private:
        QFile *logFile;
        QTimer *timer;
        QGeoPositionInfo lastPosition;
    };</pre>
<p>The main methods overrided by the subclass are:</p>
<ul>
<li><a href="qgeopositioninfosource.html#startUpdates">startUpdates()</a>: called by client applications to start regular position updates</li>
<li><a href="qgeopositioninfosource.html#stopUpdates">stopUpdates()</a>: called by client applications to stop regular position updates</li>
<li><a href="qgeopositioninfosource.html#requestUpdate">requestUpdate()</a>: called by client applications to request a single update, with a specified timeout</li>
</ul>
<p>When a position update is available, the subclass emits the <a href="qgeopositioninfosource.html#positionUpdated">positionUpdated()</a> signal.</p>
<p>Here are the key methods in the class implementation:</p>
<pre>    LogFilePositionSource::LogFilePositionSource(QObject *parent)
        : QGeoPositionInfoSource(parent),
          logFile(new QFile(this)),
          timer(new QTimer(this))
    {
        connect(timer, SIGNAL(timeout()), this, SLOT(readNextPosition()));

        logFile-&gt;setFileName(QCoreApplication::applicationDirPath()
                + QDir::separator() + &quot;simplelog.txt&quot;);
        if (!logFile-&gt;open(QIODevice::ReadOnly))
            qWarning() &lt;&lt; &quot;Error: cannot open source file&quot; &lt;&lt; logFile-&gt;fileName();
    }

    void LogFilePositionSource::startUpdates()
    {
        int interval = updateInterval();
        if (interval &lt; minimumUpdateInterval())
            interval = minimumUpdateInterval();

        timer-&gt;start(interval);
    }

    void LogFilePositionSource::stopUpdates()
    {
        timer-&gt;stop();
    }

    void LogFilePositionSource::requestUpdate(int <span class="comment">/*timeout*/</span>)
    {
        <span class="comment">// For simplicity, ignore timeout - assume that if data is not available</span>
        <span class="comment">// now, no data will be added to the file later</span>
        if (logFile-&gt;canReadLine())
            readNextPosition();
        else
            emit requestTimeout();
    }

    void LogFilePositionSource::readNextPosition()
    {
        QByteArray line = logFile-&gt;readLine().trimmed();
        if (!line.isEmpty()) {
            QList&lt;QByteArray&gt; data = line.split(' ');
            double latitude;
            double longitude;
            bool hasLatitude = false;
            bool hasLongitude = false;
            QDateTime dateTime = QDateTime::fromString(QString(data.value(0)), Qt::ISODate);
            latitude = data.value(1).toDouble(&amp;hasLatitude);
            longitude = data.value(2).toDouble(&amp;hasLongitude);

            if (hasLatitude &amp;&amp; hasLongitude &amp;&amp; dateTime.isValid()) {
                QGeoCoordinate coordinate(latitude, longitude);
                QGeoPositionInfo info(coordinate, dateTime);
                if (info.isValid()) {
                    lastPosition = info;
                    emit positionUpdated(info);
                }
            }
        }
    }</pre>
<p>The example includes a <tt>ClientApplication</tt> class that requests updates from the <tt>LogFilePositionSource</tt> class. Run the exaple to see the data that is received by <tt>ClientApplication</tt>.</p>
<p>Before running the example, make sure you have done both <tt>make</tt> and <tt>make install</tt>.</p>
<a name="building-and-compiling"></a>
<h2>Building and compiling</h2>
<p>This library requires Qt 4.5 to be installed.</p>
<p>To build the library, run <tt>qmake</tt> and <tt>make</tt>.</p>
<p>Linux supports a NetworkManager based backend and generic backend using <a href="http://qt.nokia.com/doc/4.5/qnetworkinterface.html">QNetworkInterface</a> only. By default the generic backend is selected. If the NetworkManager backend is required run qmake as follows:</p>
<pre>        qmake BACKEND=NetworkManager</pre>
<p>The backend selection is expected to disappear once the API is integrated into Qt.</p>
<a name="reference-documentation"></a>
<h2>Reference documentation</h2>
<a name="main-classes"></a>
<h3>Main classes</h3>
<ul>
<li>Service Framework<ul>
<li><a href="qservicecontext.html">QServiceContext</a></li>
<li><a href="qservicefilter.html">QServiceFilter</a></li>
<li><a href="qserviceinterfacedescriptor.html">QServiceInterfaceDescriptor</a></li>
<li><a href="qservicemanager.html">QServiceManager</a></li>
<li><a href="qserviceplugininterface.html">QServicePluginInterface</a></li>
<li><a href="qabstractsecuritysession.html">QAbstractSecuritySession</a></li>
</ul>
</li>
<li>Bearer management<ul>
<li><a href="qnetworkconfiguration.html">QNetworkConfiguration</a></li>
<li><a href="qnetworkconfigurationmanager.html">QNetworkConfigurationManager</a></li>
<li><a href="qnetworksession.html">QNetworkSession</a></li>
</ul>
</li>
<li>Location<ul>
<li><a href="qgeocoordinate.html">QGeoCoordinate</a></li>
<li><a href="qgeopositioninfo.html">QGeoPositionInfo</a></li>
<li><a href="qgeopositioninfosource.html">QGeoPositionInfoSource</a></li>
<li><a href="qgeoareamonitor.html">QGeoAreaMonitor</a></li>
<li><a href="qsatelliteinfo.html">QSatelliteInfo</a></li>
<li><a href="qsatelliteinfosource.html">QSatelliteInfoSource</a></li>
</ul>
</li>
</ul>
<a name="examples"></a>
<h3>Examples</h3>
<ul>
<li>Service Framework<ul>
<li><a href="filemanagerplugin.html">File Manager Plugin Example</a></li>
<li><a href="bluetoothtransferplugin.html">Bluetooth Transfer Plugin Example</a></li>
<li><a href="servicebrowser.html">Service Browser Example</a></li>
</ul>
</li>
<li>Bearer Management<ul>
<li><a href="bearercloud.html">Bearer Cloud</a></li>
<li><a href="bearermonitor.html">Bearer Monitor</a></li>
</ul>
</li>
</ul>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td align="left">Copyright &copy; 2009 Nokia Corporation and/or its subsidiary(-ies)</td>
<td align="right"><div align="right">Qt Mobility API</div></td>
</tr></table></div></address></body>
</html>
