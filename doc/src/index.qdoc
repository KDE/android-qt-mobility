/*!

\page index.html

\title Qt Publish and Subscribe Developer Resources

\brief The Qt Value Space allows inter-process publication of hierarchical
data.

The Qt Publish and Subscribe allows developers to construct context sensitive trees
of data by means of the Qt Value Space. This allows a variety of different 
context dependent uses, for example, the data may be strings for a context 
sensitive help system, or perhaps a context sensitive remap of buttons.

\tableofcontents

\section1 Qt Value Space

The Qt Value Space unifies various sources of hierarchical data into a
single consistent model.  Conceptually the Value Space is a hierarchical tree
of which each node or leaf can optionally contain a QVariant value.  A
serialized version of a simple example Value Space might look like this.

\code
/Device/Buttons = 3
/Device/Buttons/1/Name = Menu
/Device/Buttons/1/Usable = true
/Device/Buttons/2/Name = Select
/Device/Buttons/2/Usable = false
/Device/Buttons/3/Name = Back
/Device/Buttons/3/Usable = true
\endcode

Existing values within the Value Space are access through the QValueSpaceSubscriber class.  This
class allows applications to read item values, navigate through the Value Space, subscribe to
change notifications for items and send requests for value changes to the value provider.

New values are added to the Value Space via the QValueSpaceProvider class.  This class allows
applications to publish values, receive interest notifications and change requests from other
applications.

Nodes in the Value Space can be thought of as representing schema objects.
Obviously this is a conceptual differentiation and not a physical one, as
internally the Value Space is treated as one large tree.  By applying
structured schema to the space "explore-ability" is increased.  For example,
the \c {/Device/Buttons} schema can be defined as containing a value
representing the number of mappable buttons on a device, and a sub-item for
each adhering to the \c {MappableButton} schema.  The \c {MappableButton}
schema itself may be defined as containing two attributes \c {Name} and
\c {Usable}.  Change notification is modeled in this fashion also.  Where the
\c {/Device/Buttons/1/Name} item is to change, the \c {/Device/Buttons/1} item
would be marked as changed, and so on up the tree.  This allows, for example,
subscription to just \c {/Device/Buttons} to be notified when anything
"button" related changes.

Internally, the Value Space consists of an arbitrary number of data source
trees, or layers, which are stacked on top of each other to form the final
unified view.  If a "higher" layer contains an item, it shadows the value of
items in the layers below it.

Consider the Value Space item \c {/Device/Buttons}.  If two layer contained this item, the value in
the layer with the higher layer order (see \l {QAbstractValueSpaceLayer::order()}) would shadow
that with the lower layer order.  However, if only the layer with the lower order contained this
item, it would be visible through the QValueSpaceSubscriber class, even if the higher order layer
contained sub-items such as \c {/Device/Buttons/1}.  That is, layer shadowing occurs by value not
by path.

The Qt Value Space contains the following layers:

\table
    \header
        \o Layer
        \o Description
    \row
        \o Shared Memory Layer
        \o The Shared Memory layer provides a non-permanent Value Space backing store using shared
           memory and local sockets.  The Shared Memory layer is only available on Unix platforms.
    \row
        \o Registry Layer
        \o The Registry layer provides a non-permanent Value Space backing store using volatile
           keys stored in the Windows' registry.  The Registry layer is only available on Windows
           platforms.
\endtable

\section2 Architecture

Layers in the Qt Value Space are provided by objects implementing the
QAbstractValueSpaceLayer interface.  The two internal layers, the Shared Memory
layer and the Registry layer, are implemented in this fashion.  The Value Space
supports adding new, 3rd party layers through calls to the
QValueSpace::installLayer() method and QVALUESPACE_AUTO_INSTALL_LAYER() macro.  All layers must be
installed prior to the first Value Space usage.  Although it is legal to have a different set of
layers installed in each process (a process local layer, for example) this asymmetric model is
discouraged as it might cause confusion if these two processes communicate.

The Qt Value Space system is divided into two parts: a single server and
zero or more clients.  Internally the Value Space system draws no distinction
between the two - the server is also a client, for example - but certain
layers, in particular the Shared Memory layer, do.  The Value Space
server \bold {must} be initialized via a call to
QValueSpace::initValueSpaceManager() prior to any use of the Value Space.
Value Space clients will automatically initialize the first time Value Space
functionality is used.

\section3 Shared Memory Layer

The external use of the Shared Memory layer is described in
QValueSpaceProvider.  The Shared Memory layer stores all values in a
10MB block of shared memory which is reserved when the Value Space
initializes.  As the layer creates this region at startup, it is assumed that
the operating system lazily commits memory.  If this assumption is invalid,
the Shared Memory layer will unnecessarily consume 10MB of memory.

Value Space clients read from the Shared Memory layer's shared memory
region directly.  A kernel lock is acquired for each read to prevent
corruption.  While the layer supports concurrent readers, it is possible that
a faulty or malicious application could acquire and refuse to release this
lock causing any layer updates to be delayed indefinitely.

Only the Value Space server ever writes to the shared memory region.  When
clients attempt to add items to the layer, their changes are transmitted via
a QLocalSocket (e.g. \c {/tmp/qt-N/valuespace_shmlayer} domain socket on Unix systems) to the
server where the update is performed.  Updates are batched in-process and sent when the process
re-enters the Qt event loop.  Transmission and synchronization of changes can
be forced manually by the QValueSpaceProvider::sync() call, although as this
requires a round trip between the client and server, doing so frequently may
significantly degrade performance.

Change notifications are transmitted to clients in the form of "something has
changed" messages.  Nodes within the shared memory region are versioned, which
allows clients to quickly determine exactly what has changed without the need
for a bulkier change notification protocol.

\section1 Building and compiling

This library requires Qt 4.6 to be installed.

To build the library, run \tt qmake and \tt make.


\section1 Example: Publish and Subscribe

In the example \l{publish-subscribe}{Publish and Subscribe} the Qt Value Space
is used as a method of communicating changes in one dialog (the provider) to 
another dialog (the consumer).

\section1 Example: Battery Charging - Accessing Publish and Subscribe from QML

In the example \l{battery-charge}{Accessing Publish and Subscribe from QML} the
\l{publish-subscribe}{Publish and Subscribe} concept is now extended to make
the provider an input of the level of charge in a battery. A slider on the 
provider dialog represents the modifiable level of charge. The Qt Value Space 
acts as a communications medium between the provider dialog and the consumer graphical
battery animation. The battery is implemented in QML and C++ with Qt Value Space 
supplying the charge level for the animation to represent.

\sa QValueSpaceSubscriber, QValueSpaceProvider, QValueSpace, QAbstractValueSpaceLayer
*/
