/*!

\page index.html

\title Qt Service Framework Developer Resources

\tableofcontents


\section1 Introduction

The Qt Service framework provides a set of APIs that allows clients to discover and instanciate arbitrary services. 
This is achieved by defining a unified way of finding, implementing and accessing services across multiple platforms.
Due to the service frameworks knowledge of service interfaces, their versions and QObject-based introspection
it may even be used to unify and access multiple platform specific service implementations via the same Qt-based 
client application.

\section1 Overview 

A service is an independent component that allows a client to perform a well-defined operation. Clients
can find services based on their name and version as well as the interface that is implemented by the service object.
Once the service has been identified the framework starts the service and returns a pointer
to it. QServiceManager is the main interface through which clients can access the mentioned
framework functionality. In addition services themselves may also act as clients to the service framework by requesting
other services installed on the system.

Service provider are implemented via plug-ins. QServicePluginInterface defines the main interface for each plug-in.
In order to avoid that clients have to link against service specific libraries each service object must be derived
from QObject. Therefore the QMetaObject system can be used to dynamically discover and invoke the service's capabilities.
To achieve the best level of access via the Qt meta object system services should be implemented in such a way that 
their entire functionality is accessable via the signals, slots, properties or invokable functions 
(see Q_INVOKABLE macro for more details).

Each service plug-in implements one service only but can provide multiple implementations for multiple interfaces. 
Therefore a service (plug-in) can retain a certain level of backwards compatibility even if the main service interface breaks
in such a way that a new interface name has to be used. Existing clients can still use the previous version of service interface
whereas new clients can utilize the new interface. 

Future versions of this framework may also enable access to out-of-process service provider. 

\section1 Using the framework

This section assumes that the user wants to access the \i FileManager service which offers an implementation for the \i com.nokia.qt.examples.FileStorage interface
The service framework enables multiple ways of accessing those implementations. 

QServiceManager is the main class to lookup and instanciate services. Services can be found by constraining the search via service meta data or
by using the default lookup mechanism.

\section2 Verbose lookup

The client code has precise knowledge of the service and its interfaces. 

\code
    QServiceManager* manager = new QServiceManager(this);
    QServiceFilter filter("com.nokia.qt.examples.FileStorage");
    filter.setServiceName("FileManager");
    QList<QServiceInterfaceDescriptor> objs = manager->findInterfaces(filter);
    Q_ASSERT(objs.count());

    //instanciate the FileStorage object
    QObject* service = manager->loadInterface(objs.at(0));
\endcode

\section2 Default lookup

The client code has knowledge of the interface and doesn't really care about the service that implements the interface. In such cases 
the default service lookup can be utilized to create a service object instance. If the same service provides multiple versions of 
the same interface the latest version is returned. Therefore subsequent versions of the same interface must always be binary 
compatible to previous versions.

\code
    QServiceManager* manager = ...
    QObject* storage = manager->loadInterface("com.nokia.qt.examples.FileStorage");
\endcode

\section2 Header lookup

So far all lookup mechanism returned a QObject pointer. This pointer can be utilised by introspecting the object using 
Qt's meta object system. Therefore the client does not have to have any knowledge of the object header or symbols. However in some use cases 
it may be more convenient to directly interact with the service object by including the service header and/or linking against the service provider.
The subsequent code snippet demonstrates how this may look like:

\code
#include <filestorage.h>
...
QServiceManager manager;
FileStorage* storage = 0;
manager->setDefaultServiceForInterface("FileManager", "com.nokia.qt.examples.FileStorage");
storage = manager->getInterface("com.nokia.qt.examples.FileStorage");

\endcode

\section1 Adding and removing of services

New services can be installed and removed at runtime. An XML file is used to describe the service meta data and links the service code
to its meta description.

\section2 XML format

Services are installed via an XML file which describes the meta data and location of the service. The xml file can be described via the following 
DTD:

\code
    <!ELEMENT service ( name, filepath, description?, interface+ ) >
    <!ELEMENT description ( #CDATA ) >
    <!ELEMENT filepath ( #PCDATA ) >
    <!ELEMENT interface ( name, version, description?, capabilities?, customproperty* ) >
    <!ELEMENT capabilities ( #PCDATA ) >
    <!ELEMENT name ( #PCDATA ) >
    <!ELEMENT version ( #PCDATA ) >
    <!ELEMENT customproperty ( #CDATA ) >
    <!ATTLIST customproperty key NMTOKEN #REQUIRED >

\endcode

The elements and attributes have the following meanings:

\table
    \header
        \o Element \o SubElement \o Description
   \row
        \o service
        \o 
        \o The \i service tag can contain an arbitrary number of \i interface tags and one description tag.
    \row
        \o "
        \o description
        \o A user readable description of the purpose of the service.
    \row
        \o "
        \o filepath
        \o The absolute path and name of the plug-in to be loaded when this service is requested. Alternatively if the plug-in
           name only is provided the standard library paths (see QCoreApplication::libraryPaths()) are used to find the plug-in.
           Note that if the plugin name is given only, platform specific parts such as the suffix ".dll" and ".so" or plugin prefix "lib"
           should be removed to enable cross platform resolution. QLibrary is used to determine the platform specific parts of the plugin.
    \row
        \o "
        \o name
        \o The name of the service.
    \row
        \o interface
        \o
        \o The \i interface describes the properties of the interface.
    \row
        \o "
        \o capabilities
        \o This property is a list of arbitrary strings which are interpreted as permissions/capabilities. This list can be empty.
    \row
        \o "
        \o name
        \o The name of the interface using the Java class name notation. (e.g. com.nokia.qt.TestService)
    \row
        \o "
        \o version
        \o This property contains the interface and implementation version. The version tag follows the \i major.minor notation. The major version indicates the interface version the minor version the implementation version.

           The version number \bold must be greater than 1.0. The version cannot be less than 1.0 because the Service Framework is dependent on the fact that services must be binary compatible between major versions, and services with versions less than 1.0 are unlikely to be binary compatible with later versions.
    \row
        \o "
        \o description
        \o A user readable description of the purpose of the interface.
 
\endtable


An example for a valid XML service description could be the following \i TestService:

\code
    <?xml version="1.0" encoding="utf-8" ?>
    <service>
        <name>TestService</name>
        <filepath>testserviceplugin</filepath>
        <description>Test service description</description>
        <interface>
            <name>com.nokia.qt.ILocation</name>
            <version>1.4</version>
            <capabilities></capabilities>
            <description>Interface that provides location support</description>
        </interface>
        <interface>
            <name>com.nokia.qt.ILocation</name>
            <version>1.5</version>
            <capabilities></capabilities>
            <description>Interface that provides location support</description>
        </interface>
        <interface>
            <name>com.nokia.qt.ISysInfo</name>
            <capabilities>ReadUserData</capabilities>
            <version>2.3</version>
            <description>Interface that provides system information support</description>
            <customproperty key="key1">value1</customproperty>
            <customproperty key="key2">value2</customproperty>
        </interface>  
    </service>
\endcode

\section2 Installing the service at runtime

New services can be added and removed at any time via QServiceManager::addService() and QServiceManager::removeService().


\section1 Identifying services

Each implementation is identified by a service name, an interface name and its version. This information is encapsulated 
by QServiceInterfaceDescriptor which can be used to request references to service objects. 

QServiceFilter simplifies the lookup of already installed services. Developers specifies the criteria used during the meta data lookup. The subsequent example
demonstrates the interaction between QServiceInterfaceDescriptor and QServiceFilter by creating references to all services that implement the 
above \i com.nokia.qt.TestService interface:

\code
    QServiceManager mgr;
    QServiceFilter filter;
    filter.setInterfaceName("com.nokia.qt.TestService");
    QList<QServiceInterfaceDescriptor> list = mgr.findInterfaces(filter);
    for( int i = 0; i<list.size(); i++) {
        QObject* obj = mgr.loadInterface(list[i]);
        if (obj) obj.setParent(this); //returned object owned by client
    }
\endcode

\section1 Upgrading services
There are two ways in which to upgrade a service.  The first is an incremental approach whereby QServiceManager::addService() is used to register 
an XML descriptor whose service name already exists but defines new interface implementations.  For example an already existing service, "ovi"
may define version 1.0 of interface,"IDownload".  QServiceManager::addService() is then called with an XML descriptor that declares itself
as belonging the "ovi" service, but implements version 1.1 of the interface "IDownload".  Both implementation versions will be
available for use.

The second method is a replacement approach whereby an existing service is completely removed and replaced by a new service.
As an example the already existing "ovi" service may implement interface "IDownload" version 1.0, the new "ovi" service may 
implement "IDownload" version 1.0 and version 1.1.  In this case the old service implementation must be first be removed using
QServiceManager::removeService() to make way for the new service implementation.

\section1 Building and compiling

This library requires Qt 4.5 to be installed.

To build the library, run \tt qmake and \tt make.


\section1 Reference documentation

\section2 Main classes

\list
    \o \l{QServiceContext}
    \o \l{QServiceFilter}
    \o \l{QServiceInterfaceDescriptor}
    \o \l{QServiceManager}
    \o \l{QServicePluginInterface}
    \o \l{QAbstractSecuritySession}
\endlist

\section2 Examples

\list
    \o \l{File Manager Plugin Example}
    \o \l{Bluetooth Transfer Plugin Example}
    \o \l{Service Browser Example}
\endlist

*/
