/*!

\page contacts.html

\title Qt Contacts Developer Resources

\tableofcontents

\section1 Introduction

Qt Contacts provides a set of APIs that allows clients to request contact data from local or remote backends,
access to which are provided by implementations of Qt Contacts manager API.  This is achieved by defining generic
personal information data abstractions which can sufficiently describe contact data stored on any platform.
Due to the cross-platform nature of the API, and the ability for developers to write platform-independent
implementations of a QContactManager which may unify one or more platform specific contact backends, it is
intended that the semantics and quirks of the underlying datastores on any platform may be entirely opaque
from the perspective of Qt-based, cross-platform client applications.

\section1 Overview 

A contact is the digital representation of a person, which is stored in a platform-specific manner.
Information pertaining to a single contact may be located across several different datastores, and each datum
(or detail) may or may not pertain to a particular context in which that information is valid.  A contact may
include semantically identical pieces of information that are relevant in different contexts.  For example, a
contact may have a phone number that is relevant to their "home" context, and another phone number that is relevant
to their "work" context.  It can be seen that the context of information defines its validity to the user, depending
on the context of usage; and as such, the sum of information in a given context can be considered equivalent to
a "contextual identity".  This allows great flexibility when consolidating data from various sources into a single,
cohesive contact.  Contacts may be placed into arbitrary collections called groups.  Each group has a name and a
unique identifier, and consists of a list of contacts.

Each datum (or detail) stored in a contact has defined semantics of usage and storage.  The Qt Contacts API allows
per-datastore contact detail definitions, allowing a manager to provide clients with this information on demand,
and allowing third-party developers to register detail definitions for use by clients.  A detail definition includes
the fields (and value-types of those fields) which make up the detail, per-contact uniqueness constraints on
details of the definition, and access constraints (such as read-only, create-only, etc).

A detail is a single, cohesive unit of information that is stored in a contact.  As explained previously, it is
valid for a particular context or set of contexts, and conforms to a particular definition.  A detail may have
specific metadata associated with it, such as its sub-type, the source of the information, and arbitrary,
user-defined metadata.

A manager provides access to zero or more platform-specific datastores.  Each datastore may support different
capabilities (for example, the ability to store certain datatypes, the ability to natively filter on different
details or details of different definitions, the provision of locking mechanisms, the provision of changelog
information, etc) which are reported by the manager on request.  The manager therefore provides access to detail
definitions, contacts, and groups stored in different datastores, in a platform and datastore independent manner.
The engine of a manager may be implemented as a plugin to allow dynamic loading of different engines at run-time.

\section1 Using the API

This section provides some examples of common usage of the API.

\section2 Saving a new contact to the default manager

    The client creates a new contact, adds a name and a phone number, and saves it to the default store of the default manager.
    We assume the existence of a specialised leaf-class that allows simple access to details of the definition identified
    by the "PhoneNumber" identifier, and another that allows simple access to details of the definition identified by the
    "Name" identifier.  These specialised leaf classes may be written by anyone, and simply wrap the functionality
    provided by QContactDetail in order to allow simpler access to fields supported by a particular definition.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Creating a new contact

\section2 Filtering by detail definition and value

    The client utilises a default manager and asks for any contacts with
    a particular phone number.  The example assumes that the default manager supports
    the provided QContactPhoneNumber detail leaf class (which implements the default
    definition for phone number details).

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Filtering by definition and value

\section2 Viewing a specific detail of a contact

    The client retrieves the phone numbers of a contact, and displays the first one

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing a specific detail of a contact

\section2 Viewing all of the details of a contact

    The client retrieves all of the details of a contact, and displays them

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Viewing the details of a contact

\section2 Installing a plugin that modifies the definition of one type of detail

    The client installs a plugin, which requires a new field to be added to details of the
    "EmailAddress" definition.  It loads the definition from the default manager,
    modifies it (by adding the new field - a label field), and saves it back.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Installing a plugin which modifies a definition

\section2 Modifying an existing contact and saving the modifications

    The client retrieves a contact, modifies one of its details, adds a new detail, and then saves the
    contact back to the manager.  Note that it uses the newly added field of the email address definition!

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Modifying an existing contact

\section2 Loading the manager for a specific backend

    In this example, the client loads a manager for a specific backend.  While this could be
    found and retrieved using a more advanced plugin framework (such as the Qt Service Framework),
    this code assumes that the client has prior knowledge of the backend in question.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend

\section2 Loading a manager with specific parameters

    The client loads a manager with specific parameters defined.  The parameters which are available
    are backend specific, and so the client had to know that the "Settings" parameter was valid for
    the particular backend, and what argument it took.
    In this example, the client tells the backend to load detail definitions saved in a particular
    settings file.

    \snippet snippets/qtcontactsdocsample/qtcontactsdocsample.cpp Loading a specific manager backend with parameters

\section1 Building and compiling

This library requires Qt 4.5 to be installed.

To build the library, run \tt qmake and \tt make.

\section1 Reference documentation

\section2 Main classes

\list
    \o \l{QContactManager}
    \o \l{QContactDetailDefinition}
    \o \l{QContactDetail}
    \o \l{QContact}
    \o \l{QContactGroup}
\endlist

\section2 Detail leaf classes

Several subclasses of \l{QContactDetail} are provided as part of the
Qt Mobility Contacts API.  They are general in design but are intended
to fulfil specific use-cases.  Please note that certain backends may
choose not to support one or more of these subclasses as they appear here;
they may offer their own which provide similar functionality, or they may
require that clients access contact information through the \l{QContactDetail}
base class alone.

\list
    \o \l{QContactAddress}
    \o \l{QContactAnniversary}
    \o \l{QContactAvatar}
    \o \l{QContactBirthday}
    \o \l{QContactEmailAddress}
    \o \l{QContactGender}
    \o \l{QContactGuid}
    \o \l{QContactName}
    \o \l{QContactPhoneNumber}
    \o \l{QContactSyncTarget}
    \o \l{QContactUrl}
\endlist

Each of these subclasses provide access to information stored in fields which
are listed in the \l{Qt Contacts Schema}{schema}.

\section2 Examples

\list
    \o \l{samplephonebook}{Sample Phonebook}
\endlist

*/
