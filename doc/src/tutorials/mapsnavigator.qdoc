/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of this
** file.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \page tutorials-mapsnavigator.html
    \title Maps Navigator Tutorial

    \brief An introduction to the Location API, showing how to develop a simple
           map search and navigation application.

    In this tutorial, you will learn about the basic components of the Location
    API, including

    \list
    \o items
    \o here...
    \endlist

    We will be developing the map search and navigation application shown below:

    \image mapsnavigator-finished.png

    Tutorial contents:

    \list 1
    \o \l{tutorials/mapsnavigator/part1}{The Map Widget}
    \o \l{tutorials/mapsnavigator/part2}{Searching for locations}
    \o \l{tutorials/mapsnavigator/part3}{Listening to satellites}
    \o \l{tutorials/mapsnavigator/part4}{Stopping for directions}
    \o \l{tutorials/mapsnavigator/part5}{Kinetic panning and tuning for mobile}
    \endlist

    Some more text goes here.
*/

/*!
    \page tutorials-mapsnavigator-part1.html
    \example tutorials/mapsnavigator/part1
    \title Part 1 - The Map Widget

    To begin with, we will start defining the map widget, which is the central part of
    the application's user interface. Enough of the map widget will be defined here to
    work satisfactorily on most desktop platforms -- full consideration for mobile use
    will be made later along with other parts of the application.

    \section2 The very basics

    The Location module provides the QGraphicsGeoMap which is a simple, easy way to insert
    maps into a QGraphicsScene. Since we're going to be extending the map later, we'll
    create a subclass of QGraphicsGeoMap called \c GeoMap, as below:

    \code
class GeoMap : public QGraphicsGeoMap
{
    Q_OBJECT

public:
    GeoMap(QGeoMappingManager *manager, MapsWidget *mapsWidget);
    ~GeoMap();

private:
    MapsWidget *m_mapsWidget;
};

GeoMap::GeoMap(QGeoMappingManager *manager, MapsWidget *mapsWidget) :
    QGraphicsGeoMap(manager), m_mapsWidget(mapsWidget)
{
}
    \endcode

    And next we define a QWidget subclass, MapsWidget, which handles the creation of
    QGraphicsView and QGraphicsScene to put the GeoMap into:

    \code
class MapsWidget : public QWidget
{
    Q_OBJECT

public:
    MapsWidget(QWidget *parent = 0);
    ~MapsWidget();

public slots:
    void initialize(QGeoMappingManager *manager);

private:
    GeoMap *geoMap;
    QGraphicsView *graphicsView;
};
    \endcode

    We perform the creation of the QGraphicsScene and GeoMap in the initialize() method:

    \code
void MapsWidget::initialize(QGeoMappingManager *manager)
{
    geoMap = new GeoMap(manager, this);

    QGraphicsScene *sc = new QGraphicsScene;
    sc->addItem(geoMap);

    geoMap->resize(300, 480);

    graphicsView = new QGraphicsView(sc, this);
    graphicsView->setVisible(true);
    graphicsView->setInteractive(true);

    geoMap->setCenter(QGeoCoordinate(-27.5796, 153.1));
    geoMap->setZoomLevel(15);
}
    \endcode

    Doing this in the constructor, while possible, is not the preferred approach, as
    the QGeoMappingManager may not be available until the user has chosen it, or until a
    network connection is available. This is especially important in mobile
    environments, as we'll see later.

    To get an instance of QGeoMappingManager we use the list of service providers
    available in QGeoServiceProvider::availableServiceProviders(). Service providers
    provide the ability to fetch and draw maps, search for locations, get directions,
    and a variety of other tasks.

    To test out the MapsWidget we just wrote, we can simply get the first available
    service provider in the main() function, as follows:

    \code
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MapsWidget w;
    w.show();

    QList<QString> providers = QGeoServiceProvider::availableServiceProviders();
    QGeoServiceProvider *serviceProvider = new QGeoServiceProvider(providers[0]);

    w.initialize(serviceProvider->mappingManager());

    return a.exec();
}
    \endcode

    If you compile and run the code so far, you should see a window appear containing
    a street map of Eight Mile Plains, in Queensland, Australia, rendered by your
    platform's default geo service provider.

    \image mapsnavigator-verybasic.png

    \section2 Pan & zoom

    Next we'll add some basic pan and zoom capability to the map widget. Like most other
    classes in Qt, QGraphicsGeoMap allows mouse and keyboard events to be handled by
    private methods.

    Into the private section of the GeoMap declaration we add:
    \code
bool panActive;

void mousePressEvent(QGraphicsSceneMouseEvent *event);
void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    \endcode

    And their definitions:

    \code
void GeoMap::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = true;
    event->accept();
}

void GeoMap::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = false;
    event->accept();
}

void GeoMap::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    if (panActive) {
        QPointF delta = event->lastPos() - event->pos();
        pan(delta.x(), delta.y());
    }
    event->accept();
}
    \endcode

    These three short methods are enough to add basic panning support to the map.
    The panning method is a simple mouse-locked one, and moving long distances on
    a touch screen with it can get quite tedious. Many map applications now make
    use of "kinetic" panning for a better user experience, especially on touch
    devices, and we'll implement support for that later.

    Next, to add zoom support on the mouse scrollwheel:

    \code
void GeoMap::wheelEvent(QGraphicsSceneWheelEvent *event)
{
    qreal panx = event->pos().x() - size().width() / 2.0;
    qreal pany = event->pos().y() - size().height() / 2.0;
    pan(panx, pany);
    if (event->delta() > 0) {   // zoom in
        if (zoomLevel() < maximumZoomLevel()) {
            setZoomLevel(zoomLevel() + 1);
        }
    } else {                    // zoom out
        if (zoomLevel() > minimumZoomLevel()) {
            setZoomLevel(zoomLevel() - 1);
        }
    }
    pan(-panx, -pany);
    event->accept();
}
    \endcode

    This method is a little more complicated. To provide a suitable zoom feel, we
    have to actually combine panning with zooming, so that the user's point of
    interest (the mouse cursor) remains in the same part of the view. So, we
    actually pan the mouse cursor's location into the center, then adjust
    the zoom level, then pan back at the end.

    \section2 Map icons

    Another important basic feature is the ability to render icons on the map to
    represent points of interest. The QGeoMapPixmapObject class provides most of
    the functionality necessary to achieve this, and we'll use a subclass of it
    in similar vein to our GeoMap, above.

    For our application, we need to deal with 6 different kinds of icons:
    \list
    \o A "my location" icon
    \o "Search" icons for search results
    \o User waypoints for direction routes
    \o Start points for directions
    \o End points for directions
    \o "Path" markers for individual steps in the direction route
    \endlist

    \code
class Marker : public QGeoMapPixmapObject
{
    Q_OBJECT
public:
    enum MarkerType {
        MyLocationMarker,
        SearchMarker,
        WaypointMarker,
        StartMarker,
        EndMarker,
        PathMarker
    };

    explicit Marker(MarkerType type);

    inline MarkerType markerType() const { return m_type; }
    void setMarkerType(MarkerType type);

private:
    MarkerType m_type;

};
    \endcode

    So we can construct Marker instances of different types, but we need QPixmaps
    to represent each one. In our implementation we will simply use a \c switch
    statement to map MarkerTypes to QPixmaps.

    \code
Marker::Marker(MarkerType type) :
    QGeoMapPixmapObject()
{
    setMarkerType(type);
}

void Marker::setMarkerType(MarkerType type)
{
    QString filename;
    QPoint offset;
    int scale;

    m_type = type;

    switch (m_type) {
    case MyLocationMarker:
        filename = ":/icons/mylocation.png";
        break;
    case SearchMarker:
        filename = ":/icons/searchmarker.png";
        break;
    case WaypointMarker:
        filename = ":/icons/waypointmarker.png";
        break;
    case StartMarker:
        filename = ":/icons/startmarker.png";
        break;
    case EndMarker:
        filename = ":/icons/endmarker.png";
        break;
    case PathMarker:
        filename = ":/icons/pathmarker.png";
        break;
    }

    if (m_type == MyLocationMarker) {
        offset = QPoint(-13,-13);
        scale = 25;
    } else {
        offset = QPoint(-15, -36);
        scale = 30;
    }

    setOffset(offset);
    setPixmap(QPixmap(filename).scaledToWidth(scale, Qt::SmoothTransformation));
}
    \endcode

    The icon PNG images can be found in the \c examples/mapsnavigator/icons
    directory in the QtMobility distribution. All we have to do to have this
    working is simply add the PNG icons to a \c .qrc file and add it to the
    project.

    The QGraphicsGeoMap::addMapObject method is used to add markers to a map.
    We can add a call to create a marker at our starting point into
    MapsWidget::initialize() as a demonstration:

    \code
// in MapsWidget::initialize()
Marker *me = new Marker(Marker::MyLocationMarker);
me->setCoordinate(QGeoCoordinate(-27.5796, 153.1));
geoMap->addMapObject(me);
    \endcode

    Build and start the application, and we now have a "My Location" icon in
    the centre of the initial view.

    This now concludes the basic functionality of the map widget. We'll be
    making a few modifications and improvements to it as we go along, but
    the basic skeleton will remain the same.

    Next, we'll add a basic GUI around the map widget, and the ability
    to search for locations like addresses.
*/

/*!
    \page tutorials-mapsnavigator-part2.html
    \example tutorials/mapsnavigator/part2
    \title Part 2 - Searching for locations

    Now that we have a basic map widget, we want to add the capability
    to search for addresses and locations and create markers for them
    on the map.

    \section2 Search classes

    Searching in the Location API is handled by use of the QGeoSearchManager,
    which we obtain in similar fashion to the MappingManager (in main() in
    part 1). As we want to create markers for search results and then
    be able to remove them for the next search (or perhaps other operations),
    we need some way to organise collections of markers.

    To do this, we introduce a new class, MarkerManager:

    \code
class MarkerManager : public QObject
{
    Q_OBJECT
public:
    explicit MarkerManager(QGeoSearchManager *sm, QObject *parent=0);
    ~MarkerManager();

public slots:
    void setMap(QGraphicsGeoMap *map);
    void setMyLocation(QGeoCoordinate coord);
    void search(QString query);
    void removeSearchMarkers();

signals:
    void searchError(QGeoSearchReply::Error error, QString errorString);
    void searchFinished();

private:
    Marker *m_myLocation;
    QList<Marker*> searchMarkers;

    QGraphicsGeoMap *m_map;
    QGeoSearchManager *m_searchManager;
    QSignalMapper sigMap;

private slots:
    void replyFinished(QObject *reply);
};
    \endcode

    The MarkerManager tracks both the "My Location" marker and a list of search
    result markers. Implementing the My Location portion is nothing new:

    \code
MarkerManager::MarkerManager(QGeoSearchManager *searchManager, QObject *parent) :
    QObject(parent),
    m_searchManager(searchManager)
{
    m_myLocation = new Marker(Marker::MyLocationMarker);
}

MarkerManager::~MarkerManager()
{
    m_map->removeMapObject(m_myLocation);
    delete m_myLocation;
    ...
}

void MarkerManager::setMap(QGraphicsGeoMap *map)
{
    ...
    map->addMapObject(m_myLocation);
    ...
}

void MarkerManager::setMyLocation(QGeoCoordinate coord)
{
    m_myLocation->setCoordinate(coord);
}
    \endcode

    To implement searching, we call the QGeoSearchManager::search method, which
    returns a QGeoSearchReply. This reply object emits a signal finished() when
    the search results are available. It can also be constructed already
    finished, and we need to check for this first before connecting the signals.

    Since we'd like to have one general slot that handles both the pre-finished
    and the signal case, we give the slot a QObject* parameter and make use of
    QSignalMapper:

    \code
void MarkerManager::search(QString query)
{
    QGeoSearchReply *reply = m_searchManager->search(query);
    if (reply->isFinished()) {
        replyFinished(reply);
    } else {
        sigMap.setMapping(reply, reply);
        connect(reply, SIGNAL(finished()),
                &sigMap, SLOT(map()));
        connect(&sigMap, SIGNAL(mapped(QObject*)),
                this, SLOT(replyFinished(QObject*)));

        connect(reply, SIGNAL(error(QGeoSearchReply::Error,QString)),
                this, SIGNAL(searchError(QGeoSearchReply::Error,QString)));
    }
}
    \endcode

    The QGeoSearchReply yields its results as a list of QGeoPlace instances.
    While these hold quite a bit of information, for now we'll just be using
    them for their coordinates.

    \code
void MarkerManager::replyFinished(QObject *obj)
{
    QGeoSearchReply *reply = dynamic_cast<QGeoSearchReply*>(obj);
    Q_ASSERT(reply != NULL);

    // generate the markers and add them to the map
    foreach (QGeoPlace place, reply->places()) {
        Marker *m = new Marker(Marker::SearchMarker);
        m->setCoordinate(place.coordinate());
        searchMarkers.append(m);

        if (m_map) {
            m_map->addMapObject(m);
            // also zoom out until marker is visible
            while (!m_map->viewport().contains(place.coordinate()))
                m_map->setZoomLevel(m_map->zoomLevel()-1);
        }
    }

    reply->deleteLater();

    emit searchFinished();
}
    \endcode

    Next, we add two methods to MapsWidget to keep track of a MarkerManager
    instance associated with its map:

    \code
class MapsWidget : public QWidget
{
    ...
public:
    void setMarkerManager(MarkerManager *markerManager);
    MarkerManager *markerManager() const;

    ...
private:
    MarkerManager *m_markerManager;
    ...
};
    \endcode

    And then add two small sections of code to connect them together:

    \code
void MapsWidget::initialize(QGeoMappingManager *manager)
{
    geoMap = new GeoMap(manager, this);
    if (m_markerManager)
        m_markerManager->setMap(geoMap);
    ...
}

void MapsWidget::setMarkerManager(MarkerManager *markerManager)
{
    m_markerManager = markerManager;
    if (geoMap)
        markerManager->setMap(geoMap);
}
    \endcode

    Now we have basic search capability added to our code. But we still
    have no GUI to drive it, and so we'll focus on that in the next section.

    \section2 GUI with search dialog

    Next we'll build a GUI around our map widget and add a search dialog to
    make use of the code we just wrote. Our finished GUI looks like this:

    \image mapsnavigator-searchgui.png

    We won't cover building the GUI in too much detail (that being the
    subject of other tutorials), but the complete code is in the finished
    MapsNavigator example in the QtMobility distribution.

    Our GUI consists of a QMainWindow containing our MapsWidget and a QMenuBar.
    On the QMenuBar is an option for zooming to the current "My Location", and
    a menu for performing search operations.

    Also part of the GUI is the dialog box displayed when selecting "Search
    for address or name" -- this is a simple QDialog subclass with a QFormLayout
    and a QDialogButtonBox.

    In the MainWindow constructor, we simply set up the menubar and MapsWidget
    and other UI details. All initialization of Location-based details are in
    the MainWindow::initialize() slot. For the moment, we will simply assume
    that initialize() is called directly from the constructor (the purpose of
    this decoupling will be explained later).

    \code
void MainWindow::initialize()
{
    if (serviceProvider)
        delete serviceProvider;

    QList<QString> providers = QGeoServiceProvider::availableServiceProviders();
    if (providers.size() < 1) {
        QMessageBox::information(this, tr("Maps Navigator"),
                                 tr("No service providers are available"));
        QCoreApplication::quit();
        return;
    }

    serviceProvider = new QGeoServiceProvider(providers[0]);
    if (serviceProvider->error() != QGeoServiceProvider::NoError) {
        QMessageBox::information(this, tr("Maps Navigator"),
                                 tr("Error loading geoservice plugin: %1").arg(providers[0]));
        QCoreApplication::quit();
        return;
    }

    mapsWidget->initialize(serviceProvider->mappingManager());
    markerManager = new MarkerManager(serviceProvider->searchManager());
    mapsWidget->setMarkerManager(markerManager);

    connect(markerManager, SIGNAL(searchError(QGeoSearchReply::Error,QString)),
            this, SLOT(showErrorMessage(QGeoSearchReply::Error,QString)));

    mapsWidget->setMyLocation(QGeoCoordinate(-27.5796, 153.1));
}
    \endcode

    As you can see, this performs more or less the same actions as our old
    code in main() from part 1 of the tutorial did. It fetches the first
    available service provider, then initializes the MapsWidget and
    MarkerManager using the appropriate Manager instances.

    Additionally, we've added a setMyLocation() method to MapsWidget which
    simply calls the current MarkerManager's method of the same name, plus
    centreing the view on the marker.

    The "Search for address or name" menu item sets off the showSearchDialog()
    slot:

    \code
void MainWindow::showSearchDialog()
{
    SearchDialog sd;
    if (sd.exec() == QDialog::Accepted) {
        if (markerManager) {
            markerManager->removeSearchMarkers();
            markerManager->search(sd.searchTerms());
        }
    }
}
    \endcode

    Which uses the methods on MarkerManager that we defined previously. So now
    we have a basic searchable mapping application. However, there is one big
    piece of functionality missing for a searchable map: consider if we had
    a provider that allowed us to search for local businesses. We might type
    in a business name in the Search dialog and press OK, and then be presented
    with tens or hundreds of businesses that match the name we typed from all
    around the world. Some of these results might not even be the kind of
    business we were looking for (partial text matches etc).

    This can be solved with the addition of two key features: viewing the extra
    details about search results that we're currently throwing away; and adding
    the ability to limit the search area.

    \section2 Adding details to search markers

    First up, we'll add some additional properties to the Marker class:

    \code
class Marker : public QGeoMapPixmapObject
{
    ....
public:
    inline QString name() const { return m_name; }
    inline void setName(QString name) { m_name = name; }

    inline QGeoAddress address() const { return m_address; }
    inline void setAddress(QGeoAddress addr) { m_address = addr; }

    inline bool moveable() const { return m_moveable; }
    inline void setMoveable(bool moveable) { m_moveable = moveable; }

private:
    ...
    QString m_name;
    bool m_moveable;
    QGeoAddress m_address;
};
    \endcode

    And add code to MarkerManager to set them from search results:

    \code
void MarkerManager::replyFinished(QObject *obj)
{
    ...
    foreach (QGeoPlace place, reply->places()) {
        Marker *m = new Marker(Marker::SearchMarker);

        m->setCoordinate(place.coordinate());
        if (place.isLandmark()) {
            QLandmark lm(place);
            m->setName(lm.name());
        } else {
            m->setName(QString("%1, %2").arg(place.address().street())
                                        .arg(place.address().city()));
        }
        m->setAddress(place.address());
        m->setMoveable(false);
    ...
    \endcode

    So now the data is available from the Marker objects. We want to show
    this to the user somehow, though, and the best means of doing this is
    probably a dialog box. We're going to do a dialog box that appears when
    the user clicks a marker, so we'll have to add click detection to
    MapsWidget and GeoMap, first.

    We already have methods for handling mouse presses and releases over
    the map widget, so we will modify these. Add two private fields and a
    signal to GeoMap:

    \code
class GeoMap : public QGraphicsGeoMap
{
    ...
signals:
    void clicked(Marker *marker);

private:
    ...
    bool markerPressed;
    QGeoMapObject *pressed;
    ...
};
    \endcode

    We set the \c markerPressed flag when the mouse has been pressed over a
    map object, and set \c pressed to the map object in question.

    \code
void GeoMap::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = true;

    markerPressed = false;
    QList<QGeoMapObject*> objects = mapObjectsAtScreenPosition(event->pos());
    if (objects.size() > 0) {
        pressed = objects.first();
        markerPressed = true;
    }

    event->accept();
}

void GeoMap::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = false;

    if (markerPressed) {
        // check if we're still over the object
        QList<QGeoMapObject*> objects = mapObjectsAtScreenPosition(event->pos());
        if (objects.contains(pressed)) {
            Marker *m = dynamic_cast<Marker*>(pressed);
            if (m)
                emit clicked(m);
        }

        markerPressed = false;
    }

    event->accept();
}
    \endcode

    Finally, we need to pass this clicked() signal up through MapsWidget so
    that we can use it from outside. We do this by adding a signal and
    connecting GeoMap's signal to the signal on MapsWidget with the same
    name.

    \code
class MapsWidget : public QWidget
{
    ...
signals:
    void markerClicked(Marker *m);
    ...
};

void MapsWidget::initialize(QGeoMappingManager *manager)
{
    ...
    connect(geoMap, SIGNAL(clicked(Marker*)),
            this, SIGNAL(markerClicked(Marker*)));
}
    \endcode

    Now that's done, creating a dialog box to display the address information
    is relatively trivial. The MarkerDialog class contains a QLineEdit for the
    name field, a readonly QLabel for the address, and two QDoubleSpinBoxes
    for latitude and longitude.

    We connect up the MapsWidget's markerClicked() signal to a slot in
    MainWindow:

    \code
void MainWindow::on_markerClicked(Marker *marker)
{
    MarkerDialog md(marker);
    if (md.exec() == QDialog::Accepted) {
        marker->setName(md.markerName());
        QGeoCoordinate c(md.latitude(), md.longitude());
        marker->setCoordinate(c);
    }
}
    \endcode

    And now clicking on markers on the map yields a simple editing dialog box, so
    our first task is complete.

    \section2 Limiting search area

    The QGeoSearchManager's search() method already comes with support for
    limited search areas -- by setting up a QGeoBoundingArea we can take
    advantage of this functionality.

    Firstly, we'll modify the MarkerManager's search() method:

    \code
// declaration
void search(QString query, qreal radius=-1);

// implementation
void MarkerManager::search(QString query, qreal radius)
{
    QGeoSearchReply *reply;
    if (radius > 0) {
        QGeoBoundingCircle boundingCircle(m_myLocation->coordinate(), radius);
        reply = m_searchManager->search(query,
                                        QGeoSearchManager::SearchAll,
                                        -1, 0,
                                        boundingCircle);
    } else {
        reply = m_searchManager->search(query);
    }

    if (reply->isFinished()) {
      ...
    \endcode

    And now we need to modify the UI to expose this to the user. There are
    a few ways of doing this, but the option we'll take is to expose a
    QComboBox with some preset distances. This is easier to use on
    touch screen devices, especially, where entering numbers often takes
    much more effort from the user than selecting an option.

    \code
// in SearchDialog constructor
whereCombo = new QComboBox();
whereCombo->addItem(tr("Nearby (<10km)"), 10000);
whereCombo->addItem(tr("Within 30 mins drive of me (<25km)"), 25000);
whereCombo->addItem(tr("Within 100km of me"), 100000);
whereCombo->addItem(tr("Anywhere in the world"), -1);
whereCombo->setCurrentIndex(1);
formLayout->addRow(tr("Where"), whereCombo);
    \endcode

    Then to get the radius value to put into search, we simply take the user
    data from the QComboBox, convert it to a qreal and pass it through.

    So we now have a searchable map, with clickable markers and the ability
    to limit the search radius. The last feature we'll cover that relates to
    searching is the so-called "reverse geocode" technique.

    \section2 Reverse geocode

    Currently, if you click the My Location icon on our map application, a
    blank address is displayed. We can add the capability here to turn the
    current coordinates of the marker into an approximate address, and the
    technique is known as "reverse geocode" searching.

    To implement this, we'll hook into the coordinateChanged() signal of
    the Marker object:

    \code
MarkerManager::MarkerManager(QGeoSearchManager *searchManager, QObject *parent) :
    QObject(parent),
    m_searchManager(searchManager)
{
    m_myLocation = new Marker(Marker::MyLocationMarker);
    m_myLocation->setName("Me");

    // hook the coordinateChanged() signal for reverse geocoding
    connect(m_myLocation, SIGNAL(coordinateChanged(QGeoCoordinate)),
            this, SLOT(myLocationChanged(QGeoCoordinate)));
}
    \endcode

    Then we perform the reverse lookup in the myLocationChanged() slot. This
    looks quite similar to the original search() method, with good reason, as
    the reverse geocode lookup is simply a special kind of search call.

    \code
void MarkerManager::myLocationChanged(QGeoCoordinate location)
{
    QGeoSearchReply *reply = m_searchManager->reverseGeocode(location);
    if (reply->isFinished()) {
        reverseReplyFinished(reply);
    } else {
        revSigMap.setMapping(reply, reply);
        connect(reply, SIGNAL(finished()),
                &revSigMap, SLOT(map()));
        connect(&revSigMap, SIGNAL(mapped(QObject*)),
                this, SLOT(reverseReplyFinished(QObject*)));
    }
}
    \endcode

    As before, we use a QSignalMapper and a slot taking a QObject* parameter
    to handle the replies, but this time we only extract the first result and
    set the address of the myLocation marker:

    \code
void MarkerManager::reverseReplyFinished(QObject *obj)
{
    QGeoSearchReply *reply = dynamic_cast<QGeoSearchReply*>(obj);
    Q_ASSERT(reply != NULL);

    if (reply->places().size() > 0) {
        QGeoPlace place = reply->places().first();
        m_myLocation->setAddress(place.address());
    }

    reply->deleteLater();
}
    \endcode

    However, this isn't going to work very well with a GPS updating myLocation
    on a regular basis and a slow network connection, as the requests
    will pile up and the geocoded coordinates will lag behind the reported
    ones by quite a margin. A simple scheme to solve this relies only
    on two boolean flags:

    \code
class MarkerManager : public QObject
{
    ...
private:
    ...
    // a reverse geocode request is currently running
    bool revGeocodeRunning;
    // a request is currently running, and my location has changed
    // since it started (ie, the request is stale)
    bool myLocHasMoved;
};

void MarkerManager::myLocationChanged(QGeoCoordinate location)
{
    if (revGeocodeRunning) {
        myLocHasMoved = true;
    } else {
        QGeoSearchReply *reply = m_searchManager->reverseGeocode(location);
        myLocHasMoved = false;

        if (reply->isFinished()) {
            revGeocodeRunning = false;
            reverseReplyFinished(reply);
        } else {
            revGeocodeRunning = true;

            // <mapping and slots as before>
        }
    }
}

void MarkerManager::reverseReplyFinished(QObject *obj)
{
    QGeoSearchReply *reply = dynamic_cast<QGeoSearchReply*>(obj);
    Q_ASSERT(reply != NULL);

    // <set address as before>

    revGeocodeRunning = false;
    if (myLocHasMoved)
        myLocationChanged(m_myLocation->coordinate());

    reply->deleteLater();
}
    \endcode

    A reverse geocode request is only sent if the previous one has
    finished -- if it hasn't finished, a flag is set so that the location
    will be refreshed at the conclusion of the previous request. This is
    far from a perfect scheme, but in practise it works quite well.

    At the end of part 2 now, we have a searchable map with a simple GUI,
    clickable markers, the ability to limit search radius about our location,
    and reverse geocoding to work out the address of where we are. This is
    already quite a bit of useful functionality, but we will continue to
    extend it further.

    In part 3, we will add support for using platform positioning methods such
    as GPS, and in part 4 we will add the ability to fetch directions to a given
    destination. Finally, in part 5 we will add kinetic scrolling and cover a
    number of points about means for achieving better performance on mobile
    platforms.
*/

/*!
    \page tutorials-mapsnavigator-part3.html
    \example tutorials/mapsnavigator/part3
    \title Part 3 - Listening to satellites

    Another useful part of the Location API is the ability to receive updates
    of the user's present geographic location from methods such as GPS or
    network positioning. We're going to add support to our MapsNavigator for
    using these methods to update the "my location" marker we've already
    added in parts 1 and 2 of this tutorial.
    
    But first we need an attractive way to present status messages to the user
    while they are busy looking at the map. We're going to do this using an
    animated translucent rectangle at the bottom of the display.
    
    \section2 Animated status bar
    
    First, set up the map to resize automatically:
    
    \code
class MapsWidget : public QWidget
{
    ...
private:
    void resizeEvent(QResizeEvent *event);
    void showEvent(QShowEvent *event);
};

void MapsWidget::resizeEvent(QResizeEvent *event)
{
    if (graphicsView && geoMap) {
        graphicsView->resize(size());
        geoMap->resize(size());
        graphicsView->centerOn(geoMap);
    }
}

void MapsWidget::showEvent(QShowEvent *event)
{
    if (graphicsView && geoMap) {
        graphicsView->resize(size());
        geoMap->resize(size());
        graphicsView->centerOn(geoMap);
    }
}
    \endcode
    
    And now we add our new StatusBarItem class:
    
    \code
class StatusBarItem : public QObject, public QGraphicsRectItem
{
    Q_OBJECT
    Q_PROPERTY(int offset READ offset WRITE setOffset)

public:
    StatusBarItem();
    ~StatusBarItem();

    inline int offset() const { return m_offset; }
    void setRect(qreal x, qreal y, qreal w, qreal h);

public slots:
    void setText(QString text);

    void showText(QString text, quint32 timeout=3000);
    void show();
    void hide();

    void setOffset(int offset);

private:
    int m_offset;
    QGraphicsSimpleTextItem *textItem;
};
    \endcode
    
    Note that the order of base classes here is very important: QObject
    and then QGraphicsRectItem. Re-ordering the base classes will cause
    the code not to compile, as QGraphicsRectItem does not have a
    meta-object (for more details consult the documentation in Qt).
    
    The \a offset property here is added so that when we come to animating
    our status bar, we can handle the case where the bar is sliding in
    and the window is being resized simultaneously. If we simply animated
    the \a y property of the GraphicsItem instead we would have difficulty
    handling this case.
    
    Now add a pointer to one of these in MapsWidget:
    
    \code
class MapsWidget : public QWidget
{
    ...
private:
    StatusBarItem *m_statusBar;
};
    \endcode
    
    And we're ready for the implementation. The constructor is not terribly
    exciting, but sets the defaults for everything:
    
    \code
StatusBarItem::StatusBarItem() :
    m_offset(0)
{
    setPen(QPen(QBrush(), 0));
    setBrush(QBrush(QColor(0,0,0,120)));

    textItem = new QGraphicsSimpleTextItem(this);
    textItem->setBrush(QBrush(Qt::white));

    setText("");
}
    \endcode
    
    The \a setText function, however, is more interesting;
    
    \code
void StatusBarItem::setText(QString text)
{
    textItem->setText(text);
    QRectF rect = textItem->boundingRect();
    QPointF delta = this->rect().center() - rect.center();
    textItem->setPos(delta.x(), delta.y());
}
    \endcode
    
    This re-centers the \a textItem inside its parent (the StatusBarItem)
    every time the text changes.
    
    Also, the \a setRect method is used to update the size and position of
    the status bar:
    
    \code
void StatusBarItem::setRect(qreal x, qreal y, qreal w, qreal h)
{
    QGraphicsRectItem::setRect(x, y + m_offset, w, h);
    setText(textItem->text());
}
    \endcode
    
    Here we see the use of the \a offset property for the first time. The
    idea is to call \a setRect to specify a rectangle that is below
    the bottom of the visible area in the QGraphicsView. Then \a offset
    is used to bump the status bar up into the visible area when needed.
    
    Whenever we change the offset we should re-calculate our own \a y
    value using the rect and the offset together:
    
    \code
void StatusBarItem::setOffset(int offset)
{
    this->setY(this->y() - m_offset + offset);
    m_offset = offset;
}
    \endcode
   
    And now finally, the animations:
    
    \code
void StatusBarItem::show()
{
    QPropertyAnimation *anim = new QPropertyAnimation(this, "offset");
    anim->setStartValue(0);
    anim->setEndValue(-1 * rect().height());
    anim->setDuration(500);
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}

void StatusBarItem::hide()
{
    QPropertyAnimation *anim = new QPropertyAnimation(this, "offset");
    anim->setStartValue(m_offset);
    anim->setEndValue(0);
    anim->setDuration(500);
    anim->start(QAbstractAnimation::DeleteWhenStopped);
}
    \endcode
    
    You can see here that we simply use QPropertyAnimations on the \a offset
    property we just defined. This produces a nice linear slide in and out
    whenever \a show() or \a hide() are called.
    
    Lastly, one convenience method:
    
    \code
void StatusBarItem::showText(QString text, quint32 timeout)
{
    setText(text);
    show();
    QTimer::singleShot(timeout, this, SLOT(hide()));
}
    \endcode
    
    This lets us more easily display a status message when we only want it
    to appear and disappear soon afterwards.
    
    Then we have only to add this into our MapsWidget:
    
    \code
void MapsWidget::initialize(QGeoMappingManager *manager)
{
    QGraphicsScene *sc;
    ...
    m_statusBar = new StatusBarItem;
    sc->addItem(m_statusBar);
}

void MapsWidget::resizeEvent(QResizeEvent *event)
{
    if (graphicsView && geoMap) {
        ...
        m_statusBar->setRect(0, height(), width(), 20);
    }
}

// and similarly in MapsWidget::showEvent()
    \endcode

    \section2 Getting GPS data
    
    Now we move on to the focus of this section: GPS data and how to get it.
    The QGeoPositionInfoSource class gives a convenient interface to
    receive position updates. We're going to add one to our MainWindow:
    
    \code
class MainWindow : public QMainWindow
{
private:
    QGeoPositionInfoSource *positionSource;
    
private slots:
    // slot to receive updates
    void updateMyPosition(QGeoPositionInfo info);
};
    \endcode
    
    And in \a initialize() we'll set it up:
    
    \code
void MainWindow::initialize()
{
    ...
    if (positionSource)
        delete positionSource;

    positionSource = QGeoPositionInfoSource::createDefaultSource(this);

    if (!positionSource) {
        mapsWidget->statusBar()->showText("Could not open GPS", 5000);
        mapsWidget->setMyLocation(QGeoCoordinate(-27.5796, 153.1));
    } else {
        positionSource->setUpdateInterval(1000);
        connect(positionSource, SIGNAL(positionUpdated(QGeoPositionInfo)),
                this, SLOT(updateMyPosition(QGeoPositionInfo)));
        positionSource->startUpdates();
        mapsWidget->statusBar()->showText("Opening GPS...");
    }
}
    \endcode
    
    Here we make use of the StatusBarItem

*/

/*!
    \page tutorials-mapsnavigator-part4.html
    \example tutorials/mapsnavigator/part4
    \title Part 4 - Stopping for directions


*/

/*!
    \page tutorials-mapsnavigator-part5.html
    \example tutorials/mapsnavigator/part5
    \title Part 5 - Kinetic panning and tuning for mobile

    \code
class MapsWidget : public QWidget
{
    ...
private:
    void resizeEvent(QResizeEvent *event);
    ...
};

void MapsWidget::initialize(QGeoMappingManager *manager)
{
    ...
    geoMap->resize(this->size());

    graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

    graphicsView->resize(this->size());
    
    ...
}

void MapsWidget::resizeEvent(QResizeEvent *event)
{
    if (graphicsView && geoMap) {
        graphicsView->resize(event->size());
        geoMap->resize(event->size());
    }
}
    \endcode

*/