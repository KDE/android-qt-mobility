/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial Usage
** Licensees holding valid Qt Commercial licenses may use this file in
** accordance with the Qt Commercial License Agreement provided with the
** Software or, alternatively, in accordance with the terms contained in a
** written agreement between you and Nokia.
**
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of this
** file.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \page tutorials-mapsnavigator.html
    \title Maps Navigator Tutorial
    
    \brief An introduction to the Location API, showing how to develop a simple
           map search and navigation application.
    
    In this tutorial, you will learn about the basic components of the Location
    API, including
    
    \list
    \o items
    \o here...
    \endlist
    
    We will be developing the map search and navigation application shown below:
    
    \image mapsnavigator-finished.png
    
    Tutorial contents:
    
    \list 1
    \o \l{tutorials/mapsnavigator/part1}{The Map Widget}
    \o \l{tutorials/mapsnavigator/part2}{Searching for locations}
    \endlist
    
    Some more text goes here.
*/

/*!
    \page tutorials-mapsnavigator-part1.html
    \example tutorials/mapsnavigator/part1
    \title Part 1 - The Map Widget
    
    To begin with, we will start defining the map widget, which is the central part of
    the application's user interface. Enough of the map widget will be defined here to
    work satisfactorily on most desktop platforms -- full consideration for mobile use
    will be made later along with other parts of the application.
    
    \section2 The very basics
    
    The Location module provides the QGraphicsGeoMap which is a simple, easy way to insert
    maps into a QGraphicsScene. Since we're going to be extending the map later, we'll
    create a subclass of QGraphicsGeoMap called \c GeoMap, as below:
    
    \code
class GeoMap : public QGraphicsGeoMap
{
    Q_OBJECT
    
public:
    GeoMap(QGeoMappingManager *manager, MapsWidget *mapsWidget);

private:
    MapsWidget *m_mapsWidget;
};

GeoMap::GeoMap(QGeoMappingManager *manager, MapsWidget *mapsWidget) :
    QGraphicsGeoMap(manager), m_mapsWidget(mapsWidget)
{
}
    \endcode
    
    And next we define a QWidget subclass, MapsWidget, which handles the creation of
    QGraphicsView and QGraphicsScene to put the GeoMap into:
    
    \code
class MapsWidget : public QWidget
{
    Q_OBJECT

public:
    MapsWidget(QWidget *parent = 0);
    ~MapsWidget();

public slots:
    void initialize(QGeoMappingManager *manager);

private:
    GeoMap *geoMap;
    QGraphicsView *graphicsView;
};
    \endcode
    
    We perform the creation of the QGraphicsScene and GeoMap in the initialize() method:
    
    \code
void MapsWidget::initialize(QGeoMappingManager *manager)
{
    geoMap = new GeoMap(manager, this);

    QGraphicsScene *sc = new QGraphicsScene;
    sc->addItem(geoMap);

    geoMap->resize(300, 480);

    graphicsView = new QGraphicsView(sc, this);
    graphicsView->setVisible(true);
    graphicsView->setInteractive(true);

    geoMap->setCenter(QGeoCoordinate(-27.5796, 153.1));
    geoMap->setZoomLevel(15);
}
    \endcode
    
    Doing this in the constructor, while possible, is not the preferred approach, as
    the QGeoMappingManager may not be available until the user has chosen it, or until a
    network connection is available. This is especially important in mobile
    environments, as we'll see later.
    
    To get an instance of QGeoMappingManager we use the list of service providers
    available in QGeoServiceProvider::availableServiceProviders(). Service providers
    provide the ability to fetch and draw maps, search for locations, get directions,
    and a variety of other tasks.
    
    To test out the MapsWidget we just wrote, we can simply get the first available
    service provider in the main() function, as follows:
    
    \code
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MapsWidget w;
    w.show();

    QList<QString> providers = QGeoServiceProvider::availableServiceProviders();
    QGeoServiceProvider *serviceProvider = new QGeoServiceProvider(providers[0]);

    w.initialize(serviceProvider->mappingManager());

    return a.exec();
}
    \endcode
    
    If you compile and run the code so far, you should see a window appear containing
    a street map of Eight Mile Plains, in Queensland, Australia, rendered by your
    platform's default geo service provider.
    
    \image mapsnavigator-verybasic.png
    
    \section2 Pan & zoom
    
    Next we'll add some basic pan and zoom capability to the map widget. Like most other
    classes in Qt, QGraphicsGeoMap allows mouse and keyboard events to be handled by
    private methods.
    
    Into the private section of the GeoMap declaration we add:
    \code
bool panActive;

void mousePressEvent(QGraphicsSceneMouseEvent *event);
void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
    \endcode
    
    And their definitions:
    
    \code
void GeoMap::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = true;
    event->accept();
}

void GeoMap::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    panActive = false;
    event->accept();
}

void GeoMap::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    if (panActive) {
        QPointF delta = event->lastPos() - event->pos();
        pan(delta.x(), delta.y());
    }
    event->accept();
}
    \endcode
    
    These three short methods are enough to add basic panning support to the map.
    The panning method is a simple mouse-locked one, and moving long distances on
    a touch screen with it can get quite tedious. Many map applications now make
    use of "kinetic" panning for a better user experience, especially on touch
    devices, and we'll implement support for that later.
    
    Next, to add zoom support on the mouse scrollwheel:
    
    \code
void GeoMap::wheelEvent(QGraphicsSceneWheelEvent *event)
{
    qreal panx = event->pos().x() - size().width() / 2.0;
    qreal pany = event->pos().y() - size().height() / 2.0;
    pan(panx, pany);
    if (event->delta() > 0) {   // zoom in
        if (zoomLevel() < maximumZoomLevel()) {
            setZoomLevel(zoomLevel() + 1);
        }
    } else {                    // zoom out
        if (zoomLevel() > minimumZoomLevel()) {
            setZoomLevel(zoomLevel() - 1);
        }
    }
    pan(-panx, -pany);
    event->accept();
}
    \endcode
    
    This method is a little more complicated. To provide a suitable zoom feel, we
    have to actually combine panning with zooming, so that the user's point of
    interest (the mouse cursor) remains in the same part of the view. So, we
    actually pan the mouse cursor's location into the center, then adjust
    the zoom level, then pan back at the end.
    
    \section2 Map icons
    
    Another important basic feature is the ability to render icons on the map to
    represent points of interest. The QGeoMapPixmapObject class provides most of 
    the functionality necessary to achieve this, and we'll use a subclass of it
    in similar vein to our GeoMap, above.
    
    For our application, we need to deal with 6 different kinds of icons:
    \list
    \o A "my location" icon
    \o "Search" icons for search results
    \o User waypoints for direction routes
    \o Start points for directions
    \o End points for directions
    \o "Path" markers for individual steps in the direction route
    \endlist
    
    \code
class Marker : public QGeoMapPixmapObject
{
    Q_OBJECT
public:
    enum MarkerType {
        MyLocationMarker,
        SearchMarker,
        WaypointMarker,
        StartMarker,
        EndMarker,
        PathMarker
    };

    explicit Marker(MarkerType type);

    inline MarkerType markerType() const { return m_type; }
    void setMarkerType(MarkerType type);

private:
    MarkerType m_type;

};
    \endcode
    
    So we can construct Marker instances of different types, but we need QPixmaps
    to represent each one. In our implementation we will simply use a \c switch
    statement to map MarkerTypes to QPixmaps.
    
    \code
Marker::Marker(MarkerType type) :
    QGeoMapPixmapObject()
{
    setMarkerType(type);
}

void Marker::setMarkerType(MarkerType type)
{
    QString filename;
    QPoint offset;
    int scale;

    m_type = type;

    switch (m_type) {
    case MyLocationMarker:
        filename = ":/icons/mylocation.png";
        break;
    case SearchMarker:
        filename = ":/icons/searchmarker.png";
        break;
    case WaypointMarker:
        filename = ":/icons/waypointmarker.png";
        break;
    case StartMarker:
        filename = ":/icons/startmarker.png";
        break;
    case EndMarker:
        filename = ":/icons/endmarker.png";
        break;
    case PathMarker:
        filename = ":/icons/pathmarker.png";
        break;
    }

    if (m_type == MyLocationMarker) {
        offset = QPoint(-13,-13);
        scale = 25;
    } else {
        offset = QPoint(-15, -36);
        scale = 30;
    }

    setOffset(offset);
    setPixmap(QPixmap(filename).scaledToWidth(scale, Qt::SmoothTransformation));
}
    \endcode
    
    The icon PNG images can be found in the \c examples/mapsnavigator/icons
    directory in the Qt Mobility distribution. All we have to do to have this
    working is simply add the PNG icons to a \c .qrc file and add it to the 
    project.
    
    The QGraphicsGeoMap::addMapObject method is used to add markers to a map.
    We can add a call to create a marker at our starting point into 
    MapsWidget::initialize() as a demonstration:
    
    \code
// in MapsWidget::initialize()
Marker *me = new Marker(Marker::MyLocationMarker);
me->setCoordinate(QGeoCoordinate(-27.5796, 153.1));
geoMap->addMapObject(me);
    \endcode
    
    Build and start the application, and we now have a "My Location" icon in
    the centre of the initial view.
    
    This now concludes the basic functionality of the map widget. We'll be
    making a few modifications and improvements to it as we go along, but
    the basic skeleton will remain the same.
    
    Next, we'll add a basic GUI around the map widget, and the ability
    to search for locations like addresses.
*/

/*!
    \page tutorials-mapsnavigator-part2.html
    \example tutorials/mapsnavigator/part2
    \title Part 2 - Searching for locations
    
    Now that we have a basic map widget, we want to add the capability
    to search for addresses and locations and create markers for them
    on the map.
    
    \section2 Search classes
    
    Searching in the Location API is handled by use of the QGeoSearchManager,
    which we obtain in similar fashion to the MappingManager (in main() in
    part 1). As we want to create markers for search results and then
    be able to remove them for the next search (or perhaps other operations),
    we need some way to organise collections of markers.
    
    To do this, we introduce a new class, MarkerManager:
    
    \code
class MarkerManager : public QObject
{
    Q_OBJECT
public:
    explicit MarkerManager(QGeoSearchManager *sm, QObject *parent=0);
    ~MarkerManager();

public slots:
    void setMap(QGraphicsGeoMap *map);
    void setMyLocation(QGeoCoordinate coord);
    void search(QString query);
    void removeSearchMarkers();

signals:
    void searchError(QGeoSearchReply::Error error, QString errorString);
    void searchFinished();

private:
    Marker *m_myLocation;
    QList<Marker*> searchMarkers;

    QGraphicsGeoMap *m_map;
    QGeoSearchManager *m_searchManager;
    QSignalMapper sigMap;

private slots:
    void replyFinished(QObject *reply);
};
    \endcode
    
    The MarkerManager tracks both the "My Location" marker and a list of search
    result markers. Implementing the My Location portion is nothing new:
    
    \code
MarkerManager::MarkerManager(QGeoSearchManager *searchManager, QObject *parent) :
    QObject(parent),
    m_searchManager(searchManager)
{
    m_myLocation = new Marker(Marker::MyLocationMarker);
}

MarkerManager::~MarkerManager()
{
    m_map->removeMapObject(m_myLocation);
    delete m_myLocation;
    ...
}

void MarkerManager::setMap(QGraphicsGeoMap *map)
{
    ...
    map->addMapObject(m_myLocation);
    ...
}

void MarkerManager::setMyLocation(QGeoCoordinate coord)
{
    m_myLocation->setCoordinate(coord);
}
    \endcode
    
    To implement searching, we call the QGeoSearchManager::search method, which
    returns a QGeoSearchReply. This reply object emits a signal finished() when
    the search results are available. It can also be constructed already
    finished, and we need to check for this first before connecting the signals.
    
    Since we'd like to have one general slot that handles both the pre-finished
    and the signal case, we give the slot a QObject* parameter and make use of
    QSignalMapper:
    
    \code
void MarkerManager::search(QString query)
{
    QGeoSearchReply *reply = m_searchManager->search(query);
    if (reply->isFinished()) {
        replyFinished(reply);
    } else {
        sigMap.setMapping(reply, reply);
        connect(reply, SIGNAL(finished()),
                &sigMap, SLOT(map()));
        connect(&sigMap, SIGNAL(mapped(QObject*)),
                this, SLOT(replyFinished(QObject*)));

        connect(reply, SIGNAL(error(QGeoSearchReply::Error,QString)),
                this, SIGNAL(searchError(QGeoSearchReply::Error,QString)));
    }
}
    \endcode
    
    The QGeoSearchReply yields its results as a list of QGeoPlace instances.
    While these hold quite a bit of information, for now we'll just be using
    them for their coordinates.
    
    \code
void MarkerManager::replyFinished(QObject *obj)
{
    QGeoSearchReply *reply = dynamic_cast<QGeoSearchReply*>(obj);
    Q_ASSERT(reply != NULL);

    // generate the markers and add them to the map
    foreach (QGeoPlace place, reply->places()) {
        Marker *m = new Marker(Marker::SearchMarker);
        m->setCoordinate(place.coordinate());
        searchMarkers.append(m);

        if (m_map) {
            m_map->addMapObject(m);
            // also zoom out until marker is visible
            while (!m_map->viewport().contains(place.coordinate()))
                m_map->setZoomLevel(m_map->zoomLevel()-1);
        }
    }

    reply->deleteLater();

    emit searchFinished();
}
    \endcode
    
    Next, we add two methods to MapsWidget to keep track of a MarkerManager
    instance associated with its map:
    
    \code
class MapsWidget : public QWidget
{
    ...
public:
    void setMarkerManager(MarkerManager *markerManager);
    MarkerManager *markerManager() const;

    ...
private:
    MarkerManager *m_markerManager;
    ...
};
    \endcode
    
    And then add two small sections of code to connect them together:
    
    \code
void MapsWidget::initialize(QGeoMappingManager *manager)
{
    geoMap = new GeoMap(manager, this);
    if (m_markerManager)
        m_markerManager->setMap(geoMap);
    ...
}

void MapsWidget::setMarkerManager(MarkerManager *markerManager)
{
    m_markerManager = markerManager;
    if (geoMap)
        markerManager->setMap(geoMap);
}
    \endcode
    
    Now we have basic search capability added to our code. But we still
    have no GUI to drive it, and so we'll focus on that in the next section.
    
    \section2 GUI with search dialog
    
    Next we'll build a GUI around our map widget and add a search dialog to
    make use of the code we just wrote. Our finished GUI looks like this:
    
    \image mapsnavigator-searchgui.png
    
    We won't cover building the GUI in too much detail (that being the
    subject of other tutorials), but the complete code is in the finished
    MapsNavigator example in the Qt Mobility distribution.
    
    Our GUI consists of a QMainWindow containing our MapsWidget and a QMenuBar.
    On the QMenuBar is an option for zooming to the current "My Location", and
    a menu for performing search operations.
    
    Also part of the GUI is the dialog box displayed when selecting "Search
    for address or name" -- this is a simple QDialog subclass with a QFormLayout
    and a QDialogButtonBox.
    
    In the MainWindow constructor, we simply set up the menubar and MapsWidget
    and other UI details. All initialization of Location-based details are in
    the MainWindow::initialize() slot. For the moment, we will simply assume
    that initialize() is called directly from the constructor (the purpose of
    this decoupling will be explained later).
    
    \code
void MainWindow::initialize()
{
    if (serviceProvider)
        delete serviceProvider;

    QList<QString> providers = QGeoServiceProvider::availableServiceProviders();
    if (providers.size() < 1) {
        QMessageBox::information(this, tr("Maps Navigator"),
                                 tr("No service providers are available"));
        QCoreApplication::quit();
        return;
    }

    serviceProvider = new QGeoServiceProvider(providers[0]);
    if (serviceProvider->error() != QGeoServiceProvider::NoError) {
        QMessageBox::information(this, tr("Maps Navigator"),
                                 tr("Error loading geoservice plugin: %1").arg(providers[0]));
        QCoreApplication::quit();
        return;
    }

    mapsWidget->initialize(serviceProvider->mappingManager());
    markerManager = new MarkerManager(serviceProvider->searchManager());
    mapsWidget->setMarkerManager(markerManager);

    connect(markerManager, SIGNAL(searchError(QGeoSearchReply::Error,QString)),
            this, SLOT(showErrorMessage(QGeoSearchReply::Error,QString)));

    mapsWidget->setMyLocation(QGeoCoordinate(-27.5796, 153.1));
}
    \endcode
    
    As you can see, this performs more or less the same actions as our old
    code in main() from part 1 of the tutorial did. It fetches the first
    available service provider, then initializes the MapsWidget and
    MarkerManager using the appropriate Manager instances.
    
    Additionally, we've added a setMyLocation() method to MapsWidget which
    simply calls the current MarkerManager's method of the same name, plus
    centreing the view on the marker.
    
    The "Search for address or name" menu item sets off the showSearchDialog()
    slot:
    
    \code
void MainWindow::showSearchDialog()
{
    SearchDialog sd;
    if (sd.exec() == QDialog::Accepted) {
        if (markerManager) {
            markerManager->removeSearchMarkers();
            markerManager->search(sd.searchTerms());
        }
    }
}
    \endcode
    
    Which uses the methods on MarkerManager that we defined previously. So now
    we have a basic searchable mapping application. However, there is one big
    piece of functionality missing for a searchable map: consider if we had
    a provider that allowed us to search for local businesses. We might type
    in a business name in the Search dialog and press OK, and then be presented
    with tens or hundreds of businesses that match the name we typed from all
    around the world. Some of these results might not even be the kind of
    business we were looking for (partial text matches etc).
    
    This can be solved with the addition of two key features: viewing the extra
    details about search results that we're currently throwing away; and adding
    the ability to limit the search area.
    
    \section2 Adding details to search markers
    
    First up, we'll add some additional properties to the Marker class:
    
    \code
class Marker : public QGeoMapPixmapObject
{
    ....
public:
    inline QString name() const { return m_name; }
    inline void setName(QString name) { m_name = name; }

    inline bool moveable() const { return m_moveable; }
    inline void setMoveable(bool moveable) { m_moveable = moveable; }
    
private:
    ...
    QString m_name;
    bool m_moveable;
};
    \endcode
    
    And add code to MarkerManager to set them from search results:
    
    \code
void MarkerManager::replyFinished(QObject *obj)
{
    ...
    foreach (QGeoPlace place, reply->places()) {
        Marker *m = new Marker(Marker::SearchMarker);
        m->setCoordinate(place.coordinate());
        m->setName(QString("%1, %2").arg(place.address().street())
                                    .arg(place.address().city()));
        m->setMoveable(false);
        searchMarkers.append(m);
	...
    \endcode
    
    So now the data is available from the Marker objects. We want to show
    this to the user somehow, though, and the best means of doing this is
    probably a dialog box. We're going to do a dialog box that appears when
    the user clicks a marker, so we'll have to add click detection to
    MapsWidget and GeoMap, first.
    
    We already have methods for handling mouse presses and releases over
    the map widget, so we will modify these. Add two private fields to GeoMap:
    
    \code
class GeoMap : public QGraphicsGeoMap
{
    ...
private:
    ...
    bool markerPressed;
    QGeoMapObject *pressed;
    ...
};
    \endcode
    
    
*/