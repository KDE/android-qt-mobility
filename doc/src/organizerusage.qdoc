/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial Usage
** Licensees holding valid Qt Commercial licenses may use this file in
** accordance with the Qt Commercial License Agreement provided with the
** Software or, alternatively, in accordance with the terms contained in a
** written agreement between you and Nokia.
**
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of this
** file.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\page organizerusage.html

\title Organizer API Usage

\tableofcontents

\section1 Introduction

This section provides some examples of common usage of the Qt Organizer API.

\section1 Manager Settings And Configuration

Users of the items API can define which backend they wish to access if a
manager for that backend is available.  The list of available managers can be
queried programmatically at run-time, and the capabilities of different
managers can be ascertained by inspecting a QOrganizerItemManager instance.
Furthermore, some managers can be constructed with parameters which affect the
operation of the backend.  In this example, the client constructs a particular
backend, but does not construct it with any special parameters:

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Instantiating a specific manager

Most users of the API will want to use the default manager for the platform,
which provides access to the system address book.  Instantiating a manager by
using the default constructor will result in the default manager for that
platform being instantiated:

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Instantiating the default manager for the platform

The default constructor can either be used to create a manager on the stack,
in which case it will be deleted automatically when it goes out of scope,
or it can be used explicitly to create a manager on the heap, in which case
the client must ensure that they delete the manager when they are finished
with it in order to avoid a memory leak.

\section2 Querying a manager for capabilities

Different managers will support different capabilities and details.  Clients
can use the meta data reporting functions of QOrganizerItemManager to determine what
the capabilities of the manager they have instantiated might be.

\section2 Loading the manager for a specific backend

The client can choose to load a manager for a specific backend.  While
the engine could be found and retrieved using a more advanced plugin framework
(such as the Qt Service Framework), this code assumes that the client has
prior knowledge of the backend in question:

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Instantiating a specific manager

Clients may wish to use this feature of the API if they wish to store or
retrieve item information to a particular manager (for example, one that
interfaces with a particular online service).

\section2 Loading a manager with specific parameters

The client can loads a manager with specific parameters defined.  The
parameters which are available are backend specific, and so the client has
to know which parameters are valid for a particular backend,
and what argument it takes.

\section1 Organizer Item Detail Manipulation

Once an item has been created (or retrieved from a manager), the client can
retrieve, create, update or delete details from the item.  Since QOrganizerItem
and QOrganizerItemDetail are both container (value) classes, the API offered for
these operations is purely synchronous.

An item consists of the details it contains, as well as an id.  Some details
are read-only (such as the modification timestamp of an item) or irremovable (like
the type of an item), but most are freely modifiable by clients.  The
QOrganizerItem::details(), QOrganizerItem::detail(),
QOrganizerItem::saveDetail() and QOrganizerItem::removeDetail() functions can be
used to manipulate these details.

To aid in the manipulation of common details, convenience functions are provided
in QOrganizerItem like setDisplayLabel() and setDescription() which set and
access the details directly.  Many details are specific to particular types of
items, and convenience functions for these are provided in the subclasses of
QOrganizerItem.  For example, the QOrganizerEvent class provides the function
setStartDateTime(), which is equivalent to getting the QOrganizerEventTimeRange
detail, setting the StartDateTime field and resaving it.

It is important to note that details are implicitly shared objects with
particular semantics surrounding saving, removal and modification.

\section1 Persistent Organizer Item Information

After instantiating a manager, clients will wish to retrieve or modify item
information (detail definitions) which is persistently stored in the manager
(for example, in a database or online cloud).  This may be done synchronously
or asynchronously.  And example of synchronous usage is as follows:

If the client wishes to use the asynchronous API, it is suggested that their
class uses member variables for the manager and requests.  This allows them
to define slots which deal with the data as required when the
state of the request changes.

Note that if the client is interested in receiving the results of the request
as they become available, rather than only the final set of results once the
request changes state (to \c FinishedState, for example), the client should
instead connect the QOrganizerItemAbstractRequest::resultsAvailable() signal to the
slot which deals with the results.

\section2 Creating a new item in a manager

Clients can create a new item simply by instantiating one and saving it a manager.
The save operation will succeed if the item initially had a zero-id, and
if the manager supports the details in the item.  The item may be saved
either synchronously by directly calling QOrganizerItemManager::saveItem() or
asynchronously using a QOrganizerItemSaveRequest and connecting to that request's
change signals.  Alternatively, the client can explicitly block execution until the request is
complete, by calling waitForFinished().

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Creating a non-recurrent entry

\section2 Retrieving items from a manager

The client requests all items from the manager which match a particular
filter, sorted according to a particular sort order.

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Retrieving any entry (not occurrence) which matches a search criteria

The client can also retrieve a particular existing item from a manager, by
directly requesting the item with a particular (previously known) id.
With the asynchronous API, this takes the form of another filter.
The synchronous API provides the QOrganizerItemManager::item() function specifically for this purpose.

Some items which clients are interested in may not be explicitly stored in the manager,
but rather dynamically generated given a recurrence rule which is saved in a particular
item.  These are known as occurrences and may be retrieved by calling itemInstances().
Once retrieved, a generated occurrence may be saved into the manager, at which point it
becomes an exception to the original item.

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Creating an exception to a particular recurrent event

\section2 Updating an existing item in a manager

The client updates a previously saved item by saving the updated version of
the item.  Any item whose id is the same as that of the updated item
will be overwritten as a result of the save request.

    \snippet snippets/qtorganizerdocsample/qtorganizerdocsample.cpp Editing a non-recurrent entry

\section2 Removing an item from a manager

The client may remove an item from the manager by specifying its local id.

\section2 Optimization in item retrieval

Clients can inform the manager that they do not require certain details from
an item, which can allow a manager to optimize item retrieval.
In this way, the client can inform the manager that they are
not interested in any binary blob data (e.g., images) in retrieved items.

\section2 Querying the schema supported by a manager

A client may query the schema supported by a manager, and check to see if a
particular detail definition supports a certain field.

\section2 Modifying the schema supported by a manager

A client may attempt to modify a particular detail definition by extending it
so that it supports an extra field, or add a new detail definition, or
remove an existing one.  These operations are not necessarily supported on
various backends, and even those backends which do support a mutable schema
may not allow modification of the default detail definitions.

Note that some managers do not support mutable definitions, and hence
attempting to modify or remove detail definitions in those managers will fail.

\section1 Recurring items

A recurring item is an item that occurs more than once; for example, a meeting
that occurs every week for the next 10 weeks.  A recurring item is created by
creating a QOrganizerEvent or QOrganizerTodo and adding a
QOrganizerItemRecurrence detail to it to specify the rules for when it should
recur.  While the item occurs multiple times, the client only has to create it
once and save it once.  When QOrganizerItemManager::itemInstances() is called,
any recurring items are expanded into multiple QOrganizerEventOccurrence and
QOrganizerTodoOccurrence items by the manager.  Each generated occurrence item
has a local id of zero.

The client is able to make an exception for an occurrence by taking a generated
item occurrence from the manager, making the necessary modifications, and
resaving it.  When the manager is then queried with
QOrganizerItemManager::itemInstances(), it will return the list of occurrences
as before, but with the modifications in place.  The modified item will be given
a non-zero local id, and replaces the generated one in the list.

The client can also query the manager for a list of unexpanded items by calling
QOrganizerItemManager::items().  The list of returned items will contain all
items that have been saved to the manager with a call to saveItem() (of course,
without any items removed with removeItem()).  That is, recurring events will be
returned as is, and event occurrences will not appear unless they are exceptions
(ie. have a non-zero local id).  Fetching the list in this way can be useful for
transfering items to other managers or for exporting to iCalendar with QtVersit.

\section1 Multiple organizers

It may be useful for clients to separate their organizer items into different
organizers (eg. Personal and Work) and work with different views that show items
from one, some or all of these organizers.  This is functionality has not been
implemented in this technical preview, but we currently are investigating the
best model to use to offer this.

*/
