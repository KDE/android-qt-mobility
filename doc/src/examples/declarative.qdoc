/****************************************************************************
**
** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Mobility Components.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\example declarative

\title Service Framework using QML Example

\bold {Explanation:}

This example should demonstrate how to use the Service Framework and 
access the services in a QMLContext.

\target guidesign

The GUI looks like following picture:

\image DialerServiceGUI.png "GUI"

The following picture shows the architecture of this example:

\image DialerServiceUML.png "UML"


The following steps outline how to make a QML based application 
using the Service Framework technology.
It is assumed that Qt Mobility has been
successfully built and environment variables have been set 
as per \l {Installation Guide}.

\bold {The main function:}

For the usage of several Qml objects and Service Framework we need to
prepare our main.cpp:
\list 1
    \o Include the appropriate headers
    \o Include the neccessary Qml objects header
    \o Include the Service Framework object header
\endlist

Steps 1 and 2 are shown in the example below:
\snippet declarative/main.cpp 0

We are using the QmlView header which we need to 
load the main Qml file and show the Qml site.
\snippet declarative/main.cpp 1
\snippet declarative/main.cpp 2
\snippet declarative/main.cpp 3

Furthermore we are using the QmlContext header 
which we need to add our own implemented object in the Qml context.
This means that we can create our own object and access it in a QML script file.
\target addpropertyinqmlcontext
In this case we can access our service list over the "services" property
in Qml script.
\snippet declarative/main.cpp 4

\bold {The Services:}

The services are implemented in a shared library and can be register in the service framework.
After the service is registered it can be used in different applications.
In our case we'll access the services over an application that is based on QML scripting.
We will be able to change between different services and call their properties,
receiving their signals and so forth.

In this example we've implemented 2 services called
Landdialer and Voipdialer.
You can find the projects for those services in:

declarative\\landlinedialer and declarative\\voipdialer.
Those projects will create a shared library in each case.

If the library needs to be available over the Service Framework,
we need to register the library.
You can do this by using the QServiceManager function addService(...).
In our example this will be done in the function registerExampleServices in ServiceRegister:
\snippet declarative/sfwexample.cpp 0

As you can see we register the services using a xml file.
This xml file basically contains all information to register the shared library in the 
Service Framework enviroment.
For more information please read more about the Qt Service Framework 
\l {service-frameworks.html#adding-and-removing-of-services}{XML Format}
 
The QServiceManager creates an instance of a services over a QServicePluginInterface.
For each services we provide a Plugin.
\snippet declarative/voipdialer/voipdialerplugin.h 0

The Q_INTERFACES macro tells Qt which interfaces the class implements.

Both seviceplugins needs to implement the QServicePluginInterface.
In our case we only need to overwrite the virtual function createInstance.
\snippet declarative/voipdialer/voipdialerplugin.cpp 0

As you can see the createInstance function create the appropriate dialer object
and returns it.
The Q_EXPORT_PLUGIN2 macro provides the neccessary implementation for a plugin.
See \l{How to Create Qt Plugins} for more details.

The last thing we need to provide in our services are
the states, properties, signals and slots that we
want to access in out QML script later.

\target voipdialer_h_0
\snippet declarative/voipdialer/voipdialer.h 0

\bold {The ServiceWrapper:}

The ServiceWarpper is our object that is accessible in the QML script.
Over the ServiceWrapper we can access several service details by calling the properties of the wrapper.

\snippet declarative/sfwexample.h 0

\bold {The ServiceRegister:}

The ServiceRegister contains a list of all available services they contain the com.nokia.qt.examples.Dialer interface.
In the constructor of ServiceRegister a call will be made to register the dialer services (LandLineDialer and VoipDaler)
from this example.

\snippet declarative/sfwexample.cpp 0

After this call the ServiceRegister fills it's internal ServiceWrappper QList.

\snippet declarative/sfwexample.cpp 1

In the header of ServiceRegister we allow external objects to access the ServiceWrapper QList.

\snippet declarative/sfwexample.h 1

You may remember that we add this QList to our qml context as a property named \l {addpropertyinqmlcontext}{ services} 

\bold {Service access on the QML site}

The QML elements are implemented in 4 different qml scripting files
\l {guidesign}{ see GUI design}.

In the ServiceList.qml file the services property is assigned to the ListView model property. 

\snippet declarative/ServiceList.qml 0

To show the items of the model property we need to create a delegate component and assign it to the ListView
Delegate property:

\snippet declarative/ServiceList.qml 1

In this component you can define how you want to draw one ListView item.
You can acces insite of this component the current ListWiew item by using the variable modelData.
In our example we are using two text lines. Furthermore we can define whats happening if we click
on a ListView item by using the MouseRegion.

\target ServiceList_qml_2
\snippet declarative/ServiceList.qml 2

Another component can be created for highliting a list item:

\snippet declarative/ServiceList.qml 3

\bold {Service signals and function calls on the QML site}

In sfw-kinetic-example.qml we define a control named DialScreen and implement
the function onDial and onHangup.
As you can see in the onDial event we call the service function dialNumber and
the onHangup calls hangup.
Both function are implemented in the service \l {voipdialer_h_0} { (see voipdialer header file).}

\snippet declarative/sfw-kinetic-example.qml 0

In DialScreen.qml the dial and the hangup signals are defined.
The hangup signal will be emited if the HangUpButton was clicked:

\snippet declarative/DialScreen.qml 1

The dial signal will be emited if the CallButton was clicked:

\snippet declarative/DialScreen.qml 2

Now we need to connect the stateChanged signal form the services with an event handler on the QML site.
This is done in the sfw-kinetic-example.qml file:

\snippet declarative/sfw-kinetic-example.qml 1

The DialScreen.currentDialer is assigned during a ListView item click in the
\l {ServiceList_qml_2}{ ServiceList.qml file}.

*/
