/****************************************************************************
**
** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
** All rights reserved.
** Contact: Nokia Corporation (qt-info@nokia.com)
**
** This file is part of the Qt Mobility Components.
**
** $QT_BEGIN_LICENSE:LGPL$
** No Commercial Usage
** This file contains pre-release code and may not be distributed.
** You may use this file in accordance with the terms and conditions
** contained in the Technology Preview License Agreement accompanying
** this package.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Nokia gives you certain additional
** rights.  These rights are described in the Nokia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** If you have questions regarding the use of this file, please contact
** Nokia at qt-info@nokia.com.
**
**
**
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include <QList>
#include <QString>
#include <QTextStream>
#include "qversitcontactdefaulthandlers.h"
#include "qcontact.h"
#include "qcontactdetail.h"
#include "qversitdocument.h"
#include "qversitproperty.h"

QTM_USE_NAMESPACE

QTM_BEGIN_NAMESPACE

/*
 * This is a map from Versit group names to the details that were generated from properties with the
 * said groups.  Multiple details can be associated with a single group.
 */
class DetailGroupMap
{
public:
    QList<QContactDetail> detailsInGroup(const QString& groupName) const;
    void insert(const QString& groupName, const QContactDetail& detail);
    void update(const QContactDetail& detail);
    void clear();

private:
    QHash<int, QString> mDetailGroupName; // detailid -> group name
    QHash<int, QContactDetail> mDetailById; // detailid -> detail
};

class QVersitContactImporterDefaultPropertyHandlerPrivate
{
public:
    DetailGroupMap mDetailGroupMap; // remembers which details came from which groups
};

class QVersitContactExporterDefaultDetailHandlerPrivate
{
public:
    QVersitContactExporterDefaultDetailHandlerPrivate();
    int mDetailNumber;
};

QTM_END_NAMESPACE

/*
 * Returns a list of details generated from a Versit group.
 */
QList<QContactDetail> DetailGroupMap::detailsInGroup(const QString& groupName) const
{
    QList<int> detailIds = mDetailGroupName.keys(groupName);
    QList<QContactDetail> details;
    foreach (int detailId, detailIds) {
        details << mDetailById[detailId];
    }
    return details;
}

/*
 * Inserts the association between \a detail and \a groupName to the map.
 * The detail must have a key (ie. have already been saved in a contact) and the group name must not
 * be the empty string.
 */
void DetailGroupMap::insert(const QString& groupName, const QContactDetail& detail)
{
    Q_ASSERT(!groupName.isEmpty());
    mDetailGroupName[detail.key()] = groupName;
    mDetailById[detail.key()] = detail;
}

/*
 * Replaces the detail currently in the map with \a detail.
 * The detail must have a key (ie. have already been saved in a contact).
 */
void DetailGroupMap::update(const QContactDetail& detail)
{
    Q_ASSERT(detail.key());
    mDetailById[detail.key()] = detail;
}

/*!
 * Removes details and groups from the map.
 */
void DetailGroupMap::clear()
{
    mDetailGroupName.clear();
    mDetailById.clear();
}

/*!
  \class QVersitContactImporterDefaultPropertyHandler
  \brief The QVersitContactImporterDefaultPropertyHandler class provides a default implementation of a
  QVersitContactImporterPropertyHandlerV2

  This handler decodes properties generated by QVersitContactExporterDefaultDetailHandler.

  Clients wishing to implement their own property handler and also benefit from the functionality of
  the default handler can inherit from QVersitContactImporterDefaultPropertyHandler.  In the
  implementation of propertyProcessed and documentProcessed, the respective functions in the default
  handler should be called as the last step.

  \sa QVersitContactImporterPropertyHandlerV2, QVersitContactImporter
 */

/*!
 * Constructs a QVersitContactImporterDefaultPropertyHandler.
 */
QVersitContactImporterDefaultPropertyHandler::QVersitContactImporterDefaultPropertyHandler()
    : d(new QVersitContactImporterDefaultPropertyHandlerPrivate())
{
}

/*!
  \reimp
 */
void QVersitContactImporterDefaultPropertyHandler::propertyProcessed(
        const QVersitDocument& document,
        const QVersitProperty& property,
        bool alreadyProcessed,
        const QContact& contact,
        QList<QContactDetail>* updatedDetails)
{
    Q_UNUSED(document)
    Q_UNUSED(contact)
    QString group;
    if (!property.groups().isEmpty())
        group = property.groups().first();
    if (!alreadyProcessed) {
        if (property.name() != QLatin1String("X-NOKIA-QCONTACTFIELD"))
            return;
        if (property.groups().size() != 1)
            return;
        QMultiHash<QString,QString> parameters = property.parameters();
        QString definitionName = parameters.value(QLatin1String("DETAIL"));
        QString fieldName = parameters.value(QLatin1String("FIELD"));

        // Find a detail previously seen with the same definitionName, which was generated from
        // a property from the same group
        QContactDetail detail(definitionName);
        foreach (const QContactDetail& previousDetail, d->mDetailGroupMap.detailsInGroup(group)) {
            if (previousDetail.definitionName() == definitionName) {
                detail = previousDetail;
            }
        }
        // If not found, it's a new empty detail with the definitionName set.

        // Import the field
        if (parameters.contains(QLatin1String("DATATYPE"), QLatin1String("V"))) {
            // The value was stored as a QVariant serialized in a QByteArray
            QDataStream stream(property.variantValue().toByteArray());
            QVariant value;
            stream >> value;
            detail.setValue(fieldName, value);
        } else {
            // The value was stored as a QString or QByteArray
            detail.setValue(fieldName, property.variantValue());
        }

        // Replace the equivalent detail in updatedDetails with the new one
        QMutableListIterator<QContactDetail> it(*updatedDetails);
        while (it.hasNext()) {
            if (it.next().key() == detail.key()) {
                it.remove();
                break;
            }
        }
        updatedDetails->append(detail);
    }
    if (!group.isEmpty()) {
        // Keep track of which details were generated from which Versit groups
        foreach (const QContactDetail& detail, *updatedDetails) {
            d->mDetailGroupMap.insert(group, detail);
        }
    }
}

/*!
  \reimp
 */
void QVersitContactImporterDefaultPropertyHandler::documentProcessed(
        const QVersitDocument& document,
        QContact* contact)
{
    Q_UNUSED(document)
    Q_UNUSED(contact)
    d->mDetailGroupMap.clear();
}

QVersitContactExporterDefaultDetailHandlerPrivate::QVersitContactExporterDefaultDetailHandlerPrivate()
    : mDetailNumber(0)
{
}

/*!
  \class QVersitContactExporterDefaultDetailHandler
  \brief The QVersitContactExporterDefaultDetailHandler class provides a default implementation of a
  QVersitContactExporterDetailHandlerV2.

  This handler encodes details that the exporter doesn't recognise.  The format it uses to encode
  the detail is as follows:
  \list
  \o All generated properties will have the name X-NOKIA-QCONTACTFIELD
  \o All generated properties will have a single Versit group, and all properties generated from a
     single detail will have the same group.
  \o All generated properties will have at least the parameters DETAIL, which holds the definition
     name of the QContactDetail from which it was generated, and FIELD, which holds the name of the
     field within the detail from which it was generated.
  \o If the field is of type QString or QByteArray, the property's value is set directly to the
     value of the field.  (For a QByteArray value, the QVersitWriter will base-64 encode it.)
  \o If the field is of some other type, the field value is encoded to a QByteArray via QDataStream
     (and the resulting byte array is base-64 encoded by the QVersitWriter).  In this case, the
     parameter DATATYPE=V is added to the Versit property.
  \endlist

  For example, a detail with definition name "Detail" and fields "Field1"="Value1" and
  "Field2"=(int)42 will be exported to the vCard properties:
  \code
  G0.X-NOKIA-QCONTACTFIELD;DETAIL=Detail;FIELD=Field1:Value1
  G0.X-NOKIA-QCONTACTFIELD;DETAIL=Detail;FIELD=Field2;DATATYPE=V;ENCODING=b:AAAAAgAAAAAq?

  \endcode
  And the next detail (say, "Detail" with a field "Field1"="Value3" will generate:
  \code
  G1.X-NOKIA-QCONTACTFIELD;DETAIL=Detail;FIELD=Field1:Value3
  \endcode

  The properties produced by this class can be imported by the
  QVersitContactImporterDefaultPropertyHandler to reproduce the original
  \l{QContactDetail}{QContactDetails}.

  Clients wishing to implement their own detail handler and also benefit from the functionality of
  the default handler can inherit from QVersitContactExporterDefaultDetailHandler.  In the
  implementation of detailProcessed and contactProcessed, the respective functions in the default
  handler should be called as the last step.

  \sa QVersitContactExporterDetailHandlerV2, QVersitContactExporter
 */

/*!
  Constructs a QVersitContactExporterDefaultDetailHandler.
 */
QVersitContactExporterDefaultDetailHandler::QVersitContactExporterDefaultDetailHandler()
    : d(new QVersitContactExporterDefaultDetailHandlerPrivate)
{
}

/*!
 \reimp
 */
void QVersitContactExporterDefaultDetailHandler::detailProcessed(
        const QContact& contact,
        const QContactDetail& detail,
        const QSet<QString>& processedFields,
        const QVersitDocument& document,
        QList<QVersitProperty>* toBeRemoved,
        QList<QVersitProperty>* toBeAdded)
{
    Q_UNUSED(contact)
    Q_UNUSED(document)
    Q_UNUSED(toBeRemoved)
    if (detail.definitionName() == QContactType::DefinitionName)
        return; // special case of an unhandled detail that we don't export
    QVariantMap fields = detail.variantValues();
    // fields from the same detail have the same group so the importer can collate them
    QString detailGroup = QLatin1String("G") + QString::number(d->mDetailNumber++);
    int toBeAddedCount = toBeAdded->count();
    bool propertiesSynthesized = false;
    for (QVariantMap::const_iterator it = fields.constBegin(); it != fields.constEnd(); it++) {
        if (!processedFields.contains(it.key()) && !it.value().toString().isEmpty()) {
            // Generate a property for the unknown field
            QVersitProperty property;
            property.setGroups(QStringList(detailGroup));
            property.setName(QLatin1String("X-NOKIA-QCONTACTFIELD"));
            property.insertParameter(QLatin1String("DETAIL"), detail.definitionName());
            property.insertParameter(QLatin1String("FIELD"), it.key());

            // serialize the value
            if (it.value().type() == QVariant::String
                || it.value().type() == QVariant::ByteArray) {
                // store QStrings and QByteArrays as-is
                property.setValue(it.value());
            } else {
                // store other types by serializing the QVariant in a QByteArray
                QByteArray valueBytes;
                QDataStream stream(&valueBytes, QIODevice::WriteOnly);
                stream << it.value();
                property.insertParameter(QLatin1String("DATATYPE"), QLatin1String("V"));
                property.setValue(valueBytes);
            }

            toBeAdded->append(property);
            propertiesSynthesized = true;
        }
    }
    if (propertiesSynthesized) {
        // We need to group the already-generated properties with the newly synthesized ones
        for (int i = 0; i < toBeAddedCount; i++) {
            QVersitProperty& property = (*toBeAdded)[i];
            property.setGroups(property.groups() << detailGroup);
        }
    }
}

/*!
 \reimp
 */
void QVersitContactExporterDefaultDetailHandler::contactProcessed(
        const QContact& contact,
        QVersitDocument* document)
{
    Q_UNUSED(contact)
    Q_UNUSED(document)
    d->mDetailNumber = 0;
}
