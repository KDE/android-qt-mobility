/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef CLI_CLIENT_H
#define CLI_CLIENT_H

#include "maemo/interfaces/cli-types.h"

#include <QtCore/QtGlobal>

#include <QtCore/QString>
#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

#include "maemo/interfaces/abstract-interface.h"
#include "maemo/dbus-proxy.h"

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
    namespace Client
    {

        /**
         * \class ClientInterface
         * \headerfile TelepathyQt4/client.h "../Client"
         * \ingroup clientclient
         *
         * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client."
         */
        class ClientInterface : public Tp::AbstractInterface
        {
            Q_OBJECT

        public:
            /**
             * Returns the name of the interface "org.freedesktop.Telepathy.Client", which this class
             * represents.
             *
             * \return The D-Bus interface name.
             */
            static inline const char *staticInterfaceName()
            {
                return "org.freedesktop.Telepathy.Client";
            }

            /**
             * Creates a ClientInterface associated with the given object on the session bus.
             *
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientInterface(
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientInterface associated with the given object on the given bus.
             *
             * \param connection The bus via which the object can be reached.
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientInterface(
                const QDBusConnection& connection,
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientInterface associated with the same object as the given proxy.
             *
             * \param proxy The proxy to use. It will also be the QObject::parent()
             *               for this object.
             */
            ClientInterface(Tp::DBusProxy *proxy);

            ~ClientInterface();

            /**
             * Represents property "Interfaces" on the remote object.
             *
             * <p>A list of the extra interfaces provided by this client.
             *   This SHOULD include at least one of
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Observer</tp:dbus-ref>,
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Approver</tp:dbus-ref> or
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Handler</tp:dbus-ref>.</p>
             *
             * <p>In the <code>.client</code> file, this is represented by key
             *   &quot;<code>Interfaces</code>&quot; in the group named after this interface.
             *   The value of the key is a list of interface names each followed by
             *   a semicolon (so it always ends with a semicolon unless it is empty),
             *   i.e. a key of type &quot;strings&quot; as described in the Desktop Entry
             *   specification.</p>
             */
            Q_PROPERTY(QStringList Interfaces READ Interfaces)

            /**
             * Getter for the remote object property "Interfaces".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline QStringList Interfaces() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<QStringList>(internalPropGet("Interfaces"));
            }

        protected:
            virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
        };

        /**
         * \class ClientApproverInterface
         * \headerfile TelepathyQt4/client.h "../Client"
         * \ingroup clientclient
         *
         * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Approver."
         */
        class ClientApproverInterface : public Tp::AbstractInterface
        {
            Q_OBJECT

        public:
            /**
             * Returns the name of the interface "org.freedesktop.Telepathy.Client.Approver", which this class
             * represents.
             *
             * \return The D-Bus interface name.
             */
            static inline const char *staticInterfaceName()
            {
                return "org.freedesktop.Telepathy.Client.Approver";
            }

            /**
             * Creates a ClientApproverInterface associated with the given object on the session bus.
             *
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientApproverInterface(
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientApproverInterface associated with the given object on the given bus.
             *
             * \param connection The bus via which the object can be reached.
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientApproverInterface(
                const QDBusConnection& connection,
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            ~ClientApproverInterface();

            /**
             * Creates a ClientApproverInterface associated with the same object as the given proxy.
             *
             * \param proxy The proxy to use. It will also be the QObject::parent()
             *               for this object.
             */
            ClientApproverInterface(Tp::DBusProxy *proxy);

            /**
             * Creates a ClientApproverInterface associated with the same object as the given proxy.
             * Additionally, the created proxy will have the same parent as the given
             * proxy.
             *
             * \param mainInterface The proxy to use.
             */
            explicit ClientApproverInterface(const Tp::Client::ClientInterface& mainInterface);

            /**
             * Creates a ClientApproverInterface associated with the same object as the given proxy.
             * However, a different parent object can be specified.
             *
             * \param mainInterface The proxy to use.
             * \param parent Passed to the parent class constructor.
             */
            ClientApproverInterface(const Tp::Client::ClientInterface& mainInterface, QObject* parent);

            /**
             * Represents property "ApproverChannelFilter" on the remote object.
             *
             * <p>A specification of the channels in which this approver is
             *   interested. The <tp:member-ref>AddDispatchOperation</tp:member-ref>
             *   method should be called by the channel dispatcher whenever at least
             *   one of the channels in a channel dispatch operation matches this
             *   description.</p>
             *
             * <p>This property works in exactly the same way as the
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Observer.ObserverChannelFilter</tp:dbus-ref>
             *   property. In particular, it cannot change while the approver process
             *   continues to own the corresponding Client bus name.</p>
             *
             * <p>In the .client file, it is represented in the
             *   same way as ObserverChannelFilter, but the group has the same
             *   name as this interface and the keys start with
             *   ApproverChannelFilter instead of ObserverChannelFilter.</p>
             */
            Q_PROPERTY(Tp::ChannelClassList ApproverChannelFilter READ ApproverChannelFilter)

            /**
             * Getter for the remote object property "ApproverChannelFilter".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline Tp::ChannelClassList ApproverChannelFilter() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<Tp::ChannelClassList>(internalPropGet("ApproverChannelFilter"));
            }

        public Q_SLOTS:
            /**
             * Begins a call to the D-Bus method "AddDispatchOperation" on the remote object.
             *
             * <p>Called by the channel dispatcher when a ChannelDispatchOperation
             *   in which the approver has registered an interest is created,
             *   or when the approver starts up while such channel dispatch
             *   operations already exist.</p>
             *
             * <p>The channel dispatcher SHOULD call this method on all approvers
             *   at the same time. If an approver returns an error from this method,
             *   the approver is assumed to be faulty.</p>
             *
             * <p>If no approvers return from this method
             *   successfully (including situations where there are no matching
             *   approvers at all), the channel dispatcher SHOULD consider this
             *   to be an error, and recover by dispatching the channel to the
             *   most preferred handler.</p>
             *
             * <tp:rationale>
             *   Processes that aren't approvers (or don't at least ensure that there
             *   is some approver) probably shouldn't be making connections
             *   anyway, so there should always be at least one approver running.
             * </tp:rationale>
             *
             * \param channels
             *
             *     <p>The initial value of the <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatchOperation.Channels</tp:dbus-ref>
             *       property, containing the <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel</tp:dbus-ref>s
             *       to be dispatched and their properties.</p>
             *
             *     <tp:rationale>
             *       <p>This can't be signalled to the approver through the Properties
             *         parameter of this method, because Channels is not an immutable
             *         property.</p>
             *     </tp:rationale>
             *
             *     <p>This argument always contains all of the channels in the channel
             *       dispatch operation, even if not all of them actually match
             *       the <tp:member-ref>ApproverChannelFilter</tp:member-ref>.</p>
             *
             *     <tp:rationale>
             *       <p>This seems the least bad way to handle such a situation;
             *         see the discussion on
             *         <a href="http://bugs.freedesktop.org/show_bug.cgi?id=21090">bug
             *           #21090</a>.</p>
             *     </tp:rationale>
             *
             *     <p>The actual channels to be dispatched may reduce as channels are
             *       closed: this is signalled by <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatchOperation.ChannelLost</tp:dbus-ref>.
             *     </p>
             *
             *     <p>Approvers SHOULD connect to ChannelLost and <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatchOperation.Finished</tp:dbus-ref>.
             *       (if desired) before returning from AddDispatchOperation, since
             *       those signals are guaranteed not to be emitted until after all
             *       AddDispatchOperation calls have returned (with success or failure)
             *       or timed out.</p>
             *
             * \param dispatchOperation
             *
             *     <p>The
             *     <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatchOperation</tp:dbus-ref>
             *       to be processed.</p>
             *
             * \param properties
             *
             *     Properties of the channel dispatch operation. The keys MUST be
             *     fully qualified D-Bus property names. This MUST NOT include
             *     properties that could change, SHOULD include as many properties as
             *     possible given that constraint, and MUST include at least the
             *     Account, Connection and PossibleHandlers properties.
             */
            inline QDBusPendingReply<> AddDispatchOperation(const Tp::ChannelDetailsList& channels, const QDBusObjectPath& dispatchOperation, const QVariantMap& properties)
            {
                if (!invalidationReason().isEmpty()) {
                    return QDBusPendingReply<>(QDBusMessage::createError(
                        invalidationReason(),
                        invalidationMessage()
                    ));
                }


                QList<QVariant> argumentList;
                argumentList << QVariant::fromValue(channels) << QVariant::fromValue(dispatchOperation) << QVariant::fromValue(properties);
                return asyncCallWithArgumentList(QLatin1String("AddDispatchOperation"), argumentList);
            }

        protected:
            virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
        };

        /**
         * \class ClientHandlerInterface
         * \headerfile TelepathyQt4/client.h "../Client"
         * \ingroup clientclient
         *
         * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Handler."
         */
        class ClientHandlerInterface : public Tp::AbstractInterface
        {
            Q_OBJECT

        public:
            /**
             * Returns the name of the interface "org.freedesktop.Telepathy.Client.Handler", which this class
             * represents.
             *
             * \return The D-Bus interface name.
             */
            static inline const char *staticInterfaceName()
            {
                return "org.freedesktop.Telepathy.Client.Handler";
            }

            /**
             * Creates a ClientHandlerInterface associated with the given object on the session bus.
             *
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientHandlerInterface(
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientHandlerInterface associated with the given object on the given bus.
             *
             * \param connection The bus via which the object can be reached.
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientHandlerInterface(
                const QDBusConnection& connection,
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            ~ClientHandlerInterface();

            /**
             * Creates a ClientHandlerInterface associated with the same object as the given proxy.
             *
             * \param proxy The proxy to use. It will also be the QObject::parent()
             *               for this object.
             */
            ClientHandlerInterface(Tp::DBusProxy *proxy);

            /**
             * Creates a ClientHandlerInterface associated with the same object as the given proxy.
             * Additionally, the created proxy will have the same parent as the given
             * proxy.
             *
             * \param mainInterface The proxy to use.
             */
            explicit ClientHandlerInterface(const Tp::Client::ClientInterface& mainInterface);

            /**
             * Creates a ClientHandlerInterface associated with the same object as the given proxy.
             * However, a different parent object can be specified.
             *
             * \param mainInterface The proxy to use.
             * \param parent Passed to the parent class constructor.
             */
            ClientHandlerInterface(const Tp::Client::ClientInterface& mainInterface, QObject* parent);

            /**
             * Represents property "HandlerChannelFilter" on the remote object.
             *
             * <p>A specification of the channels that this channel handler can
             *   deal with. It will be offered to approvers as a potential
             *   channel handler for bundles that contain only suitable channels,
             *   or for suitable channels that must be handled separately.</p>
             *
             * <p>This property works in exactly the same way as the
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Observer.ObserverChannelFilter</tp:dbus-ref>
             *   property. In particular, it cannot change while the handler process
             *   continues to own the corresponding Client bus name.</p>
             *
             * <p>In the .client file, it is represented in the
             *   same way as ObserverChannelFilter, but the group has the same
             *   name as this interface and the keys start with
             *   HandlerChannelFilter instead of ObserverChannelFilter.</p>
             */
            Q_PROPERTY(Tp::ChannelClassList HandlerChannelFilter READ HandlerChannelFilter)

            /**
             * Getter for the remote object property "HandlerChannelFilter".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline Tp::ChannelClassList HandlerChannelFilter() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<Tp::ChannelClassList>(internalPropGet("HandlerChannelFilter"));
            }

            /**
             * Represents property "BypassApproval" on the remote object.
             *
             * <p>If true, channels destined for this handler are automatically
             *   handled, without invoking approvers.</p>
             *
             * <tp:rationale>
             *   <p>The intended usage is to allow a client handling one channel to
             *     pick up closely related channels. Suppose a client capable of
             *     handling both Text and StreamedMedia,
             *     <code>org.freedesktop.Telepathy.Client.Empathy</code>, is
             *     handling a StreamedMedia channel. That client can take a second
             *     well-known bus name, say
             *     <code>org.freedesktop.Telepathy.Client.Empathy._1._42.Bundle1</code>,
             *     and configure an object at
             *     <code>/org/freedesktop/Telepathy/Client/Empathy/_1/_42/Bundle1</code>
             *     with BypassApproval = TRUE,
             *     whose <tp:member-ref>HandlerChannelFilter</tp:member-ref>
             *     matches closely related Text channels by their Bundle property.
             *     (This is use-case dis5)</p>
             * </tp:rationale>
             */
            Q_PROPERTY(bool BypassApproval READ BypassApproval)

            /**
             * Getter for the remote object property "BypassApproval".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline bool BypassApproval() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<bool>(internalPropGet("BypassApproval"));
            }

            /**
             * Represents property "Capabilities" on the remote object.
             *
             *         <p>The set of additional capabilities supported by this handler.
             *           This describes things like support for streamed media codecs and
             *           NAT traversal mechanisms: see the Contact Capabilities
             *           interface for more details.</p>
             *
             *         <p>For handlers that have a <code>.client</code> file, the
             *           channel dispatcher may discover this property from the
             *           <code>org.freedesktop.Telepathy.Client.Handler.Capabilities</code>
             *           group; for each capability, that group contains a key
             *           whose name is the capability, with value <code>true</code>.
             *           Keys with other values SHOULD NOT appear in this group.</p>
             *
             *         <p>For instance, the <code>.client</code> file for a streamed media
             *           handler that supports ICE-UDP NAT traversal, Speex audio,
             *           and Theora and H264 video might contain this group:</p>
             *
             * <pre>
             * [org.freedesktop.Telepathy.Client.Handler.Capabilities]
             * org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/ice-udp=true
             * org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/audio/speex=true
             * org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/video/theora=true
             * org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/video/h264=true
             * </pre>
             *
             *         <p>Like the <tp:member-ref>HandlerChannelFilter</tp:member-ref>
             *           property, this property cannot change while the Handler owns its
             *           Client bus name. However, the <code>.client</code> file, if any,
             *           can change (due to upgrades or installation of pluggable codecs),
             *           and the capabilities really supported by the handler might not
             *           exactly match what is cached in the <code>.client</code> file.</p>
             *
             *         <tp:rationale>
             *           <p>The client file is installed statically and is intended to list
             *             codecs etc. that the handler guarantees it can support (e.g. by
             *             having a hard dependency on them), whereas the running handler
             *             process might be able to find additional codecs.</p>
             *         </tp:rationale>
             */
            Q_PROPERTY(QStringList Capabilities READ Capabilities)

            /**
             * Getter for the remote object property "Capabilities".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline QStringList Capabilities() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<QStringList>(internalPropGet("Capabilities"));
            }

            /**
             * Represents property "HandledChannels" on the remote object.
             *
             * <p>A list of the channels that this process is currently handling.</p>
             *
             * <p>There is no change notification.</p>
             *
             * <tp:rationale>
             *   <p>This property exists for state recovery - it makes it possible
             *     for channel handling to survive a ChannelDispatcher crash.</p>
             *
             *   <p>If the channel dispatcher is automatically replaced, the
             *     replacement can discover all Handlers by looking for the Client
             *     well-known bus names, and discover which channels they are
             *     currently handling. Once this has been done, all unhandled
             *     channels can be re-dispatched, and the only issue visible to
             *     the user is that unhandled channels that they have already
             *     approved might be sent back to Approvers.</p>
             * </tp:rationale>
             *
             * <p>The value of this property SHOULD be the same for all Client
             *   instances that share a unique bus name, and SHOULD include all
             *   channels that are being handled, even if they were conceptually
             *   handled by a different Client instance.</p>
             *
             * <tp:rationale>
             *   <p>Otherwise, when a process released a temporary Client name,
             *     channels that it handled because of that Client name would no
             *     longer be state-recoverable.</p>
             * </tp:rationale>
             */
            Q_PROPERTY(Tp::ObjectPathList HandledChannels READ HandledChannels)

            /**
             * Getter for the remote object property "HandledChannels".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline Tp::ObjectPathList HandledChannels() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<Tp::ObjectPathList>(internalPropGet("HandledChannels"));
            }

        public Q_SLOTS:
            /**
             * Begins a call to the D-Bus method "HandleChannels" on the remote object.
             *
             * <p>Called by the channel dispatcher when this client should handle these
             *   channels, or when this client should present channels that it is already
             *   handling to the user (e.g. bring them into the foreground).</p>
             *
             * <tp:rationale>
             *   <p>Clients are expected to know what channels they're already handling,
             *     and which channel object path corresponds to which window or tab.
             *     This can easily be done using a hash table keyed by channels' object
             *     paths.</p>
             * </tp:rationale>
             *
             * <p>This method can raise any D-Bus error. If it does, the
             *   handler is assumed to have failed or crashed, and the channel
             *   dispatcher MUST recover in an implementation-specific way; it MAY
             *   attempt to dispatch the channels to another handler, or close the
             *   channels.</p>
             *
             * <p>If closing the channels, it is RECOMMENDED that the channel
             *   dispatcher attempts to close the channels using
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Close</tp:dbus-ref>,
             *   but resorts to calling
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Channel.Interface.Destroyable.Destroy</tp:dbus-ref>
             *   (if available) or ignoring the channel (if not) if the same handler
             *   repeatedly fails to handle channels.</p>
             *
             * <p>After HandleChannels returns successfully, the client process is
             *   considered to be responsible for the channel until it its unique
             *   name disappears from the bus.</p>
             *
             * <tp:rationale>
             *   <p>If a process has multiple Client bus names - some temporary and
             *     some long-lived - and drops one of the temporary bus names in order
             *     to reduce the set of channels that it will handle, any channels
             *     that it is already handling should remain unaffected.</p>
             * </tp:rationale>
             *
             * \param account
             *
             *     The Account with which the channels are associated. The well-known
             *     bus name to use is that of the AccountManager.
             *
             * \param connection
             *
             *     The Connection with which the channels are associated. The
             *     well-known bus name to use can be derived from this object path by
             *     removing the leading &apos;/&apos; and replacing all subsequent
             *     &apos;/&apos; by &apos;.&apos;.
             *
             * \param channels
             *
             *     The channels and their immutable properties. Their well-known bus
             *     name is the same as that of the Connection.
             *
             * \param requestsSatisfied
             *
             *     <p>The requests satisfied by these channels.</p>
             *
             *     <tp:rationale>
             *       <p>If the handler implements Requests, this tells it
             *         that these channels match previous <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Interface.Requests">AddRequest</tp:dbus-ref>
             *         calls that it may have received.</p>
             *
             *       <p>There can be more than one, if they were EnsureChannel
             *         requests.</p>
             *     </tp:rationale>
             *
             * \param userActionTime
             *
             *     The time at which user action occurred, or 0 if this channel is to
             *     be handled for some reason not involving user action. Handlers
             *     SHOULD use this for focus-stealing prevention, if applicable.
             *
             * \param handlerInfo
             *
             *     <p>Additional information about these channels. No keys are
             *       currently defined.</p>
             *
             *     <p>If keys are defined for this dictionary, all will be optional;
             *       handlers MAY safely ignore any entry in this dictionary.</p>
             */
            inline QDBusPendingReply<> HandleChannels(const QDBusObjectPath& account, const QDBusObjectPath& connection, const Tp::ChannelDetailsList& channels, const Tp::ObjectPathList& requestsSatisfied, qulonglong userActionTime, const QVariantMap& handlerInfo)
            {
                if (!invalidationReason().isEmpty()) {
                    return QDBusPendingReply<>(QDBusMessage::createError(
                        invalidationReason(),
                        invalidationMessage()
                    ));
                }


                QList<QVariant> argumentList;
                argumentList << QVariant::fromValue(account) << QVariant::fromValue(connection) << QVariant::fromValue(channels) << QVariant::fromValue(requestsSatisfied) << QVariant::fromValue(userActionTime) << QVariant::fromValue(handlerInfo);
                return asyncCallWithArgumentList(QLatin1String("HandleChannels"), argumentList);
            }

        protected:
            virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
        };

        /**
         * \class ClientInterfaceRequestsInterface
         * \headerfile TelepathyQt4/client.h "../Client"
         * \ingroup clientclient
         *
         * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Interface.Requests."
         */
        class ClientInterfaceRequestsInterface : public Tp::AbstractInterface
        {
            Q_OBJECT

        public:
            /**
             * Returns the name of the interface "org.freedesktop.Telepathy.Client.Interface.Requests", which this class
             * represents.
             *
             * \return The D-Bus interface name.
             */
            static inline const char *staticInterfaceName()
            {
                return "org.freedesktop.Telepathy.Client.Interface.Requests";
            }

            /**
             * Creates a ClientInterfaceRequestsInterface associated with the given object on the session bus.
             *
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientInterfaceRequestsInterface(
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientInterfaceRequestsInterface associated with the given object on the given bus.
             *
             * \param connection The bus via which the object can be reached.
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientInterfaceRequestsInterface(
                const QDBusConnection& connection,
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            ~ClientInterfaceRequestsInterface();

            /**
             * Creates a ClientInterfaceRequestsInterface associated with the same object as the given proxy.
             *
             * \param proxy The proxy to use. It will also be the QObject::parent()
             *               for this object.
             */
            ClientInterfaceRequestsInterface(Tp::DBusProxy *proxy);

            /**
             * Creates a ClientInterfaceRequestsInterface associated with the same object as the given proxy.
             * Additionally, the created proxy will have the same parent as the given
             * proxy.
             *
             * \param mainInterface The proxy to use.
             */
            explicit ClientInterfaceRequestsInterface(const Tp::Client::ClientInterface& mainInterface);

            /**
             * Creates a ClientInterfaceRequestsInterface associated with the same object as the given proxy.
             * However, a different parent object can be specified.
             *
             * \param mainInterface The proxy to use.
             * \param parent Passed to the parent class constructor.
             */
            ClientInterfaceRequestsInterface(const Tp::Client::ClientInterface& mainInterface, QObject* parent);

        public Q_SLOTS:
            /**
             * Begins a call to the D-Bus method "AddRequest" on the remote object.
             *
             * <p>Called by the ChannelDispatcher to indicate that channels have been
             *   requested, and that if the request is successful, they will probably
             *   be handled by this Handler. The ChannelDispatcher SHOULD only
             *   call this method on one handler per request.</p>
             *
             * <tp:rationale>
             *   <p>This allows the UI to start preparing to handle the channels
             *     in advance (e.g. render a window with an &quot;in progress&quot; message),
             *     improving perceived responsiveness.</p>
             *
             *   <p>The use of &quot;probably&quot; is because you can't necessarily tell from
             *     a channel request which handler will handle particular channels.
             *     A reasonable heuristic would be to match the request against the
             *     <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler">HandlerChannelFilter</tp:dbus-ref>,
             *     and respect the preferred handler (if any).</p>
             * </tp:rationale>
             *
             * <p>If the request succeeds and is given to the expected Handler,
             *   the Requests_Satisfied parameter to
             *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler">HandleChannels</tp:dbus-ref>
             *   can be used to match the channel to a previous AddRequest call.</p>
             *
             * <tp:rationale>
             *   <p>This lets the UI direct the channels to the window that it
             *     already opened.</p>
             * </tp:rationale>
             *
             * <p>If the request fails, the expected handler is notified by the
             *   channel dispatcher calling its
             *   <tp:member-ref>RemoveRequest</tp:member-ref> method.</p>
             *
             * <tp:rationale>
             *   <p>This lets the UI close the window or display the error.</p>
             * </tp:rationale>
             *
             * <p>The channel dispatcher SHOULD remember which handler was notified,
             *   and if the channel request succeeds, it SHOULD dispatch the channels
             *   to the expected handler, unless the channels do not match that
             *   handler's <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler">HandlerChannelFilter</tp:dbus-ref>.
             *   If the channels are not dispatched to the expected handler, the
             *   handler that was expected is notified by the channel dispatcher
             *   calling its <tp:member-ref>RemoveRequest</tp:member-ref> method
             *   with the NotYours error.</p>
             *
             * <tp:rationale>
             *   <p>Expected handling is for the UI to close the window it
             *     previously opened.</p>
             * </tp:rationale>
             *
             * <p>Handlers SHOULD NOT return an error from this method; errors
             *   returned from this method SHOULD NOT alter the channel dispatcher's
             *   behaviour.</p>
             *
             * <tp:rationale>
             *   <p>Calls to this method are merely a notification.</p>
             * </tp:rationale>
             *
             * \param request
             *
             *     The ChannelRequest object, which MUST have been returned by
             *     CreateChannel or EnsureChannel before this method is called. See
             *     those methods for the rationale of this ordering.
             *
             * \param properties
             *
             *     Some of the properties of the ChannelRequest. To avoid race
             *     conditions, this dictionary MUST NOT include properties whose
             *     values could subsequently change. It SHOULD include as many
             *     properties as possible, given that constraint. In particular, the
             *     properties Requests and UserActionTime MUST be included.
             */
            inline QDBusPendingReply<> AddRequest(const QDBusObjectPath& request, const QVariantMap& properties)
            {
                if (!invalidationReason().isEmpty()) {
                    return QDBusPendingReply<>(QDBusMessage::createError(
                        invalidationReason(),
                        invalidationMessage()
                    ));
                }


                QList<QVariant> argumentList;
                argumentList << QVariant::fromValue(request) << QVariant::fromValue(properties);
                return asyncCallWithArgumentList(QLatin1String("AddRequest"), argumentList);
            }

            /**
             * Begins a call to the D-Bus method "RemoveRequest" on the remote object.
             *
             * <p>Called by the ChannelDispatcher to indicate that a request
             *   previously passed to <tp:member-ref>AddRequest</tp:member-ref>
             *   has failed and should be disregarded.</p>
             *
             * <p>Handlers SHOULD NOT return an error from this method; errors
             *   returned from this method SHOULD NOT alter the channel dispatcher's
             *   behaviour.</p>
             *
             * <tp:rationale>
             *   <p>Calls to this method are merely a notification.</p>
             * </tp:rationale>
             *
             * \param request
             *
             *     The request that failed.
             *
             * \param error
             *
             *     <p>The name of the D-Bus error with which the request failed.</p>
             *
             *     <p>If this is <code>org.freedesktop.Telepathy.Error.NotYours</code>,
             *       this indicates that the request succeeded, but all the resulting
             *       channels were given to some other handler.</p>
             *
             * \param message
             *
             *     Any message supplied with the D-Bus error.
             */
            inline QDBusPendingReply<> RemoveRequest(const QDBusObjectPath& request, const QString& error, const QString& message)
            {
                if (!invalidationReason().isEmpty()) {
                    return QDBusPendingReply<>(QDBusMessage::createError(
                        invalidationReason(),
                        invalidationMessage()
                    ));
                }


                QList<QVariant> argumentList;
                argumentList << QVariant::fromValue(request) << QVariant::fromValue(error) << QVariant::fromValue(message);
                return asyncCallWithArgumentList(QLatin1String("RemoveRequest"), argumentList);
            }

        protected:
            virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
        };

        /**
         * \class ClientObserverInterface
         * \headerfile TelepathyQt4/client.h "../Client"
         * \ingroup clientclient
         *
         * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Client.Observer."
         */
        class ClientObserverInterface : public Tp::AbstractInterface
        {
            Q_OBJECT

        public:
            /**
             * Returns the name of the interface "org.freedesktop.Telepathy.Client.Observer", which this class
             * represents.
             *
             * \return The D-Bus interface name.
             */
            static inline const char *staticInterfaceName()
            {
                return "org.freedesktop.Telepathy.Client.Observer";
            }

            /**
             * Creates a ClientObserverInterface associated with the given object on the session bus.
             *
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientObserverInterface(
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            /**
             * Creates a ClientObserverInterface associated with the given object on the given bus.
             *
             * \param connection The bus via which the object can be reached.
             * \param busName Name of the service the object is on.
             * \param objectPath Path to the object on the service.
             * \param parent Passed to the parent class constructor.
             */
            ClientObserverInterface(
                const QDBusConnection& connection,
                const QString& busName,
                const QString& objectPath,
                QObject* parent = 0
            );

            ~ClientObserverInterface();

            /**
             * Creates a ClientObserverInterface associated with the same object as the given proxy.
             *
             * \param proxy The proxy to use. It will also be the QObject::parent()
             *               for this object.
             */
            ClientObserverInterface(Tp::DBusProxy *proxy);

            /**
             * Creates a ClientObserverInterface associated with the same object as the given proxy.
             * Additionally, the created proxy will have the same parent as the given
             * proxy.
             *
             * \param mainInterface The proxy to use.
             */
            explicit ClientObserverInterface(const Tp::Client::ClientInterface& mainInterface);

            /**
             * Creates a ClientObserverInterface associated with the same object as the given proxy.
             * However, a different parent object can be specified.
             *
             * \param mainInterface The proxy to use.
             * \param parent Passed to the parent class constructor.
             */
            ClientObserverInterface(const Tp::Client::ClientInterface& mainInterface, QObject* parent);

            /**
             * Represents property "ObserverChannelFilter" on the remote object.
             *
             *         <p>A specification of the channels in which this observer is
             *           interested. The <tp:member-ref>ObserveChannels</tp:member-ref> method
             *           should be called by the channel dispatcher whenever any of the new
             *           channels in a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">NewChannels</tp:dbus-ref>
             *           signal match this description.</p>
             *
             *         <p>Only certain D-Bus types have useful semantics for matching like this,
             *           so only certain types are allowed:</p>
             *
             *         <dl>
             *           <dt>Integers of all sizes, including byte (y, n, q, i, u, x, t)</dt>
             *           <dd>Matched by numeric value, regardless of type (e.g. 42 as a
             *             16-bit signed integer 'n' is considered equal to 42 as a 32-bit
             *             unsigned integer 'u')</dd>
             *
             *           <dt>Booleans (b)</dt>
             *           <dd>Matched by equality in the obvious way; not considered equal to any
             *             other type</dd>
             *
             *           <dt>Strings (s)</dt>
             *           <dd>Matched by equality in the obvious way; not considered equal to any
             *             other type</dd>
             *
             *           <dt>Object paths (o)</dt>
             *           <dd>Matched by equality in the obvious way; not considered equal to any
             *             other type</dd>
             *
             *         </dl>
             *
             *         <p>This property never changes while the observer process owns its
             *           Client bus name. For activatable processes, the filter can change
             *           due to an upgrade - the channel dispatcher SHOULD observe changes to
             *           .client files using a mechanism like inotify.</p>
             *
             *         <tp:rationale>
             *           <p>Not allowing this property to change is a simplification,
             *             particularly for activatable processes (we reject the possibility
             *             that a process with a .client file, when activated, has a filter
             *             that differs from what its .client file said).</p>
             *
             *           <p>If an Observer wants to add extra channels to its list of
             *             interests at runtime, it can register an additional Client bus name
             *             (for instance, the org.freedesktop.Telepathy.Client.Empathy process
             *             with unique name :1.42 could additionally register
             *             org.freedesktop.Telepathy.Client.Empathy._1_42) with additional
             *             filters. To remove those filters, it can release the bus name;
             *             it could even re-claim the bus name immediately, with different
             *             filters.</p>
             *
             *           <p>The same principle is applied to Approvers and Handlers.</p>
             *         </tp:rationale>
             *
             *         <p>For observers that have a .client file, the channel dispatcher
             *           may discover this property from keys of the form
             *           &quot;<code><em>propertyname</em> <em>type</em></code>&quot;,
             *           in groups in the .client file whose name is the name of this
             *           interface followed by <code>.ObserverChannelFilter</code>,
             *           a space and an ASCII decimal number starting from 0.</p>
             *
             *         <p>Values in the .client file are encoded in exactly the same way as
             *           the <code>default-<em>p</em></code> keys in .manager files, as
             *           described in the <tp:dbus-ref namespace="org.freedesktop.Telepathy">ConnectionManager</tp:dbus-ref> interface (but note that not all
             *           types supported in .manager files can appear in .client files).</p>
             *
             *         <p>For instance, a .client file for an observer that is only interested
             *           in Text channels, with CONTACT or ROOM handles, that were requested by
             *           a local client:</p>
             *
             * <pre>
             * [org.freedesktop.Telepathy.Client]
             * Interfaces=org.freedesktop.Telepathy.Client.Observer;
             *
             * [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 0]
             * org.freedesktop.Telepathy.Channel.ChannelType s=org.freedesktop.Telepathy.Channel.Type.Text
             * org.freedesktop.Telepathy.Channel.TargetHandleType u=1
             * org.freedesktop.Telepathy.Channel.Requested b=true
             *
             * [org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter 1]
             * org.freedesktop.Telepathy.Channel.ChannelType s=org.freedesktop.Telepathy.Channel.Type.Text
             * org.freedesktop.Telepathy.Channel.TargetHandleType u=2
             * org.freedesktop.Telepathy.Channel.Requested b=true
             * </pre>
             */
            Q_PROPERTY(Tp::ChannelClassList ObserverChannelFilter READ ObserverChannelFilter)

            /**
             * Getter for the remote object property "ObserverChannelFilter".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline Tp::ChannelClassList ObserverChannelFilter() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<Tp::ChannelClassList>(internalPropGet("ObserverChannelFilter"));
            }

            /**
             * Represents property "Recover" on the remote object.
             *
             * <p>If true, upon the startup of this observer, <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Observer">ObserveChannels</tp:dbus-ref>
             * will be called for every already existing channel matching
             * its <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Observer">ObserverChannelFilter</tp:dbus-ref></p>
             *
             * <p>When activatable client having this property disappears from the bus
             * and there are channels matching its ObserverChannelFilter,
             * ObserveChannels will be called immediately to reactivate it again.</p>
             * <tp:rationale>
             *   <p>This means that if an activatable Observer crashes, it will
             *     be restarted as soon as possible; while there is an unavoidable
             *     possibility that it will miss some events during this process
             *     (particularly <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text</tp:dbus-ref>
             *     messages), this window of event loss is kept to a minimum.</p>
             *
             *    <p>Non-activatable observers can't take advantage of this
             *     mechanism, but setting this property on a non-activatable
             *     observer does allow it to &quot;catch up&quot; on channels that are
             *     currently active at the time that it starts up.</p>
             * </tp:rationale>
             *
             * <p>When the ObserveChannels method is called due to observer recovery,
             * the &quot;Observer_Info&quot; dictionary will contain one extra item with key
             * &quot;recovering&quot; and boolean value of True.</p>
             */
            Q_PROPERTY(bool Recover READ Recover)

            /**
             * Getter for the remote object property "Recover".
             *
             * Don't use this: it blocks the main loop.
             *
             * \return The value of the property, or a default-constructed value
             *          if the property is not readable.
             */
            inline bool Recover() const TELEPATHY_GNUC_DEPRECATED
            {
                return qvariant_cast<bool>(internalPropGet("Recover"));
            }

        public Q_SLOTS:
            /**
             * Begins a call to the D-Bus method "ObserveChannels" on the remote object.
             *
             * <p>Called by the channel dispatcher when channels in which the
             *   observer has registered an interest are announced in a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">NewChannels</tp:dbus-ref>
             *   signal.</p>
             *
             * <p>If the same NewChannels signal announces some channels that match
             *   the filter, and some that do not, then only a subset of the channels
             *   (those that do match the filter) are passed to this method.</p>
             *
             * <p>If the channel dispatcher will split up the channels from a single
             *   NewChannels signal and dispatch them separately (for instance
             *   because no installed Handler can handle all of them), it will call
             *   ObserveChannels several times.</p>
             *
             * <p>The observer MUST NOT return from this method call until it is ready
             *   for a handler for the channel to run (which may change the channel's
             *   state).</p>
             *
             * <tp:rationale>
             *   <p>The channel dispatcher must wait for observers to start up,
             *     to avoid the following race: text channel logger (observer) gets
             *     ObserveChannels, text channel handler gets
             *     <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler">HandleChannels</tp:dbus-ref>
             *     channel handler starts up faster and acknowledges messages,
             *     logger never sees those messages.</p>
             * </tp:rationale>
             *
             * <p>The channel dispatcher SHOULD NOT change its behaviour based on
             *   whether this method succeeds or fails: there are no defined D-Bus
             *   errors for this method, and if it fails, this only indicates that
             *   an Observer is somehow broken.</p>
             *
             * <tp:rationale>
             *   <p>The expected error response in the channel dispatcher is to
             *     log a warning, and otherwise continue as though this method
             *     had succeeded.</p>
             * </tp:rationale>
             *
             * \param account
             *
             *     The Account with which the channels are associated. The well-known
             *     bus name to use is that of the AccountManager.
             *
             * \param connection
             *
             *     The Connection with which the channels are associated. The
             *     well-known bus name to use can be derived from this object path by
             *     removing the leading &apos;/&apos; and replacing all subsequent
             *     &apos;/&apos; by &apos;.&apos;.
             *
             * \param channels
             *
             *     The Channels and their properties. Their well-known bus names are
             *     all the same as that of the Connection.
             *
             * \param dispatchOperation
             *
             *     <p>The path to the <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatchOperation</tp:dbus-ref>
             *       for these channels, or the special value '/' if there is no
             *       ChannelDispatchOperation (because the channels were requested, not
             *       incoming).</p>
             *
             *     <p>If the Observer calls <tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation">Claim</tp:dbus-ref>
             *       or <tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation">HandleWith</tp:dbus-ref>
             *       on the dispatch operation, it MUST be careful to avoid deadlock,
             *       since these methods cannot return until the Observer has returned
             *       from <tp:member-ref>ObserveChannels</tp:member-ref>.</p>
             *
             *     <tp:rationale>
             *       <p>This allows an Observer to <tp:dbus-ref namespace="org.freedesktop.Telepathy.ChannelDispatchOperation">Claim</tp:dbus-ref>
             *         a set of channels without having to match up calls to this method
             *         with calls to <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Approver">AddDispatchOperation</tp:dbus-ref>.</p>
             *     </tp:rationale>
             *
             * \param requestsSatisfied
             *
             *     The requests satisfied by these channels. If the same process is an
             *     Observer and a Handler, it can be useful to be given this
             *     information as soon as possible (it will also be passed to
             *     Handler.HandleChannels).
             *
             * \param observerInfo
             *
             *     <p>Additional information about these channels. Currently defined
             *       keys are:</p>
             *
             *     <dl>
             *       <dt><code>recovering</code> - b</dt>
             *       <dd>True if ObserveChannels was called on existing channel due to
             *         observer recovery, otherwise False.
             *         <tp:rationale>
             *           This allows observers to distinguish between new channels (the normal
             *           case), and existing channels that were given to the observer in order
             *           to catch up on previous events (perhaps after a previous instance of
             *           the same observer crashed).
             *         </tp:rationale>
             *       </dd>
             *     </dl>
             *
             *     <p>All defined keys for this dictionary are optional;
             *       observers MAY safely ignore any entry in this dictionary.</p>
             */
            inline QDBusPendingReply<> ObserveChannels(const QDBusObjectPath& account, const QDBusObjectPath& connection, const Tp::ChannelDetailsList& channels, const QDBusObjectPath& dispatchOperation, const Tp::ObjectPathList& requestsSatisfied, const QVariantMap& observerInfo)
            {
                if (!invalidationReason().isEmpty()) {
                    return QDBusPendingReply<>(QDBusMessage::createError(
                        invalidationReason(),
                        invalidationMessage()
                    ));
                }


                QList<QVariant> argumentList;
                argumentList << QVariant::fromValue(account) << QVariant::fromValue(connection) << QVariant::fromValue(channels) << QVariant::fromValue(dispatchOperation) << QVariant::fromValue(requestsSatisfied) << QVariant::fromValue(observerInfo);
                return asyncCallWithArgumentList(QLatin1String("ObserveChannels"), argumentList);
            }

        protected:
            virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
        };
    }
}
Q_DECLARE_METATYPE(Tp::Client::ClientInterface*)
Q_DECLARE_METATYPE(Tp::Client::ClientApproverInterface*)
Q_DECLARE_METATYPE(Tp::Client::ClientHandlerInterface*)
Q_DECLARE_METATYPE(Tp::Client::ClientInterfaceRequestsInterface*)
Q_DECLARE_METATYPE(Tp::Client::ClientObserverInterface*)

#endif //#ifndef CLI_CLIENT_H
