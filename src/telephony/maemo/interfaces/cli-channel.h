/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef CLI_CHANNEL_H
#define CLI_CHANNEL_H

#include "maemo/interfaces/cli-types.h"

#include <QtCore/QtGlobal>

#include <QtCore/QString>
#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

#include "maemo/interfaces/abstract-interface.h"
#include "maemo/dbus-proxy.h"

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
namespace Client
{

/**
 * \class ChannelInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel."
 */
class ChannelInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel";
    }

    /**
     * Creates a ChannelInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterface(Tp::DBusProxy *proxy);

    /**
     * Represents property "ChannelType" on the remote object.
     * 
     * <p>The channel's type. This cannot change once the channel has
     *   been created.</p>
     * 
     * <p>For compatibility between older connection managers and newer
     *   clients, if this is unavailable or is an empty string,
     *   clients MUST use the result of calling
     *   <tp:member-ref>GetChannelType</tp:member-ref>.</p>
     * 
     * <tp:rationale>
     *   The GetAll method lets clients retrieve all properties in one
     *   round-trip, which is desirable.
     * </tp:rationale>
     * 
     * <p>When requesting a channel, the request MUST specify a channel
     *   type, and the request MUST fail if the specified channel type
     *   cannot be supplied.</p>
     * 
     * <tp:rationale>
     *   Common sense.
     * </tp:rationale>
     */
    Q_PROPERTY(QString ChannelType READ ChannelType)

    /**
     * Getter for the remote object property "ChannelType".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString ChannelType() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("ChannelType"));
    }

    /**
     * Represents property "Interfaces" on the remote object.
     * 
     * <p>Extra interfaces provided by this channel. This SHOULD NOT include
     *   the channel type and the Channel interface itself, and cannot
     *   change once the channel has been created.</p>
     * 
     * <p>For compatibility between older connection managers and newer
     *   clients, if this is unavailable, or if this is an empty list and
     *   <tp:member-ref>ChannelType</tp:member-ref> is an empty string,
     *   clients MUST use the result of calling
     *   <tp:member-ref>GetInterfaces</tp:member-ref> instead. If this is an
     *   empty list but ChannelType is non-empty, clients SHOULD NOT call
     *   GetInterfaces; this implies that connection managers that implement
     *   the ChannelType property MUST also implement the Interfaces property
     *   correctly.</p>
     * 
     * <tp:rationale>
     *   The GetAll method lets clients retrieve all properties in one
     *   round-trip, which is desirable.
     * </tp:rationale>
     * 
     * <p>When requesting a channel with a particular value for this
     *   property, the request must fail without side-effects unless the
     *   connection manager expects to be able to provide a channel whose
     *   interfaces include at least the interfaces requested.</p>
     */
    Q_PROPERTY(QStringList Interfaces READ Interfaces)

    /**
     * Getter for the remote object property "Interfaces".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList Interfaces() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("Interfaces"));
    }

    /**
     * Represents property "TargetHandle" on the remote object.
     * 
     * <p>The handle (a representation for the identifier) of the contact,
     *   chatroom, etc. with which this handle communicates. Its type
     *   is given by the <tp:member-ref>TargetHandleType</tp:member-ref>
     *   property.</p>
     * 
     * <p>This is fixed for the lifetime of the channel, so channels which
     *   could potentially be used to communicate with multiple contacts
     *   (such as streamed media calls defined by their members, or ad-hoc
     *   chatrooms like MSN switchboards) must have TargetHandleType set
     *   to Handle_Type_None and TargetHandle set to 0.</p>
     * 
     * <p>Unlike in the telepathy-spec 0.16 API, there is no particular
     *   uniqueness guarantee - there can be many channels with the same
     *   (channel type, handle type, handle) tuple. This is necessary
     *   to support conversation threads in XMPP and SIP, for example.</p>
     * 
     * <p>If this is present in a channel request, it must be nonzero,
     *   <tp:member-ref>TargetHandleType</tp:member-ref>
     *   MUST be present and not Handle_Type_None, and
     *   <tp:member-ref>TargetID</tp:member-ref> MUST NOT be
     *   present.</p>
     * 
     * <p>The channel that satisfies the request MUST either:</p>
     * 
     * <ul>
     *   <li>have the specified TargetHandle property; or</li>
     *   <li>have <tp:member-ref>TargetHandleType</tp:member-ref> =
     *     Handle_Type_None, TargetHandle = 0, and be configured such that
     *     it could communicate with the specified handle in some other way
     *     (e.g. have the requested contact handle in its Group
     *     interface)</li>
     * </ul>
     */
    Q_PROPERTY(uint TargetHandle READ TargetHandle)

    /**
     * Getter for the remote object property "TargetHandle".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint TargetHandle() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("TargetHandle"));
    }

    /**
     * Represents property "TargetID" on the remote object.
     * 
     * <p>The string that would result from inspecting the
     *   <tp:member-ref>TargetHandle</tp:member-ref>
     *   property (i.e. the identifier in the IM protocol of the contact,
     *   room, etc. with which this channel communicates), or the empty
     *   string if the TargetHandle is 0.</p>
     * 
     * <tp:rationale>
     *   <p>The presence of this property avoids the following race
     *     condition:</p>
     * 
     *   <ul>
     *     <li>New channel C is signalled with target handle T</li>
     *     <li>Client calls <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
     *       [T])</li>
     *     <li>Channel C closes, removing the last reference to handle T</li>
     *     <li><tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
     *       [T]) returns an error</li>
     *   </ul>
     * </tp:rationale>
     * 
     * <p>If this is present in a channel request,
     *   <tp:member-ref>TargetHandleType</tp:member-ref>
     *   MUST be present and not Handle_Type_None, and
     *   <tp:member-ref>TargetHandle</tp:member-ref> MUST NOT be
     *   present. The request MUST fail with error InvalidHandle, without
     *   side-effects, if the requested TargetID would not be accepted by
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestHandles</tp:dbus-ref>.</p>
     * 
     * <p>The returned channel must be related to the handle corresponding
     *   to the given identifier, in the same way as if TargetHandle
     *   had been part of the request instead.</p>
     * 
     * <tp:rationale>
     *   <p>Requesting channels with a string identifier saves a round-trip
     *     (the call to RequestHandles). It also allows the channel
     *     dispatcher to accept a channel request for an account that is not
     *     yet connected (and thus has no valid handles), bring the account
     *     online, and pass on the same parameters to the new connection's
     *     CreateChannel method.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(QString TargetID READ TargetID)

    /**
     * Getter for the remote object property "TargetID".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString TargetID() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("TargetID"));
    }

    /**
     * Represents property "TargetHandleType" on the remote object.
     * 
     * <p>The type of <tp:member-ref>TargetHandle</tp:member-ref>.</p>
     * 
     * <p>If this is omitted from a channel request, connection managers
     *   SHOULD treat this as equivalent to Handle_Type_None.</p>
     * 
     * <p>If this is omitted or is Handle_Type_None,
     *   <tp:member-ref>TargetHandle</tp:member-ref> and
     *   <tp:member-ref>TargetID</tp:member-ref> MUST be omitted from the
     *   request.</p>
     */
    Q_PROPERTY(uint TargetHandleType READ TargetHandleType)

    /**
     * Getter for the remote object property "TargetHandleType".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint TargetHandleType() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("TargetHandleType"));
    }

    /**
     * Represents property "Requested" on the remote object.
     * 
     * <p>True if this channel was created in response to a local request,
     *   such as a call to
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.RequestChannel</tp:dbus-ref>
     *   or
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>.</p>
     * 
     * <tp:rationale>
     *   <p>The idea of this property is to distinguish between &quot;incoming&quot;
     *     and &quot;outgoing&quot; channels, in a way that doesn't break down when
     *     considering special cases like contact lists that are automatically
     *     created on connection to the server, or chatrooms that an
     *     IRC proxy/bouncer like irssi-proxy or bip was already in.</p>
     * 
     *   <p>The reason we want to make that distinction is that UIs for
     *     things that the user explicitly requested should start up
     *     automatically, whereas for incoming messages and VoIP calls we
     *     should first ask the user whether they want to open the messaging
     *     UI or accept the call.</p>
     * </tp:rationale>
     * 
     * <p>If the channel was not explicitly requested (even if it was
     *   created as a side-effect of a call to one of those functions,
     *   e.g. because joining a Tube in a MUC context on XMPP implies
     *   joining that MUC), then this property is false.</p>
     * 
     * <p>For compatibility with older connection managers, clients SHOULD
     *   assume that this property is true if they see a channel announced
     *   by the
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.NewChannel</tp:dbus-ref>
     *   signal with the suppress_handler parameter set to true.</p>
     * 
     * <tp:rationale>
     *   <p>In a correct connection manager, the only way to get such a
     *     channel is to request it.</p>
     * </tp:rationale>
     * 
     * <p>Clients MAY additionally assume that this property is false
     *   if they see a channel announced by the NewChannel signal with the
     *   suppress_handler parameter set to false.</p>
     * 
     * <tp:rationale>
     *   <p>This is more controversial, since it's possible to get that
     *     parameter set to false by requesting a channel. However, there's
     *     no good reason to do so, and we've deprecated this practice.</p>
     * 
     *   <p>In the particular case of the channel dispatcher, the only
     *     side-effect of wrongly thinking a channel is unrequested
     *     is likely to be that the user has to confirm that they want to
     *     use it, so it seems fairly harmless to assume in the channel
     *     dispatcher that channels with suppress_handler false are
     *     indeed unrequested.</p>
     * </tp:rationale>
     * 
     * <p>It does not make sense for this property to be in channel
     *   requests—it will always be true for channels returned by
     *   CreateChannel, and callers of EnsureChannel cannot control whether an
     *   existing channel was originally requested locally—so it MUST NOT
     *   be accepted.</p>
     */
    Q_PROPERTY(bool Requested READ Requested)

    /**
     * Getter for the remote object property "Requested".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool Requested() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("Requested"));
    }

    /**
     * Represents property "InitiatorHandle" on the remote object.
     * 
     * <p>The contact who initiated the channel; for instance, the contact
     *   who invited the local user to a chatroom, or the contact who
     *   initiated a call.</p>
     * 
     * <p>This does <em>not</em> necessarily represent the contact who
     *   created the underlying protocol-level construct. For instance, if
     *   Rob creates a chatroom, Will joins that chatroom, and Will invites Simon
     *   to join it, then Simon will see Will as the InitiatorHandle of the
     *   channel representing the chatroom.</p>
     * 
     * <tp:rationale>
     *   <p>The room creator is generally a less useful piece of information
     *     than the inviter, is less likely to be available at invitation
     *     time (i.e. can't necessarily be an immutable property), and is
     *     less likely to be available at all. The creator of a chatroom
     *     is not currently available via Telepathy; if added in future, it
     *     is likely to be made available as a property on the Chatroom
     *     interface (<a href="http://bugs.freedesktop.org/show_bug.cgi?id=23151">bug 23151</a>).</p>
     * </tp:rationale>
     * 
     * <p>For channels requested by the
     *   local user, this MUST be the value of
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.SelfHandle</tp:dbus-ref>
     *   at the time the channel was created (i.e. not a channel-specific
     *   handle).</p>
     * 
     * <tp:rationale>
     *   <p>On some protocols, the SelfHandle may change (as signalled by
     *     <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.SelfHandleChanged</tp:dbus-ref>),
     *     but this property is immutable. Hence, locally-requested channels'
     *     InitiatorHandle and InitiatorID may not match the current
     *     SelfHandle; <tp:member-ref>Requested</tp:member-ref> can be used to
     *     determine whether the channel was created locally.</p>
     * </tp:rationale>
     * 
     * <p>For channels requested by a remote user, this MUST be their handle.
     *   If unavailable or not applicable, this MUST be 0 (for instance,
     *   contact lists are not really initiated by anyone in particular, and
     *   it's easy to imagine a protocol where chatroom invitations can be
     *   anonymous).</p>
     * 
     * <p>For channels with the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group</tp:dbus-ref>
     *   interface, this SHOULD be the same
     *   contact who is signalled as the &quot;Actor&quot; causing the self-handle
     *   to be placed in the local-pending set.</p>
     * 
     * <p>This SHOULD NOT be a channel-specific handle, if possible.</p>
     * 
     * <p>It does not make sense for this property to be in channel
     *   requests - the initiator will always be the local user - so it
     *   MUST NOT be accepted.</p>
     */
    Q_PROPERTY(uint InitiatorHandle READ InitiatorHandle)

    /**
     * Getter for the remote object property "InitiatorHandle".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint InitiatorHandle() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("InitiatorHandle"));
    }

    /**
     * Represents property "InitiatorID" on the remote object.
     * 
     * <p>The string that would result from inspecting the
     *   <tp:member-ref>InitiatorHandle</tp:member-ref>
     *   property (i.e. the initiator's identifier in the IM protocol).</p>
     * 
     * <tp:rationale>
     *   <p>The presence of this property avoids the following race
     *     condition:</p>
     * 
     *   <ul>
     *     <li>New StreamedMedia channel C is signalled with initiator
     *       handle I</li>
     *     <li>Client calls <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
     *       [I])</li>
     *     <li>Channel C closes, removing the last reference to handle I</li>
     *     <li><tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>(CONTACT,
     *       [I]) returns an error</li>
     *     <li>Client can indicate that a call was missed, but not who
     *       called!</li>
     *   </ul>
     * </tp:rationale>
     * 
     * <p>It does not make sense for this property to be in channel
     *   requests - the initiator will always be the local user - so it
     *   MUST NOT be accepted.</p>
     */
    Q_PROPERTY(QString InitiatorID READ InitiatorID)

    /**
     * Getter for the remote object property "InitiatorID".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString InitiatorID() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("InitiatorID"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "Close" on the remote object.
     * 
     * Request that the channel be closed. This is not the case until the 
     * Closed signal has been emitted, and depending on the connection manager 
     * this may simply remove you from the channel on the server, rather than 
     * causing it to stop existing entirely. Some channels such as contact 
     * list channels may not be closed.
     */
    inline QDBusPendingReply<> Close()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Close"));
    }

    /**
     * Begins a call to the D-Bus method "GetChannelType" on the remote object.
     * 
     * Returns the interface name for the type of this channel. Clients SHOULD 
     * use the ChannelType property instead, falling back to this method only 
     * if necessary. The GetAll method lets clients retrieve all properties in 
     * one round-trip.
     *
     * \return
     *     
     *     The interface name
     */
    inline QDBusPendingReply<QString> GetChannelType()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetChannelType"));
    }

    /**
     * Begins a call to the D-Bus method "GetHandle" on the remote object.
     * 
     * Returns the handle type and number if this channel represents a 
     * communication with a particular contact, room or server-stored list, or 
     * zero if it is transient and defined only by its contents. Clients 
     * SHOULD use the TargetHandle and TargetHandleType properties instead, 
     * falling back to this method only if necessary. The GetAll method lets 
     * clients retrieve all properties in one round-trip.
     *
     * \return
     *     
     *     The same as TargetHandleType.
     *
     * \return
     *     
     *     The same as TargetHandle.
     */
    inline QDBusPendingReply<uint, uint> GetHandle()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint, uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetHandle"));
    }

    /**
     * Begins a call to the D-Bus method "GetInterfaces" on the remote object.
     * 
     * Get the optional interfaces implemented by the channel. Clients SHOULD 
     * use the Interfaces property instead, falling back to this method only 
     * if necessary. The GetAll method lets clients retrieve all properties in 
     * one round-trip.
     *
     * \return
     *     
     *     An array of the D-Bus interface names
     */
    inline QDBusPendingReply<QStringList> GetInterfaces()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetInterfaces"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "Closed" on the remote object.
     * 
     * Emitted when the channel has been closed. Method calls on the channel 
     * are no longer valid after this signal has been emitted, and the 
     * connection manager may then remove the object from the bus at any point.
     */
    void Closed();

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceCallStateInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.CallState."
 */
class ChannelInterfaceCallStateInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.CallState", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.CallState";
    }

    /**
     * Creates a ChannelInterfaceCallStateInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceCallStateInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceCallStateInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceCallStateInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceCallStateInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceCallStateInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceCallStateInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceCallStateInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceCallStateInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceCallStateInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetCallStates" on the remote object.
     * 
     * Get the current call states for all contacts involved in this call.
     *
     * \return
     *     
     *     The current call states. Participants where the call state flags 
     *     would be 0 (all unset) may be omitted from this mapping.
     */
    inline QDBusPendingReply<Tp::ChannelCallStateMap> GetCallStates()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ChannelCallStateMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetCallStates"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "CallStateChanged" on the remote object.
     * 
     * Emitted when the state of a member of the channel has changed.
     *
     * \param contact
     *     
     *     An integer handle for the contact.
     *
     * \param state
     *     
     *     The new state for this contact.
     */
    void CallStateChanged(uint contact, uint state);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceChatStateInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.ChatState."
 */
class ChannelInterfaceChatStateInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.ChatState", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.ChatState";
    }

    /**
     * Creates a ChannelInterfaceChatStateInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceChatStateInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceChatStateInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceChatStateInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceChatStateInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceChatStateInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceChatStateInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceChatStateInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceChatStateInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceChatStateInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "SetChatState" on the remote object.
     * 
     * Set the local state and notify other members of the channel that it has 
     * changed.
     *
     * \param state
     *     
     *     The new state.
     */
    inline QDBusPendingReply<> SetChatState(uint state)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(state);
        return asyncCallWithArgumentList(QLatin1String("SetChatState"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "ChatStateChanged" on the remote object.
     * 
     * Emitted when the state of a member of the channel has changed. This 
     * includes local state.
     *
     * \param contact
     *     
     *     An integer handle for the contact.
     *
     * \param state
     *     
     *     The new state of this contact.
     */
    void ChatStateChanged(uint contact, uint state);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceDTMFInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.DTMF."
 */
class ChannelInterfaceDTMFInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.DTMF", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.DTMF";
    }

    /**
     * Creates a ChannelInterfaceDTMFInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceDTMFInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceDTMFInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceDTMFInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceDTMFInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceDTMFInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceDTMFInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceDTMFInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceDTMFInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceDTMFInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "StartTone" on the remote object.
     * 
     * Start sending a DTMF tone on this stream. Where possible, the tone will 
     * continue until StopTone is called. On certain protocols, it may only be 
     * possible to send events with a predetermined length. In this case, the 
     * implementation may emit a fixed-length tone, and the StopTone method 
     * call should return NotAvailable.
     *
     * \param streamID
     *     
     *     A stream ID as defined in the StreamedMedia channel type.
     *
     * \param event
     *     
     *     A numeric event code from the DTMF_Event enum.
     */
    inline QDBusPendingReply<> StartTone(uint streamID, uchar event)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(streamID) << QVariant::fromValue(event);
        return asyncCallWithArgumentList(QLatin1String("StartTone"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "StopTone" on the remote object.
     * 
     * Stop sending any DTMF tone which has been started using the StartTone 
     * method. If there is no current tone, this method will do nothing.
     *
     * \param streamID
     *     
     *     A stream ID as defined in the StreamedMedia channel type.
     */
    inline QDBusPendingReply<> StopTone(uint streamID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(streamID);
        return asyncCallWithArgumentList(QLatin1String("StopTone"), argumentList);
    }

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceGroupInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.Group."
 */
class ChannelInterfaceGroupInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.Group", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.Group";
    }

    /**
     * Creates a ChannelInterfaceGroupInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceGroupInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceGroupInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceGroupInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceGroupInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceGroupInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceGroupInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceGroupInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceGroupInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceGroupInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "GroupFlags" on the remote object.
     * 
     * An integer representing the bitwise-OR of flags on this channel. The 
     * user interface can use this to present information about which 
     * operations are currently valid. Change notification is via the 
     * GroupFlagsChanged signal.
     */
    Q_PROPERTY(uint GroupFlags READ GroupFlags)

    /**
     * Getter for the remote object property "GroupFlags".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint GroupFlags() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("GroupFlags"));
    }

    /**
     * Represents property "HandleOwners" on the remote object.
     * 
     * A map from channel-specific handles to their owners, including at least 
     * all of the channel-specific handles in this channel&apos;s members, 
     * local-pending or remote-pending sets as keys. Any handle not in the 
     * keys of this mapping is not channel-specific in this channel. Handles 
     * which are channel-specific, but for which the owner is unknown, MUST 
     * appear in this mapping with 0 as owner. Change notification is via the 
     * HandleOwnersChanged signal.
     */
    Q_PROPERTY(Tp::HandleOwnerMap HandleOwners READ HandleOwners)

    /**
     * Getter for the remote object property "HandleOwners".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::HandleOwnerMap HandleOwners() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::HandleOwnerMap>(internalPropGet("HandleOwners"));
    }

    /**
     * Represents property "LocalPendingMembers" on the remote object.
     * 
     * An array of structs containing handles representing contacts requesting 
     * channel membership and awaiting local approval with AddMembers.
     */
    Q_PROPERTY(Tp::LocalPendingInfoList LocalPendingMembers READ LocalPendingMembers)

    /**
     * Getter for the remote object property "LocalPendingMembers".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::LocalPendingInfoList LocalPendingMembers() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::LocalPendingInfoList>(internalPropGet("LocalPendingMembers"));
    }

    /**
     * Represents property "Members" on the remote object.
     * 
     * The members of this channel.
     */
    Q_PROPERTY(Tp::UIntList Members READ Members)

    /**
     * Getter for the remote object property "Members".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::UIntList Members() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::UIntList>(internalPropGet("Members"));
    }

    /**
     * Represents property "RemotePendingMembers" on the remote object.
     * 
     * An array of handles representing contacts who have been invited to the 
     * channel and are awaiting remote approval.
     */
    Q_PROPERTY(Tp::UIntList RemotePendingMembers READ RemotePendingMembers)

    /**
     * Getter for the remote object property "RemotePendingMembers".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::UIntList RemotePendingMembers() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::UIntList>(internalPropGet("RemotePendingMembers"));
    }

    /**
     * Represents property "SelfHandle" on the remote object.
     * 
     * The handle for the user on this channel (which can also be a local or 
     * remote pending member), or 0 if the user is not a member at all (which 
     * is likely to be the case, for instance, on ContactList channels). Note 
     * that this is different from the result of Connection.GetSelfHandle on 
     * some protocols, so the value of this handle should always be used with 
     * the methods of this interface.
     */
    Q_PROPERTY(uint SelfHandle READ SelfHandle)

    /**
     * Getter for the remote object property "SelfHandle".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint SelfHandle() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("SelfHandle"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AddMembers" on the remote object.
     * 
     * <p>Invite all the given contacts into the channel, or accept requests for
     *   channel membership for contacts on the pending local list.</p>
     * 
     * <p>A message may be provided along with the request, which will be sent
     * to the server if supported. See the CHANNEL_GROUP_FLAG_MESSAGE_ADD and
     * CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT
     * <tp:member-ref>GroupFlags</tp:member-ref> to see in which cases this
     * message should be provided.</p>
     * 
     * <p>Attempting to add contacts who are already members is allowed;
     *   connection managers must silently accept this, without error.</p>
     *
     * \param contacts
     *     
     *     An array of contact handles to invite to the channel
     *
     * \param message
     *     
     *     A string message, which can be blank if desired
     */
    inline QDBusPendingReply<> AddMembers(const Tp::UIntList& contacts, const QString& message)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts) << QVariant::fromValue(message);
        return asyncCallWithArgumentList(QLatin1String("AddMembers"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetAllMembers" on the remote object.
     * 
     * Returns arrays of all current, local and remote pending channel members.
     *
     * \return
     *     
     *     array of handles of current members
     *
     * \return
     *     
     *     array of handles of local pending members
     *
     * \return
     *     
     *     array of handles of remote pending members
     */
    inline QDBusPendingReply<Tp::UIntList, Tp::UIntList, Tp::UIntList> GetAllMembers()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList, Tp::UIntList, Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAllMembers"));
    }

    /**
     * Begins a call to the D-Bus method "GetGroupFlags" on the remote object.
     * 
     * Returns the value of the GroupFlags property.
     *
     * \return
     *     
     *     The value of the GroupFlags property
     */
    inline QDBusPendingReply<uint> GetGroupFlags()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetGroupFlags"));
    }

    /**
     * Begins a call to the D-Bus method "GetHandleOwners" on the remote object.
     * 
     * If the CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES flag is set on the 
     * channel, then the handles of the group members are specific to this 
     * channel, and are not meaningful in a connection-wide context such as 
     * contact lists. This method allows you to find the owner of the handle 
     * if it can be discovered in this channel, or 0 if the owner is not 
     * available.
     *
     * \param handles
     *     
     *     A list of integer handles representing members of the channel
     *
     * \return
     *     
     *     An array of integer handles representing the owner handles of the 
     *     given room members, in the same order, or 0 if the owner is not 
     *     available
     */
    inline QDBusPendingReply<Tp::UIntList> GetHandleOwners(const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("GetHandleOwners"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetLocalPendingMembers" on the remote object.
     * 
     * Returns the To_Be_Added handle (only) for each structure in the 
     * LocalPendingMembers property.
     */
    inline QDBusPendingReply<Tp::UIntList> GetLocalPendingMembers()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetLocalPendingMembers"));
    }

    /**
     * Begins a call to the D-Bus method "GetLocalPendingMembersWithInfo" on the remote object.
     * 
     * Returns the LocalPendingMembers property.
     *
     * \return
     *     
     *     An array of structs containing: A handle representing the contact 
     *     requesting channel membership A handle representing the contact 
     *     making the request, or 0 if unknown The reason for the request: one 
     *     of the values of Channel_Group_Change_Reason A string message 
     *     containing the reason for the request if any (or blank if none)
     */
    inline QDBusPendingReply<Tp::LocalPendingInfoList> GetLocalPendingMembersWithInfo()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::LocalPendingInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetLocalPendingMembersWithInfo"));
    }

    /**
     * Begins a call to the D-Bus method "GetMembers" on the remote object.
     * 
     * Returns the Members property.
     */
    inline QDBusPendingReply<Tp::UIntList> GetMembers()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetMembers"));
    }

    /**
     * Begins a call to the D-Bus method "GetRemotePendingMembers" on the remote object.
     * 
     * Returns an array of handles representing contacts who have been invited 
     * to the channel and are awaiting remote approval.
     */
    inline QDBusPendingReply<Tp::UIntList> GetRemotePendingMembers()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetRemotePendingMembers"));
    }

    /**
     * Begins a call to the D-Bus method "GetSelfHandle" on the remote object.
     * 
     * Returns the value of the SelfHandle property.
     */
    inline QDBusPendingReply<uint> GetSelfHandle()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetSelfHandle"));
    }

    /**
     * Begins a call to the D-Bus method "RemoveMembers" on the remote object.
     * 
     * <p>Requests the removal of contacts from a channel, reject their
     *   request for channel membership on the pending local list, or
     *   rescind their invitation on the pending remote list.</p>
     * 
     * <p>If the <tp:member-ref>SelfHandle</tp:member-ref> is in a Group,
     *   it can be removed via this method, in order to leave the group
     *   gracefully. This is the recommended way to leave a chatroom, close
     *   or reject a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
     *   call, and so on.</p>
     * 
     * <p>Accordingly, connection managers SHOULD support
     *   doing this, regardless of the value of
     *   <tp:member-ref>GroupFlags</tp:member-ref>.
     *   If doing so fails with PermissionDenied, this is considered to a bug
     *   in the connection manager, but clients MUST recover by falling back
     *   to closing the channel with the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">Close</tp:dbus-ref>
     *   method.</p>
     * 
     * <p>Removing any contact from the local pending list is always
     *   allowed. Removing contacts other than the
     *   <tp:member-ref>SelfHandle</tp:member-ref> from the channel's members
     *   is allowed if and only if Channel_Group_Flag_Can_Remove is in the
     *   <tp:member-ref>GroupFlags</tp:member-ref>,
     *   while removing contacts other than the
     *   <tp:member-ref>SelfHandle</tp:member-ref> from the remote pending list
     *   is allowed if and only if Channel_Group_Flag_Can_Rescind is in the
     *   <tp:member-ref>GroupFlags</tp:member-ref>.</p>
     * 
     * <p>A message may be provided along with the request, which will be
     *   sent to the server if supported. See the
     *   Channel_Group_Flag_Message_Remove,
     *   Channel_Group_Flag_Message_Depart,
     *   Channel_Group_Flag_Message_Reject and
     *   Channel_Group_Flag_Message_Rescind
     *   <tp:member-ref>GroupFlags</tp:member-ref> to see in which cases this
     *   message should be provided.</p>
     *
     * \param contacts
     *     
     *     An array of contact handles to remove from the channel
     *
     * \param message
     *     
     *     A string message, which can be blank if desired
     */
    inline QDBusPendingReply<> RemoveMembers(const Tp::UIntList& contacts, const QString& message)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts) << QVariant::fromValue(message);
        return asyncCallWithArgumentList(QLatin1String("RemoveMembers"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RemoveMembersWithReason" on the remote object.
     * 
     * As RemoveMembers, but a reason code may be provided where appropriate. 
     * The reason code may be ignored if the underlying protocol is unable to 
     * represent the given reason.
     *
     * \param contacts
     *     
     *     An array of contact handles to remove from the channel
     *
     * \param message
     *     
     *     A string message, which can be blank if desired
     *
     * \param reason
     *     
     *     A reason for the change
     */
    inline QDBusPendingReply<> RemoveMembersWithReason(const Tp::UIntList& contacts, const QString& message, uint reason)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts) << QVariant::fromValue(message) << QVariant::fromValue(reason);
        return asyncCallWithArgumentList(QLatin1String("RemoveMembersWithReason"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "HandleOwnersChanged" on the remote object.
     * 
     * Emitted whenever the HandleOwners property changes.
     *
     * \param added
     *     
     *     A map from channel-specific handles to their owners, in which the 
     *     keys include all the handles that were added to the keys of the 
     *     HandleOwners property, and all the handles in that property whose 
     *     owner has changed
     *
     * \param removed
     *     
     *     The channel-specific handles that were removed from the keys of the 
     *     HandleOwners property, as a result of the contact leaving this 
     *     group in a previous MembersChanged signal
     */
    void HandleOwnersChanged(const Tp::HandleOwnerMap& added, const Tp::UIntList& removed);

    /**
     * Represents the signal "SelfHandleChanged" on the remote object.
     * 
     * Emitted whenever the SelfHandle property changes.
     *
     * \param selfHandle
     *     
     *     The new value of the SelfHandle property.
     */
    void SelfHandleChanged(uint selfHandle);

    /**
     * Represents the signal "GroupFlagsChanged" on the remote object.
     * 
     * Emitted when the flags as returned by GetGroupFlags are changed. The 
     * user interface should be updated as appropriate.
     *
     * \param added
     *     
     *     A bitwise OR of the flags which have been set
     *
     * \param removed
     *     
     *     A bitwise OR of the flags which have been cleared
     */
    void GroupFlagsChanged(uint added, uint removed);

    /**
     * Represents the signal "MembersChanged" on the remote object.
     * 
     * <p>Emitted when contacts join any of the three lists (members, local
     *   pending or remote pending) or when they leave any of the three lists.
     *   There may also be a message from the server regarding this change,
     *   which may be displayed to the user if desired.</p>
     * 
     * <p>All channel-specific handles that are mentioned in this signal
     *   MUST be represented in the value of the
     *   <tp:member-ref>HandleOwners</tp:member-ref> property.
     *   In practice, this will mean that
     *   <tp:member-ref>HandleOwnersChanged</tp:member-ref> is
     *   emitted <em>before</em> emitting a MembersChanged signal in which
     *   channel-specific handles are added, but that it is emitted
     *   <em>after</em> emitting a MembersChanged signal in which
     *   channel-specific handles are removed.</p>
     *
     * \param message
     *     
     *     A string message from the server, or blank if not
     *
     * \param added
     *     
     *     A list of members added to the channel
     *
     * \param removed
     *     
     *     A list of members removed from the channel
     *
     * \param localPending
     *     
     *     A list of members who are pending local approval
     *
     * \param remotePending
     *     
     *     A list of members who are pending remote approval
     *
     * \param actor
     *     
     *     The contact handle of the person who made the change, or 0 if not 
     *     known
     *
     * \param reason
     *     
     *     A reason for the change
     */
    void MembersChanged(const QString& message, const Tp::UIntList& added, const Tp::UIntList& removed, const Tp::UIntList& localPending, const Tp::UIntList& remotePending, uint actor, uint reason);

    /**
     * Represents the signal "MembersChangedDetailed" on the remote object.
     * 
     * <p>Emitted when contacts join any of the three lists (members, local
     *   pending or remote pending) or when they leave any of the three
     *   lists. This signal provides a superset of the information provided by
     *   <tp:member-ref>MembersChanged</tp:member-ref>;
     *   if the channel's <tp:member-ref>GroupFlags</tp:member-ref>
     *   contains Members_Changed_Detailed, then clients may listen exclusively
     *   to this signal in preference to that signal.</p>
     * 
     * <p>All channel-specific handles that are mentioned in this signal
     *   MUST be represented in the value of the
     *   <tp:member-ref>HandleOwners</tp:member-ref> property.  In practice,
     *   this will mean that
     *   <tp:member-ref>HandleOwnersChanged</tp:member-ref> is emitted
     *   <em>before</em> emitting a MembersChangedDetailed signal in which
     *   channel-specific handles are added, but that it is emitted
     *   <em>after</em> emitting a MembersChangedDetailed signal in which
     *   channel-specific handles are removed.</p>
     *
     * \param added
     *     
     *     A list of members added to the channel
     *
     * \param removed
     *     
     *     A list of members removed from the channel
     *
     * \param localPending
     *     
     *     A list of members who are pending local approval
     *
     * \param remotePending
     *     
     *     A list of members who are pending remote approval
     *
     * \param details
     *     
     *     <p>Information about the change, which may include the following
     *       well-known keys:</p>
     *     
     *     <dl>
     *       <dt>actor (u — <tp:type>Contact_Handle</tp:type>)</dt>
     *       <dd>The contact handle of the person who made the change; 0 or
     *         omitted if unknown or not applicable.</dd>
     *     
     *       <dt>change-reason (u — <tp:type>Channel_Group_Change_Reason</tp:type>)</dt>
     *       <dd>A reason for the change.</dd>
     *     
     *       <dt>contact-ids (a{us} — <tp:type>Handle_Identifier_Map</tp:type>)</dt>
     *       <dd>
     *         <p>The string identifiers for handles mentioned in this signal, to
     *         give clients the minimal information necessary to react to the
     *         event without waiting for round-trips.  Connection managers
     *         SHOULD include the identifiers for members added to the group and
     *         for the actor (if any); they MAY omit the identifiers for handles
     *         which have been removed from the group.</p>
     *     
     *         <tp:rationale>
     *           <p>On IRC, an event such as a netsplit could cause the vast
     *           majority of a channel to leave.  Given that clients should
     *           already know the identifiers of a channel's members, including
     *           potentially hundreds of strings in the netsplit signal is
     *           unnecessary.</p>
     *         </tp:rationale>
     *     
     *         <p>Clients MUST NOT assume that the presence or absence of a
     *           handle in this mapping is meaningful. This mapping is merely
     *           an optimization for round-trip reduction, and connection
     *           managers MAY add additional handles, omit some handles, or
     *           omit the mapping completely.</p>
     *       </dd>
     *     
     *       <dt>message (s)</dt>
     *       <dd>A string message from the server regarding the change</dd>
     *     
     *       <dt>error (s — <tp:type>DBus_Error_Name</tp:type>)</dt>
     *       <dd>A (possibly implementation-specific) DBus error describing the
     *         change, providing more specific information than the
     *         <tp:type>Channel_Group_Change_Reason</tp:type> enum allows. This
     *         MUST only be present if it is strictly more informative than
     *         'change-reason'; if present, 'change-reason' MUST be set to the
     *         closest available reason.
     *     
     *         <tp:rationale>
     *           A SIP connection manager might want to signal &quot;402 Payment
     *           required&quot; as something more specific than Error or
     *           Permission_Denied so that a SIP-aware UI could handle it
     *           specially; including a namespaced error permits this to be done
     *           without <tp:type>Channel_Group_Change_Reason</tp:type> being
     *           extended to encompass every error any CM ever wants to report.
     *         </tp:rationale>
     *       </dd>
     *     
     *       <dt>debug-message (s)</dt>
     *       <dd>Debugging information on the change. SHOULD NOT be shown to
     *         users in normal circumstances.</dd>
     *     </dl>
     */
    void MembersChangedDetailed(const Tp::UIntList& added, const Tp::UIntList& removed, const Tp::UIntList& localPending, const Tp::UIntList& remotePending, const QVariantMap& details);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceHoldInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.Hold."
 */
class ChannelInterfaceHoldInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.Hold", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.Hold";
    }

    /**
     * Creates a ChannelInterfaceHoldInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceHoldInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceHoldInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceHoldInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceHoldInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceHoldInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceHoldInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceHoldInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceHoldInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceHoldInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetHoldState" on the remote object.
     * 
     * Return whether the local user has placed the channel on hold.
     *
     * \return
     *     
     *     The state of the channel
     *
     * \return
     *     
     *     The reason why the channel is in that state
     */
    inline QDBusPendingReply<uint, uint> GetHoldState()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint, uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetHoldState"));
    }

    /**
     * Begins a call to the D-Bus method "RequestHold" on the remote object.
     * 
     * <p>Request that the channel be put on hold (be instructed not to send
     *   any media streams to you) or be taken off hold.</p>
     * 
     * <p>If the connection manager can immediately tell that the requested
     *   state change could not possibly succeed, this method SHOULD
     *   return the NotAvailable error. If the requested state is the
     *   same as the current state, this method SHOULD return successfully
     *   without doing anything.</p>
     * 
     * <p>Otherwise, this method SHOULD immediately set the hold state to
     *   Local_Hold_State_Pending_Hold or Local_Hold_State_Pending_Unhold
     *   (as appropriate), emitting
     *   <tp:member-ref>HoldStateChanged</tp:member-ref> if this is a change,
     *   and return successfully.</p>
     * 
     * <p>The eventual success or failure of the request is indicated by a
     *   subsequent HoldStateChanged signal, changing the hold state to
     *   Local_Hold_State_Held or Local_Hold_State_Unheld.</p>
     * 
     * <p>If the channel has multiple streams, and the connection manager
     *   succeeds in changing the hold state of one stream but fails to
     *   change the hold state of another, it SHOULD attempt to revert
     *   all streams to their previous hold states.</p>
     * 
     * <p>The following state transitions SHOULD be used, where
     *   appropriate:</p>
     * 
     * <ul>
     *   <li>Successful hold:
     *     (Unheld, any reason) → (Pending_Hold, Requested) →
     *     (Held, Requested)
     *   </li>
     *   <li>Successful unhold:
     *     (Held, any reason) → (Pending_Unhold, Requested) →
     *     (Unheld, Requested)
     *   </li>
     *   <li>Attempting to unhold fails at the first attempt to acquire a
     *     resource:
     *     (Held, any reason) → (Pending_Unhold, Requested) →
     *     (Held, Resource_Not_Available)
     *   </li>
     *   <li>Attempting to unhold acquires one resource, but fails to acquire
     *     a second, and takes time to release the first:
     *     (Held, any reason) → (Pending_Unhold, Requested) →
     *     (Pending_Hold, Resource_Not_Available) →
     *     (Held, Resource_Not_Available)
     *   </li>
     * </ul>
     *
     * \param hold
     *     
     *     A boolean indicating whether or not the channel should be on hold
     */
    inline QDBusPendingReply<> RequestHold(bool hold)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(hold);
        return asyncCallWithArgumentList(QLatin1String("RequestHold"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "HoldStateChanged" on the remote object.
     * 
     * Emitted to indicate that the hold state has changed for this channel. 
     * This may occur as a consequence of you requesting a change with 
     * RequestHold, or the state changing as a result of a request from 
     * another process.
     *
     * \param holdState
     *     
     *     The state of the channel
     *
     * \param reason
     *     
     *     The reason for the state change
     */
    void HoldStateChanged(uint holdState, uint reason);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceMediaSignallingInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.MediaSignalling."
 */
class ChannelInterfaceMediaSignallingInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.MediaSignalling", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.MediaSignalling";
    }

    /**
     * Creates a ChannelInterfaceMediaSignallingInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMediaSignallingInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceMediaSignallingInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMediaSignallingInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceMediaSignallingInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceMediaSignallingInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceMediaSignallingInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceMediaSignallingInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceMediaSignallingInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMediaSignallingInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetSessionHandlers" on the remote object.
     * 
     * Returns all currently active session handlers on this channel as a list 
     * of (session_handler_path, type).
     */
    inline QDBusPendingReply<Tp::MediaSessionHandlerInfoList> GetSessionHandlers()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::MediaSessionHandlerInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetSessionHandlers"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "NewSessionHandler" on the remote object.
     * 
     * Signal that a session handler object has been created. The client 
     * should create a session object and create streams for the streams 
     * within.
     *
     * \param sessionHandler
     *     
     *     Object path of the new Media.SessionHandler object
     *
     * \param sessionType
     *     
     *     String indicating type of session, eg &quot;rtp&quot;
     */
    void NewSessionHandler(const QDBusObjectPath& sessionHandler, const QString& sessionType);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceMessagesInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.Messages."
 */
class ChannelInterfaceMessagesInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.Messages", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.Messages";
    }

    /**
     * Creates a ChannelInterfaceMessagesInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMessagesInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceMessagesInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMessagesInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceMessagesInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceMessagesInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceMessagesInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceMessagesInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceMessagesInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceMessagesInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "SupportedContentTypes" on the remote object.
     * 
     * <p>A list of MIME types supported by this channel, with more preferred
     *   MIME types appearing earlier in the list. The list MAY include &quot;&#42;&#47;*&quot;
     *   to indicate that attachments with arbitrary MIME types can be sent.
     *   This list MUST NOT be empty, since all Messages implementations
     *   MUST accept messages containing a single &quot;text/plain&quot; part.</p>
     * 
     * <p>Some examples of how this property interacts with the
     *   <tp:member-ref>MessagePartSupportFlags</tp:member-ref>:</p>
     * 
     * <dl>
     *   <dt>A simple IM implementation: only plain text messages are
     *     allowed</dt>
     *   <dd>SupportedContentTypes = ['text/plain'],
     *     MessagePartSupportFlags = 0</dd>
     * 
     *   <dt>Formatted text with a plain text alternative is allowed (see the
     *     HTML interface draft)</dt>
     *   <dd>SupportedContentTypes = ['text/html', 'text/plain'],
     *     MessagePartSupportFlags = 0</dd>
     * 
     *   <dt>JPEG or PNG images may be sent, but without any attached
     *     text</dt>
     *   <dd>SupportedContentTypes = ['text/plain', 'image/jpeg',
     *     'image/png'], MessagePartSupportFlags = 0</dd>
     * 
     *   <dt>Unformatted text to which an optional JPEG or PNG image may be
     *     attached</dt>
     *   <dd>SupportedContentTypes = ['text/plain', 'image/jpeg',
     *     'image/png'], MessagePartSupportFlags = One_Attachment</dd>
     * 
     *   <dt>Formatted text to which arbitrarily many images may be
     *     attached</dt>
     *   <dd>SupportedContentTypes = ['text/html', 'text/plain', 'image/jpeg',
     *     'image/png', 'image/x-ms-bmp'], MessagePartSupportFlags =
     *     One_Attachment | Multiple_Attachments</dd>
     * 
     *   <dt>A full SIP implementation: arbitrary MIME messages are
     *     allowed</dt>
     *   <dd>SupportedContentTypes = ['&#42;&#47;*'], MessagePartSupportFlags =
     *     One_Attachment | Multiple_Attachments</dd>
     * </dl>
     */
    Q_PROPERTY(QStringList SupportedContentTypes READ SupportedContentTypes)

    /**
     * Getter for the remote object property "SupportedContentTypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList SupportedContentTypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("SupportedContentTypes"));
    }

    /**
     * Represents property "MessagePartSupportFlags" on the remote object.
     * 
     * Flags indicating the level of support for message parts on this channel.
     */
    Q_PROPERTY(uint MessagePartSupportFlags READ MessagePartSupportFlags)

    /**
     * Getter for the remote object property "MessagePartSupportFlags".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MessagePartSupportFlags() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MessagePartSupportFlags"));
    }

    /**
     * Represents property "PendingMessages" on the remote object.
     * 
     * A list of incoming messages that have neither been acknowledged nor 
     * rejected. This list is a more detailed version of the one returned by 
     * Text.ListPendingMessages, and contains the same messages, uniquely 
     * identified by the same pending message IDs. Its items can be removed 
     * using Text.AcknowledgePendingMessages.
     */
    Q_PROPERTY(Tp::MessagePartListList PendingMessages READ PendingMessages)

    /**
     * Getter for the remote object property "PendingMessages".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::MessagePartListList PendingMessages() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::MessagePartListList>(internalPropGet("PendingMessages"));
    }

    /**
     * Represents property "DeliveryReportingSupport" on the remote object.
     * 
     * A bitfield indicating features supported by this channel.
     */
    Q_PROPERTY(uint DeliveryReportingSupport READ DeliveryReportingSupport)

    /**
     * Getter for the remote object property "DeliveryReportingSupport".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint DeliveryReportingSupport() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("DeliveryReportingSupport"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "SendMessage" on the remote object.
     * 
     * <p>Submit a message to the server for sending.
     *   If this method returns successfully, the message has been submitted
     *   to the server and the <tp:member-ref>MessageSent</tp:member-ref>
     *   signal is emitted. A corresponding
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Sent</tp:dbus-ref>
     *   signal on the Text interface MUST also be emitted.</p>
     * 
     * <p>This method MUST return before the MessageSent signal is
     *   emitted.</p>
     * 
     * <tp:rationale>
     *   <p>This means that the process sending the message is the first
     *     to see the <tp:type>Protocol_Message_Token</tp:type>, and can
     *     relate the message to the corresponding
     *     <tp:member-ref>MessageSent</tp:member-ref> signal by comparing
     *     message tokens (if supported by the protocol).</p>
     * </tp:rationale>
     * 
     * <p>If this method fails, message submission to the server has failed
     *   and no signal on this interface (or the Text interface) is
     *   emitted.</p>
     *
     * \param message
     *     
     *     The message content, including any attachments or alternatives
     *
     * \param flags
     *     
     *     Flags affecting how the message is sent.
     *
     * \return
     *     
     *     An opaque token used to match any incoming delivery or failure 
     *     reports against this message, or an empty string if the message is 
     *     not readily identifiable.
     */
    inline QDBusPendingReply<QString> SendMessage(const Tp::MessagePartList& message, uint flags)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(message) << QVariant::fromValue(flags);
        return asyncCallWithArgumentList(QLatin1String("SendMessage"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetPendingMessageContent" on the remote object.
     * 
     * Retrieve the content of one or more parts of a pending message. Note 
     * that this function may take a considerable amount of time to return if 
     * the part&apos;s &apos;needs-retrieval&apos; flag is true; consider 
     * extending the default D-Bus method call timeout. Additional API is 
     * likely to be added in future, to stream large message parts.
     *
     * \param messageID
     *     
     *     The ID of a pending message
     *
     * \param parts
     *     
     *     The desired entries in the array of message parts, identified by 
     *     their position. The &quot;headers&quot; part (which is not a valid 
     *     argument to this method) is considered to be part 0, so the valid 
     *     part numbers start at 1 (for the second Message_Part).
     *
     * \return
     *     
     *     <p>The content of the requested parts. The keys in this mapping
     *       are positions in the array of message parts; the values are
     *       either of type 's' or 'ay' (UTF-8 text string, or byte array),
     *       following the same rules as for the value of the 'content' key in
     *       the <tp:type>Message_Part</tp:type> mappings.</p>
     *     
     *     <p>If the one of the requested part numbers was greater than zero
     *       but referred to a part that had no content (i.e. it had no
     *       'content-type' key or no 'content' key), it is simply omitted from
     *       this mapping; this is not considered to be an error condition.</p>
     */
    inline QDBusPendingReply<Tp::MessagePartContentMap> GetPendingMessageContent(uint messageID, const Tp::UIntList& parts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::MessagePartContentMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(messageID) << QVariant::fromValue(parts);
        return asyncCallWithArgumentList(QLatin1String("GetPendingMessageContent"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "MessageSent" on the remote object.
     * 
     * <p>Signals that a message has been submitted for sending. This
     *   MUST be emitted exactly once per emission of the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.Text">Sent</tp:dbus-ref>
     *   signal on the Text interface. This SHOULD be emitted as soon as
     *   the CM determines it's theoretically possible to send the message
     *   (e.g. the parameters are supported and correct).</p>
     * 
     * <tp:rationale>
     *   <p>This signal allows a process that is not the caller of
     *     SendMessage to log sent messages. The double signal-emission
     *     provides compatibility with older clients. Clients supporting
     *     Messages should listen for Messages.MessageSent only (if the
     *     channel has the Messages interface) or Text.Sent only
     *     (otherwise).</p>
     * </tp:rationale>
     *
     * \param content
     *     
     *     <p>The message content (see <tp:type>Message_Part</tp:type> for full
     *       details). If the message that was passed to SendMessage has a
     *       formatted text part that the connection manager recognises, but no
     *       text/plain alternative, the CM MUST use the formatted text part to
     *       generate a text/plain alternative which is also included in this
     *       signal argument.</p>
     *     
     *     <p>If the connection manager can predict that the message will be
     *       altered during transmission, this argument SHOULD reflect what
     *       other contacts will receive, rather than being a copy of the
     *       argument to SendMessage (if the message is truncated,
     *       formatting or alternatives are dropped, etc., then the edited
     *       version SHOULD appear in this signal).</p>
     *
     * \param flags
     *     
     *     Flags affecting how the message was sent. The flags might be a 
     *     subset of those passed to SendMessage if the caller requested 
     *     unsupported flags.
     *
     * \param messageToken
     *     
     *     An opaque token used to match any incoming delivery or failure 
     *     reports against this message, or an empty string if the message is 
     *     not readily identifiable.
     */
    void MessageSent(const Tp::MessagePartList& content, uint flags, const QString& messageToken);

    /**
     * Represents the signal "PendingMessagesRemoved" on the remote object.
     * 
     * The messages with the given IDs have been removed from the 
     * PendingMessages list. Clients SHOULD NOT attempt to acknowledge those 
     * messages. This completes change notification for the PendingMessages 
     * property (previously, there was change notification when pending 
     * messages were added, but not when they were removed).
     *
     * \param messageIDs
     *     
     *     The messages that have been removed from the pending message list.
     */
    void PendingMessagesRemoved(const Tp::UIntList& messageIDs);

    /**
     * Represents the signal "MessageReceived" on the remote object.
     * 
     * Signals that a message has been received and added to the pending 
     * messages queue. This MUST be emitted exactly once per emission of the 
     * Received signal on the Text interface. The double signal-emission 
     * provides compatibility with older clients. Clients supporting Messages 
     * should listen for Messages.MessageReceived only (if the channel has the 
     * Messages interface) or Text.Received only (otherwise).
     *
     * \param message
     *     
     *     The message content, including any attachments or alternatives
     */
    void MessageReceived(const Tp::MessagePartList& message);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfacePasswordInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.Password."
 */
class ChannelInterfacePasswordInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.Password", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.Password";
    }

    /**
     * Creates a ChannelInterfacePasswordInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfacePasswordInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfacePasswordInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfacePasswordInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfacePasswordInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfacePasswordInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfacePasswordInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfacePasswordInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfacePasswordInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfacePasswordInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetPasswordFlags" on the remote object.
     * 
     * Returns the bitwise-OR of the flags relevant to the password on this 
     * channel. The user interface can use this to present information about 
     * which operations are currently valid.
     *
     * \return
     *     
     *     An integer with the logical OR of all the flags set (values of 
     *     ChannelPasswordFlags)
     */
    inline QDBusPendingReply<uint> GetPasswordFlags()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetPasswordFlags"));
    }

    /**
     * Begins a call to the D-Bus method "ProvidePassword" on the remote object.
     * 
     * Provide the password so that the channel can be joined. Must be called 
     * with the correct password in order for channel joining to proceed if 
     * the &apos;provide&apos; password flag is set.
     *
     * \param password
     *     
     *     The password
     *
     * \return
     *     
     *     A boolean indicating whether or not the password was correct
     */
    inline QDBusPendingReply<bool> ProvidePassword(const QString& password)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<bool>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(password);
        return asyncCallWithArgumentList(QLatin1String("ProvidePassword"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "PasswordFlagsChanged" on the remote object.
     * 
     * Emitted when the flags as returned by GetPasswordFlags are changed. The 
     * user interface should be updated as appropriate.
     *
     * \param added
     *     
     *     A bitwise OR of the flags which have been set
     *
     * \param removed
     *     
     *     A bitwise OR of the flags which have been cleared
     */
    void PasswordFlagsChanged(uint added, uint removed);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelInterfaceTubeInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Interface.Tube."
 */
class ChannelInterfaceTubeInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Interface.Tube", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Interface.Tube";
    }

    /**
     * Creates a ChannelInterfaceTubeInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceTubeInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceTubeInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceTubeInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelInterfaceTubeInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelInterfaceTubeInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelInterfaceTubeInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelInterfaceTubeInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelInterfaceTubeInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelInterfaceTubeInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Parameters" on the remote object.
     * 
     *         <p>Each tube has a dictionary of arbitrary parameters. Parameters are
     *           commonly used to bootstrap legacy protocols where you can't
     *           negotiate parameters in-band. The allowable keys,
     *           types and values are defined by the service, but connection managers
     *           must support the value being a string (D-Bus type <tt>'s'</tt>),
     *           array of bytes (D-Bus type <tt>'ay'</tt>), unsigned integer (D-Bus
     *           type <tt>'u'</tt>), integer (D-Bus type <tt>'i'</tt>) and boolean
     *           (D-Bus type <tt>'b'</tt>).</p>
     * 
     *         <p>When the tube is offered, the parameters are transmitted with the
     *           offer and appear as a property of the incoming tube for other
     *           participants.</p>
     * 
     *         <p>For example, a stream tube for <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.StreamTube">Service</tp:dbus-ref>
     *           <tt>&quot;smb&quot;</tt> (<cite>Server Message Block over TCP/IP</cite>) might
     *           use the following properties, as defined in <a href="http://www.dns-sd.org/ServiceTypes.html">DNS SRV (RFC 2782)
     *           Service Types</a>:</p>
     * 
     *         <pre>
     * { 'u': 'some-username',
     *   'p': 'top-secret-password',
     *   'path': '/etc/passwd',
     * }</pre>
     * 
     *         <p>When requesting a tube with
     *           <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">CreateChannel</tp:dbus-ref>,
     *           this property MUST NOT be included in the request; instead, it is set
     *           when <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamTube.Offer</tp:dbus-ref>
     *           or <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">DBusTube.Offer</tp:dbus-ref>
     *           (as appropriate) is called. Its value is undefined until the tube is
     *           offered; once set, its value MUST NOT change.</p>
     * 
     *         <p>When receiving an incoming tube, this property is immutable and so advertised in the
     *           <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">NewChannels</tp:dbus-ref>
     *           signal.</p>
     */
    Q_PROPERTY(QVariantMap Parameters READ Parameters)

    /**
     * Getter for the remote object property "Parameters".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QVariantMap Parameters() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QVariantMap>(internalPropGet("Parameters"));
    }

    /**
     * Represents property "State" on the remote object.
     * 
     * <p>State of the tube in this channel.</p>
     * 
     * <p>When requesting a tube with
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">CreateChannel</tp:dbus-ref>,
     *   this property MUST NOT be included in the request.</p>
     */
    Q_PROPERTY(uint State READ State)

    /**
     * Getter for the remote object property "State".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint State() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("State"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "TubeChannelStateChanged" on the remote object.
     * 
     * Emitted when the state of the tube channel changes. Valid state 
     * transitions are documented with Tube_Channel_State.
     *
     * \param state
     *     
     *     The new state of the tube.
     */
    void TubeChannelStateChanged(uint state);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeContactListInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.ContactList."
 */
class ChannelTypeContactListInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.ContactList", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.ContactList";
    }

    /**
     * Creates a ChannelTypeContactListInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeContactListInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeContactListInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeContactListInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeContactListInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeContactListInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeContactListInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeContactListInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeContactListInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeContactListInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeFileTransferInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.FileTransfer."
 */
class ChannelTypeFileTransferInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.FileTransfer", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.FileTransfer";
    }

    /**
     * Creates a ChannelTypeFileTransferInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeFileTransferInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeFileTransferInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeFileTransferInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeFileTransferInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeFileTransferInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeFileTransferInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeFileTransferInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeFileTransferInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeFileTransferInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "State" on the remote object.
     * 
     * <p>The state of the file transfer as described by the
     * File_Transfer_State enum.</p>
     */
    Q_PROPERTY(uint State READ State)

    /**
     * Getter for the remote object property "State".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint State() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("State"));
    }

    /**
     * Represents property "ContentType" on the remote object.
     * 
     * <p>The file's MIME type. This cannot change once the channel has
     * been created.</p>
     * 
     * <p>This property is mandatory when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. Protocols which do not have a content-type property with file
     * transfers should set this value to application/octet-stream.</p>
     */
    Q_PROPERTY(QString ContentType READ ContentType)

    /**
     * Getter for the remote object property "ContentType".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString ContentType() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("ContentType"));
    }

    /**
     * Represents property "Filename" on the remote object.
     * 
     * <p>The name of the file on the sender's side. This is therefore given
     * as a suggested filename for the receiver. This cannot change
     * once the channel has been created.</p>
     * 
     * <p>This property should be the basename of the file being sent. For example,
     * if the sender sends the file /home/user/monkey.pdf then this property should
     * be set to monkey.pdf.</p>
     * 
     * <p>This property is mandatory when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. This property cannot be empty and MUST be set to a sensible value.</p>
     */
    Q_PROPERTY(QString Filename READ Filename)

    /**
     * Getter for the remote object property "Filename".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Filename() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Filename"));
    }

    /**
     * Represents property "Size" on the remote object.
     * 
     * <p>The size of the file. If this property is set, then the file
     * transfer is guaranteed to be this size. This cannot change once
     * the channel has been created.</p>
     * 
     * <p>When you are creating a channel with this property, its value
     * MUST be accurate and in bytes. However, when receiving a file, this
     * property still MUST be in bytes but might not be entirely accurate
     * to the byte.</p>
     * 
     * <p>This property is mandatory when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. If this information isn't provided in the protocol, connection managers MUST set it
     * to UINT64_MAX.</p>
     */
    Q_PROPERTY(qulonglong Size READ Size)

    /**
     * Getter for the remote object property "Size".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline qulonglong Size() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<qulonglong>(internalPropGet("Size"));
    }

    /**
     * Represents property "ContentHashType" on the remote object.
     * 
     * <p>The type of the <tp:member-ref>ContentHash</tp:member-ref> property.</p>
     * 
     * <p>This property is optional when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. However, if you wish to include the <tp:member-ref>ContentHash</tp:member-ref>
     * property you MUST also include this property. If you omit this property from a
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method call then its value will be assumed to be File_Hash_Type_None.</p>
     * 
     * <p>For each supported hash type, implementations SHOULD include an entry
     *   in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">RequestableChannelClasses</tp:dbus-ref>
     *   with this property fixed to that hash type. If the protocol supports
     *   offering a file without a content hash, implementations SHOULD list
     *   this property in Allowed in a requestable channel class, mapping hash
     *   types they don't understand to None.
     * </p>
     */
    Q_PROPERTY(uint ContentHashType READ ContentHashType)

    /**
     * Getter for the remote object property "ContentHashType".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint ContentHashType() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("ContentHashType"));
    }

    /**
     * Represents property "ContentHash" on the remote object.
     * 
     * <p>Hash of the contents of the file transfer, of type described
     * in the value of the <tp:member-ref>ContentHashType</tp:member-ref>
     * property.</p>
     * 
     * <p>This property is optional when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. Its value MUST correspond to the appropriate type of the
     * <tp:member-ref>ContentHashType</tp:member-ref> property. If the
     * ContentHashType property is not set, or set to File_Hash_Type_None,
     * then this property will not even be looked at.</p>
     */
    Q_PROPERTY(QString ContentHash READ ContentHash)

    /**
     * Getter for the remote object property "ContentHash".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString ContentHash() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("ContentHash"));
    }

    /**
     * Represents property "Description" on the remote object.
     * 
     * <p>Description of the file transfer. This cannot change once the
     * channel has been created.</p>
     * 
     * <p>This property is optional when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method. If this property was not provided by the remote party, connection managers MUST set it to
     * the empty string.</p>
     */
    Q_PROPERTY(QString Description READ Description)

    /**
     * Getter for the remote object property "Description".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Description() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Description"));
    }

    /**
     * Represents property "Date" on the remote object.
     * 
     * <p>The last modification time of the file being transferred. This
     * cannot change once the channel has been created</p>
     * 
     * <p>This property is optional when requesting the channel with the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>
     * method.</p>
     */
    Q_PROPERTY(qlonglong Date READ Date)

    /**
     * Getter for the remote object property "Date".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline qlonglong Date() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<qlonglong>(internalPropGet("Date"));
    }

    /**
     * Represents property "AvailableSocketTypes" on the remote object.
     * 
     * <p>A mapping from address types (members of Socket_Address_Type) to
     * arrays of access-control type (members of Socket_Access_Control)
     * that the connection manager supports for sockets with that
     * address type. For simplicity, if a CM supports offering a
     * particular type of file transfer, it is assumed to support accepting
     * it. Connection Managers MUST support at least Socket_Address_Type_IPv4.</p>
     * 
     * <p>A typical value for a host without IPv6 support:</p>
     * 
     * <pre>
     *   {
     *     Socket_Address_Type_IPv4:
     *       [Socket_Access_Control_Localhost, Socket_Access_Control_Port,
     *        Socket_Access_Control_Netmask],
     *     Socket_Address_Type_Unix:
     *       [Socket_Access_Control_Localhost, Socket_Access_Control_Credentials]
     *   }
     * </pre>
     */
    Q_PROPERTY(Tp::SupportedSocketMap AvailableSocketTypes READ AvailableSocketTypes)

    /**
     * Getter for the remote object property "AvailableSocketTypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SupportedSocketMap AvailableSocketTypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SupportedSocketMap>(internalPropGet("AvailableSocketTypes"));
    }

    /**
     * Represents property "TransferredBytes" on the remote object.
     * 
     * <p>The number of bytes that have been transferred at the time of
     * requesting the property. This will be updated as the file transfer
     * continues.</p>
     */
    Q_PROPERTY(qulonglong TransferredBytes READ TransferredBytes)

    /**
     * Getter for the remote object property "TransferredBytes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline qulonglong TransferredBytes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<qulonglong>(internalPropGet("TransferredBytes"));
    }

    /**
     * Represents property "InitialOffset" on the remote object.
     * 
     * <p>The offset in bytes from where the file should be sent. This MUST
     * be respected by both the receiver and the sender after the state
     * becomes Open, but before any data is sent or received. Until the
     * <tp:member-ref>InitialOffsetDefined</tp:member-ref> signal
     * is emitted, this property is undefined.</p>
     * 
     * <p>Before setting the <tp:member-ref>State</tp:member-ref> property to
     * Open, the connection manager MUST set the InitialOffset property,
     * possibly to 0.</p>
     * 
     * <p>This property MUST NOT change after the state of the transfer has
     * changed to Open.</p>
     */
    Q_PROPERTY(qulonglong InitialOffset READ InitialOffset)

    /**
     * Getter for the remote object property "InitialOffset".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline qulonglong InitialOffset() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<qulonglong>(internalPropGet("InitialOffset"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AcceptFile" on the remote object.
     * 
     * Accept a file transfer that&apos;s in the Pending state. The file 
     * transfer&apos;s state becomes Accepted after this method is called. At 
     * this point the client can connect to the socket. CM MUST emit 
     * InitialOffsetDefined and change the state to Open before writing to the 
     * socket. Then InitialOffset should be respected in case its value 
     * differs from the offset that was specified as an argument to AcceptFile.
     *
     * \param addressType
     *     
     *     The type of address the connection manager should listen on.
     *
     * \param accessControl
     *     
     *     The type of access control the connection manager should apply to 
     *     the socket.
     *
     * \param accessControlParam
     *     
     *     A parameter for the access control type, to be interpreted as 
     *     specified in the documentation for the Socket_Access_Control enum.
     *
     * \param offset
     *     
     *     The desired offset in bytes where the file transfer should start. 
     *     The offset is taken from the beginning of the file. Specifying an 
     *     offset of zero will start the transfer from the beginning of the 
     *     file. The offset that is actually given in the InitialOffset 
     *     property can differ from this argument where the requested offset 
     *     is not supported. (For example, some protocols do not support 
     *     offsets at all so the InitialOffset property will always be 0.)
     *
     * \return
     *     
     *     The address on which the connection manager will listen for 
     *     connections for this file transfer.
     */
    inline QDBusPendingReply<QDBusVariant> AcceptFile(uint addressType, uint accessControl, const QDBusVariant& accessControlParam, qulonglong offset)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusVariant>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(addressType) << QVariant::fromValue(accessControl) << QVariant::fromValue(accessControlParam) << QVariant::fromValue(offset);
        return asyncCallWithArgumentList(QLatin1String("AcceptFile"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ProvideFile" on the remote object.
     * 
     * Provide the file for an outgoing file transfer which has been offered. 
     * Opens a socket that the client can use to provide a file to the 
     * connection manager. The channel MUST have been requested, and will 
     * change state to Open when this method is called if its state was 
     * Accepted.
     *
     * \param addressType
     *     
     *     The type of address the connection manager should listen on.
     *
     * \param accessControl
     *     
     *     The type of access control the connection manager should apply to 
     *     the socket.
     *
     * \param accessControlParam
     *     
     *     A parameter for the access control type, to be interpreted as 
     *     specified in the documentation for the Socket_Access_Control enum.
     *
     * \return
     *     
     *     The address on which the connection manager will listen for 
     *     connections for this file transfer.
     */
    inline QDBusPendingReply<QDBusVariant> ProvideFile(uint addressType, uint accessControl, const QDBusVariant& accessControlParam)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusVariant>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(addressType) << QVariant::fromValue(accessControl) << QVariant::fromValue(accessControlParam);
        return asyncCallWithArgumentList(QLatin1String("ProvideFile"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "FileTransferStateChanged" on the remote object.
     * 
     * Emitted when the state of a file transfer changes.
     *
     * \param state
     *     
     *     The new state of the file transfer; see the File_Transfer_State 
     *     enumeration.
     *
     * \param reason
     *     
     *     The reason for the state change; see the 
     *     File_Transfer_State_Change_Reason enumeration. The value will 
     *     always be File_Transfer_State_Change_Reason_None, except when 
     *     changing state to cancelled.
     */
    void FileTransferStateChanged(uint state, uint reason);

    /**
     * Represents the signal "TransferredBytesChanged" on the remote object.
     * 
     * Emitted when the number of transferred bytes changes. This will not be 
     * signalled with every single byte change. Instead, the most frequent 
     * this signal will be emitted is once a second. This should be 
     * sufficient, and the TransferredBytes property SHOULD NOT be polled.
     *
     * \param count
     *     
     *     The number of already transferred bytes.
     */
    void TransferredBytesChanged(qulonglong count);

    /**
     * Represents the signal "InitialOffsetDefined" on the remote object.
     * 
     * Emitted when the value of the InitialOffset property has been 
     * negotiated. This signal MUST be emitted before the channel becomes Open 
     * and clients have to use this offset when transferring the file.
     *
     * \param initialOffset
     *     
     *     The value of the InitialOffset property.
     */
    void InitialOffsetDefined(qulonglong initialOffset);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeRoomListInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.RoomList."
 */
class ChannelTypeRoomListInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.RoomList", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.RoomList";
    }

    /**
     * Creates a ChannelTypeRoomListInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeRoomListInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeRoomListInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeRoomListInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeRoomListInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeRoomListInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeRoomListInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeRoomListInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeRoomListInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeRoomListInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Server" on the remote object.
     * 
     * For protocols with a concept of chatrooms on multiple servers with 
     * different DNS names (like XMPP), the DNS name of the server whose rooms 
     * are listed by this channel, e.g. &quot;conference.jabber.org&quot;. 
     * Otherwise, the empty string. This property cannot change during the 
     * lifetime of the channel.
     */
    Q_PROPERTY(QString Server READ Server)

    /**
     * Getter for the remote object property "Server".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Server() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Server"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetListingRooms" on the remote object.
     * 
     * Check to see if there is already a room list request in progress on 
     * this channel.
     *
     * \return
     *     
     *     A boolean indicating if room listing is in progress
     */
    inline QDBusPendingReply<bool> GetListingRooms()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<bool>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetListingRooms"));
    }

    /**
     * Begins a call to the D-Bus method "ListRooms" on the remote object.
     * 
     * Request the list of rooms from the server. The ListingRooms (True) 
     * signal should be emitted when this request is being processed, GotRooms 
     * when any room information is received, and ListingRooms (False) when 
     * the request is complete.
     */
    inline QDBusPendingReply<> ListRooms()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ListRooms"));
    }

    /**
     * Begins a call to the D-Bus method "StopListing" on the remote object.
     * 
     * Stop the room listing if it&apos;s in progress, but don&apos;t close 
     * the channel. The ListingRooms (False) signal should be emitted when the 
     * listing stops.
     */
    inline QDBusPendingReply<> StopListing()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("StopListing"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "GotRooms" on the remote object.
     * 
     * <p>Emitted when information about rooms on the server becomes available.
     * The array contains the room handle (as can be passed to the
     * <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">RequestChannel</tp:dbus-ref>
     * method with HANDLE_TYPE_ROOM), the channel
     * type, and a dictionary containing further information about the
     * room as available. The following well-known keys and types are
     * recommended for use where appropriate:</p>
     * 
     * <dl>
     *   <dt>handle-name (s)</dt>
     *   <dd>The identifier of the room (as would be returned by
     *     <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>)</dd>
     * 
     *   <dt>name (s)</dt>
     *   <dd>The human-readable name of the room if different from the handle</dd>
     * 
     *   <dt>description (s)</dt>
     *   <dd>A description of the room's overall purpose</dd>
     * 
     *   <dt>subject (s)</dt>
     *   <dd>The current subject of conversation in the room</dd>
     * 
     *   <dt>members (u)</dt>
     *   <dd>The number of members in the room</dd>
     * 
     *   <dt>password (b)</dt>
     *   <dd>True if the room requires a password to enter</dd>
     * 
     *   <dt>invite-only (b)</dt>
     *   <dd>True if you cannot join the room, but must be invited</dd>
     * </dl>
     *
     * \param rooms
     *     
     *     An array of structs containing:
     *     <ul>
     *       <li>an integer room handle</li>
     *       <li>a string representing the D-Bus interface name of the channel type</li>
     *       <li>a dictionary mapping string keys to variant boxed information</li>
     *     </ul>
     */
    void GotRooms(const Tp::RoomInfoList& rooms);

    /**
     * Represents the signal "ListingRooms" on the remote object.
     * 
     * Emitted to indicate whether or not room listing request is currently in 
     * progress.
     *
     * \param listing
     *     
     *     A boolean indicating if room listing is in progress
     */
    void ListingRooms(bool listing);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeStreamTubeInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.StreamTube."
 */
class ChannelTypeStreamTubeInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.StreamTube", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.StreamTube";
    }

    /**
     * Creates a ChannelTypeStreamTubeInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamTubeInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeStreamTubeInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamTubeInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeStreamTubeInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeStreamTubeInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeStreamTubeInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeStreamTubeInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeStreamTubeInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamTubeInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Service" on the remote object.
     * 
     * <p> A string representing the service name that will be used over the
     *   tube.  It should be a well-known TCP service name as defined by
     *   <a href="http://www.iana.org/assignments/port-numbers">
     *     http://www.iana.org/assignments/port-numbers</a> or
     *   <a href="http://www.dns-sd.org/ServiceTypes.html">
     *     http://www.dns-sd.org/ServiceTypes.html</a>, for instance
     *   &quot;rsync&quot; or &quot;daap&quot;.</p>
     * <p>When the tube is offered, the service name is transmitted to the
     *   other end.</p>
     * <p>When requesting a channel with
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>,
     *   this property MUST be included in the request.</p>
     */
    Q_PROPERTY(QString Service READ Service)

    /**
     * Getter for the remote object property "Service".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Service() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Service"));
    }

    /**
     * Represents property "SupportedSocketTypes" on the remote object.
     * 
     * <p>A mapping from address types (members of Socket_Address_Type) to
     * arrays of access-control type (members of Socket_Access_Control)
     * that the connection manager supports for stream tubes with that
     * address type. For simplicity, if a CM supports offering a
     * particular type of tube, it is assumed to support accepting it.</p>
     * 
     * <p>A typical value for a host without IPv6 support:</p>
     * 
     * <pre>
     *   {
     *     Socket_Address_Type_IPv4:
     *       [Socket_Access_Control_Localhost, Socket_Access_Control_Port,
     *        Socket_Access_Control_Netmask],
     *     Socket_Address_Type_Unix:
     *       [Socket_Access_Control_Localhost, Socket_Access_Control_Credentials]
     *   }
     * </pre>
     * 
     * <p>Connection Managers MUST support at least IPv4 with the localhost
     *   access control.</p>
     * 
     * <p>When requesting a channel with
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.Interface.Requests.CreateChannel</tp:dbus-ref>,
     *   this property MUST NOT be included in the request.</p>
     */
    Q_PROPERTY(Tp::SupportedSocketMap SupportedSocketTypes READ SupportedSocketTypes)

    /**
     * Getter for the remote object property "SupportedSocketTypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SupportedSocketMap SupportedSocketTypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SupportedSocketMap>(internalPropGet("SupportedSocketTypes"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "Offer" on the remote object.
     * 
     * Offer a stream tube exporting the local socket specified.
     *
     * \param addresstype
     *     
     *     The type of the listening address of the local service, as a member 
     *     of Socket_Address_Type.
     *
     * \param address
     *     
     *     The listening address of the local service, as indicated by the 
     *     address_type.
     *
     * \param accesscontrol
     *     
     *     The access control the local service applies to the local socket, 
     *     specified so the connection manager can behave appropriately when 
     *     it connects.
     *
     * \param parameters
     *     
     *     The dictionary of arbitrary Parameters to send with the tube offer.
     */
    inline QDBusPendingReply<> Offer(uint addresstype, const QDBusVariant& address, uint accesscontrol, const QVariantMap& parameters)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(addresstype) << QVariant::fromValue(address) << QVariant::fromValue(accesscontrol) << QVariant::fromValue(parameters);
        return asyncCallWithArgumentList(QLatin1String("Offer"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "Accept" on the remote object.
     * 
     * Accept a stream tube that&apos;s in the &quot;local pending&quot; 
     * state. The connection manager will attempt to open the tube. The tube 
     * remains in the &quot;local pending&quot; state until the 
     * TubeChannelStateChanged signal is emitted.
     *
     * \param addresstype
     *     
     *     The type of address the connection manager should listen on.
     *
     * \param accesscontrol
     *     
     *     <p>The type of access control the connection manager should apply to
     *     the socket.</p>
     *     
     *     <p>Note that if you plan to establish more than one connection
     *     through the tube, the Socket_Access_Control_Port access control
     *     can't be used as you can't connect more than once from the same
     *     port.</p>
     *
     * \param accesscontrolparam
     *     
     *     A parameter for the access control type, to be interpreted as 
     *     specified in the documentation for the Socket_Access_Control enum.
     *
     * \return
     *     
     *     The address on which the connection manager will listen for 
     *     connections to this tube. The client should not attempt to connect 
     *     to the address until the tube is open.
     */
    inline QDBusPendingReply<QDBusVariant> Accept(uint addresstype, uint accesscontrol, const QDBusVariant& accesscontrolparam)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusVariant>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(addresstype) << QVariant::fromValue(accesscontrol) << QVariant::fromValue(accesscontrolparam);
        return asyncCallWithArgumentList(QLatin1String("Accept"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "NewRemoteConnection" on the remote object.
     * 
     * <p>Emitted each time a participant opens a new connection to its
     * socket.</p>
     * 
     * <p>This signal is only fired on the offering side.</p>
     *
     * \param handle
     *     
     *     The handle of the participant who opened the new connection
     *
     * \param connectionParam
     *     
     *     <p>A parameter which can be used by the listening process to identify
     *     the connection. Note that this parameter has a meaningful value
     *     only in the Socket_Access_Control_Port and
     *     Socket_Access_Control_Credentials cases. If a different
     *     Socket_Access_Control has been chosen when offering the tube, this
     *     parameter should be ignored.</p>
     *     
     *     <p>In the Socket_Access_Control_Port case, the variant
     *     contains a struct Socket_Address_IPv4 (or Socket_Address_IPv6)
     *     containing the address from which the CM is connected to the client
     *     application.</p>
     *     
     *     <p>In the Socket_Access_Control_Credentials case, the variant
     *     contains the byte (D-Bus signature 'y') that has been sent with
     *     the credentials.</p>
     *
     * \param connectionID
     *     
     *     The unique ID associated with this connection. This ID will be used 
     *     to identifiy the connection when reporting errors with 
     *     ConnectionClosed.
     */
    void NewRemoteConnection(uint handle, const QDBusVariant& connectionParam, uint connectionID);

    /**
     * Represents the signal "NewLocalConnection" on the remote object.
     * 
     * <p>Emitted when the tube application connects to the CM's socket.</p>
     * 
     * <p>This signal is only fired on the accepting side.</p>
     *
     * \param connectionID
     *     
     *     The unique ID associated with this connection. This ID will be used 
     *     to identifiy the connection when reporting errors with 
     *     ConnectionClosed.
     */
    void NewLocalConnection(uint connectionID);

    /**
     * Represents the signal "ConnectionClosed" on the remote object.
     * 
     * <p>Emitted when a connection has been closed.</p>
     *
     * \param connectionID
     *     
     *     The ID of the connection.
     *
     * \param error
     *     
     *     <p>The name of a D-Bus error describing the error that occurred.</p>
     *     
     *     <p>The following errors can be used:</p>
     *     <ul>
     *       <li><code>org.freedesktop.Telepathy.Error.Cancelled</code>:
     *          user closed the socket or the tube.</li>
     *       <li><code>org.freedesktop.Telepathy.Error.ConnectionLost</code>:
     *          the bytestream relaying connection's data has been broken.</li>
     *       <li><code>org.freedesktop.Telepathy.Error.ConnectionRefused</code>:
     *          the tube offer refused the connection.</li>
     *     </ul>
     *
     * \param message
     *     
     *     A debug message.
     */
    void ConnectionClosed(uint connectionID, const QString& error, const QString& message);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeStreamedMediaInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.StreamedMedia."
 */
class ChannelTypeStreamedMediaInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.StreamedMedia", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.StreamedMedia";
    }

    /**
     * Creates a ChannelTypeStreamedMediaInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamedMediaInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeStreamedMediaInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamedMediaInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeStreamedMediaInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeStreamedMediaInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeStreamedMediaInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeStreamedMediaInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeStreamedMediaInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeStreamedMediaInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

    /**
     * Represents property "InitialAudio" on the remote object.
     * 
     * <p>If set to true in a channel request that will create a new channel,
     *   the connection manager should immediately attempt to establish an
     *   audio stream to the remote contact, making it unnecessary for the
     *   client to call <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.StreamedMedia">RequestStreams</tp:dbus-ref>.</p>
     * 
     * <p>If this property, or InitialVideo, is passed to EnsureChannel
     *   (as opposed to CreateChannel), the connection manager SHOULD ignore
     *   these properties when checking whether it can return an existing
     *   channel as suitable; these properties only become significant when
     *   the connection manager has decided to create a new channel.</p>
     * 
     * <p>If true on a requested channel, this indicates that the audio
     *   stream has already been requested and the client does not need to
     *   call RequestStreams, although it MAY still do so.</p>
     * 
     * <p>If true on an unrequested (incoming) channel, this indicates that
     *   the remote contact initially requested an audio stream; this does
     *   not imply that that audio stream is still active (as indicated by
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type.StreamedMedia">ListStreams</tp:dbus-ref>).</p>
     * 
     * <p>This property is immutable (cannot change), and therefore SHOULD
     *   appear wherever immutable properties are reported, e.g. <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">NewChannels</tp:dbus-ref>
     *   signals.</p>
     * 
     * <tp:rationale><p>This reduces D-Bus round trips.</p></tp:rationale>
     * 
     * <p>Connection managers capable of signalling audio calls to contacts
     *   SHOULD include a channel class in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">RequestableChannelClasses</tp:dbus-ref>
     *   with <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">ChannelType</tp:dbus-ref>
     *   = <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">StreamedMedia</tp:dbus-ref>
     *   and <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandleType</tp:dbus-ref>
     *   = Contact in the fixed properties dictionary, and InitialAudio
     *   (and also InitialVideo, if applicable) in the allowed properties
     *   list. Clients wishing to discover whether a connection manager
     *   can signal audio and/or video calls SHOULD use this information.</p>
     * 
     * <tp:rationale>
     *   <p>Not all protocols support signalling video calls, and it would be
     *     possible (although unlikely) to have a protocol where only video,
     *     and not audio, could be signalled.</p>
     * </tp:rationale>
     * 
     * <p>Connection managers that support the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">ContactCapabilities</tp:dbus-ref>
     *   interface SHOULD represent the capabilities of receiving audio
     *   and/or video calls by including a channel class in
     *   a contact's capabilities with ChannelType = StreamedMedia
     *   in the fixed properties dictionary, and InitialAudio and/or
     *   InitialVideo in the allowed properties list. Clients wishing to
     *   discover whether a particular contact is likely to be able to
     *   receive audio and/or video calls SHOULD use this information.</p>
     * 
     * <tp:rationale>
     *   <p>Not all clients support video calls, and it would also be
     *     possible (although unlikely) to have a client which could only
     *     stream video, not audio.</p>
     * </tp:rationale>
     * 
     * <p>Clients that are willing to receive audio and/or video calls
     *   SHOULD include the following among their channel classes if
     *   calling <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities">UpdateCapabilities</tp:dbus-ref>
     *   (clients of a <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatcher</tp:dbus-ref>
     *   SHOULD instead arrange for the ChannelDispatcher to do this,
     *   by including the filters in their <tp:dbus-ref namespace="org.freedesktop.Telepathy.Client.Handler">HandlerChannelFilter</tp:dbus-ref>
     *   properties):</p>
     * 
     * <ul>
     *   <li>{ ChannelType = StreamedMedia }</li>
     *   <li>{ ChannelType = StreamedMedia, InitialAudio = true }
     *     if receiving calls with audio is supported</li>
     *   <li>{ ChannelType = StreamedMedia, InitialVideo = true }
     *     if receiving calls with video is supported</li>
     * </ul>
     * 
     * <tp:rationale>
     *   <p>Connection managers for protocols with capability discovery,
     *     like XMPP, need this information to advertise the appropriate
     *     capabilities for their protocol.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(bool InitialAudio READ InitialAudio)

    /**
     * Getter for the remote object property "InitialAudio".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool InitialAudio() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("InitialAudio"));
    }

    /**
     * Represents property "InitialVideo" on the remote object.
     * 
     * <p>The same as <tp:member-ref>InitialAudio</tp:member-ref>, but for
     *   a video stream. This property is immutable (cannot change).</p>
     * 
     * <p>In particular, note that if this property is false, this does not
     *   imply that an active video stream has not been added, only that no
     *   video stream was active at the time the channel appeared.</p>
     * 
     * <p>This property is the correct way to discover whether connection
     *   managers, contacts etc. support video calls; it appears in
     *   capabilities structures in the same way as InitialAudio.</p>
     */
    Q_PROPERTY(bool InitialVideo READ InitialVideo)

    /**
     * Getter for the remote object property "InitialVideo".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool InitialVideo() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("InitialVideo"));
    }

    /**
     * Represents property "ImmutableStreams" on the remote object.
     * 
     * <p>If <tt>True</tt>, once streams have been requested for this channel
     *   (either by setting <tp:member-ref>InitialAudio</tp:member-ref> or
     *   <tp:member-ref>InitialVideo</tp:member-ref> when the channel is
     *   requested, or by calling
     *   <tp:member-ref>RequestStreams</tp:member-ref> on a channel with no
     *   streams), a stream of a different content type cannot be added;
     *   subsequent calls to <tp:member-ref>RequestStreams</tp:member-ref>
     *   that attempt to do so will fail.</p>
     * 
     * <p>If this property is missing, clients SHOULD assume that it is false,
     *   and thus that the channel's streams can be changed once the call has
     *   started.</p>
     * 
     * <p>If this property is present in the &quot;allowed&quot; set in all of the
     *   StreamedMedia entries in a contact's capabilities, then user
     *   interfaces MAY choose to show a separate &quot;call&quot; option for each
     *   class of call.</p>
     * 
     *   <tp:rationale>
     *     <p>For example, once an audio-only Google Talk call has started,
     *       it is not possible to add a video stream; both audio and video
     *       must be requested at the start of the call if video is desired.
     *       User interfaces may use this pseudo-capability as a hint to
     *       display separate &quot;Audio call&quot; and &quot;Video call&quot; buttons, rather
     *       than a single &quot;Call&quot; button with the option to add and remove
     *       video once the call has started for contacts without this flag.
     *     </p>
     *   </tp:rationale>
     * 
     * <p>This property is immutable, and therefore SHOULD be announced
     *   in <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Requests">NewChannels</tp:dbus-ref>,
     *   etc.</p>
     */
    Q_PROPERTY(bool ImmutableStreams READ ImmutableStreams)

    /**
     * Getter for the remote object property "ImmutableStreams".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool ImmutableStreams() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("ImmutableStreams"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "ListStreams" on the remote object.
     * 
     * Returns an array of structs representing the streams currently active 
     * within this channel. Each stream is identified by an unsigned integer 
     * which is unique for each stream within the channel.
     *
     * \return
     *     
     *     An array of structs containing:
     *     <ul>
     *     <li>the stream identifier</li>
     *     <li>the contact handle who the stream is with (or 0 if the stream
     *       represents more than a single member)</li>
     *     <li>the type of the stream</li>
     *     <li>the current stream state</li>
     *     <li>the current direction of the stream</li>
     *     <li>the current pending send flags</li>
     *     </ul>
     */
    inline QDBusPendingReply<Tp::MediaStreamInfoList> ListStreams()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::MediaStreamInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ListStreams"));
    }

    /**
     * Begins a call to the D-Bus method "RemoveStreams" on the remote object.
     * 
     * <p>Request that the given streams are removed. If all streams are
     *   removed, the channel MAY close.</p>
     * 
     * <p>Clients SHOULD NOT attempt to terminate calls by removing all the
     *   streams; instead, clients SHOULD terminate calls by removing the
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Group.SelfHandle</tp:dbus-ref>
     *   from the channel, using either
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">RemoveMembers</tp:dbus-ref>
     *   or
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface.Group">RemoveMembersWithReason</tp:dbus-ref>.
     *   </p>
     *
     * \param streams
     *     
     *     An array of stream identifiers (as defined in ListStreams)
     */
    inline QDBusPendingReply<> RemoveStreams(const Tp::UIntList& streams)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(streams);
        return asyncCallWithArgumentList(QLatin1String("RemoveStreams"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestStreamDirection" on the remote object.
     * 
     * <p>Request a change in the direction of an existing stream. In particular,
     * this might be useful to stop sending media of a particular type,
     * or inform the peer that you are no longer using media that is being
     * sent to you.</p>
     * 
     * <p>Depending on the protocol, streams which are no longer sending in
     * either direction should be removed and a
     * <tp:member-ref>StreamRemoved</tp:member-ref> signal emitted.
     * Some direction changes can be enforced locally (for example,
     * BIDIRECTIONAL -&gt; RECEIVE can be achieved by merely stopping sending),
     * others may not be possible on some protocols, and some need agreement
     * from the remote end. In this case, the MEDIA_STREAM_PENDING_REMOTE_SEND
     * flag will be set in the
     * <tp:member-ref>StreamDirectionChanged</tp:member-ref> signal, and the
     * signal
     * emitted again without the flag to indicate the resulting direction when
     * the remote end has accepted or rejected the change.</p>
     *
     * \param streamID
     *     
     *     The stream identifier (as defined in ListStreams)
     *
     * \param streamDirection
     *     
     *     The desired stream direction (a value of MediaStreamDirection)
     */
    inline QDBusPendingReply<> RequestStreamDirection(uint streamID, uint streamDirection)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(streamID) << QVariant::fromValue(streamDirection);
        return asyncCallWithArgumentList(QLatin1String("RequestStreamDirection"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestStreams" on the remote object.
     * 
     * <p>Request that streams be established to exchange the given types of
     * media with the given member. In general this will try and establish a
     * bidirectional stream, but on some protocols it may not be possible to
     * indicate to the peer that you would like to receive media, so a
     * send-only stream will be created initially. In the cases where the
     * stream requires remote agreement (eg you wish to receive media from
     * them), the <tp:member-ref>StreamDirectionChanged</tp:member-ref> signal
     * will be emitted with the
     * MEDIA_STREAM_PENDING_REMOTE_SEND flag set, and the signal emitted again
     * with the flag cleared when the remote end has replied.</p>
     * 
     * <p>If streams of the requested types already exist, calling this
     *   method results in the creation of additional streams. Accordingly,
     *   clients wishing to have exactly one audio stream or exactly one
     *   video stream SHOULD check for the current streams using
     *   <tp:member-ref>ListStreams</tp:member-ref> before calling this
     *   method.</p>
     *
     * \param contactHandle
     *     
     *     A contact handle with whom to establish the streams
     *
     * \param types
     *     
     *     An array of stream types (values of MediaStreamType)
     *
     * \return
     *     
     *     An array of structs (in the same order as the given stream types)
     *     containing:
     *     <ul>
     *       <li>the stream identifier</li>
     *       <li>the contact handle who the stream is with (or 0 if the stream
     *         represents more than a single member)</li>
     *       <li>the type of the stream</li>
     *       <li>the current stream state</li>
     *       <li>the current direction of the stream</li>
     *       <li>the current pending send flags</li>
     *     </ul>
     */
    inline QDBusPendingReply<Tp::MediaStreamInfoList> RequestStreams(uint contactHandle, const Tp::UIntList& types)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::MediaStreamInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contactHandle) << QVariant::fromValue(types);
        return asyncCallWithArgumentList(QLatin1String("RequestStreams"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "StreamAdded" on the remote object.
     * 
     * <p>Emitted when a new stream has been added to this channel.
     *   Clients SHOULD assume that the stream's
     *   <tp:type>Media_Stream_State</tp:type> is initially Disconnected.</p>
     * 
     * <p>If a connection manager needs to represent the addition of a stream
     *   whose state is already Connecting or Connected, it MUST do this
     *   by emitting StreamAdded, closely followed by
     *   <tp:member-ref>StreamStateChanged</tp:member-ref> indicating a
     *   change to the appropriate state.</p>
     * 
     * <tp:rationale>
     *   <p>Historically, it was not clear from the StreamAdded signal what
     *     the state of the stream was. telepathy-spec 0.17.22
     *     clarified this.</p>
     * </tp:rationale>
     * 
     * <p>Similarly, clients SHOULD assume that the initial
     *   <tp:type>Media_Stream_Direction</tp:type> of a newly added stream
     *   is Receive, and that the initial
     *   <tp:type>Media_Stream_Pending_Send</tp:type> is
     *   Pending_Local_Send.</p>
     * 
     * <p>If a connection manager needs to represent the addition of a stream
     *   whose direction or pending-send differs from those initial values,
     *   it MUST do so by emitting StreamAdded, closely followed by
     *   <tp:member-ref>StreamDirectionChanged</tp:member-ref> indicating a
     *   change to the appropriate direction and pending-send state.</p>
     * 
     * <tp:rationale>
     *   <p>StreamAdded doesn't itself indicate the stream's direction; this
     *     is unfortunate, but is preserved for compatibility.</p>
     * 
     *   <p>This is the appropriate direction for streams added by a remote
     *     contact on existing connection managers, and does not violate
     *     user privacy by automatically sending audio or video (audio streams
     *     start off muted, video streams start off not sending). For
     *     streams added by the local user using the client receiving the
     *     signal, the true direction can also be determined from the return
     *     value of the <tp:member-ref>RequestStreams</tp:member-ref>
     *     method.</p>
     * 
     *   <p>Existing clients typically operate by maintaining a separate
     *     idea of the directions that they would like the streams to have,
     *     and enforcing these intended directions by calling
     *     <tp:member-ref>RequestStreamDirection</tp:member-ref> whenever
     *     needed.</p>
     * </tp:rationale>
     *
     * \param streamID
     *     
     *     The stream identifier (as defined in ListStreams)
     *
     * \param contactHandle
     *     
     *     The contact handle who the stream is with (or 0 if it represents 
     *     more than a single member)
     *
     * \param streamType
     *     
     *     The stream type (a value from MediaStreamType)
     */
    void StreamAdded(uint streamID, uint contactHandle, uint streamType);

    /**
     * Represents the signal "StreamDirectionChanged" on the remote object.
     * 
     * <p>Emitted when the direction or pending flags of a stream are
     *   changed.</p>
     * 
     * <p>If the MEDIA_STREAM_PENDING_LOCAL_SEND flag is set, the remote user
     *   has requested that we begin sending on this stream.
     *   <tp:member-ref>RequestStreamDirection</tp:member-ref>
     *   should be called to indicate whether or not this change is
     *   acceptable.</p>
     * 
     * <tp:rationale>
     *   <p>This allows for a MSN-style user interface, &quot;Fred has asked you
     *     to enable your webcam. (Accept | Reject)&quot;, if desired.</p>
     * </tp:rationale>
     *
     * \param streamID
     *     
     *     The stream identifier (as defined in ListStreams)
     *
     * \param streamDirection
     *     
     *     The new stream direction (as defined in ListStreams)
     *
     * \param pendingFlags
     *     
     *     The new pending send flags (as defined in ListStreams)
     */
    void StreamDirectionChanged(uint streamID, uint streamDirection, uint pendingFlags);

    /**
     * Represents the signal "StreamError" on the remote object.
     * 
     * Emitted when a stream encounters an error.
     *
     * \param streamID
     *     
     *     The stream identifier (as defined in ListStreams)
     *
     * \param errorCode
     *     
     *     A stream error number, one of the values of MediaStreamError
     *
     * \param message
     *     
     *     A string describing the error (for debugging purposes only)
     */
    void StreamError(uint streamID, uint errorCode, const QString& message);

    /**
     * Represents the signal "StreamRemoved" on the remote object.
     * 
     * Emitted when a stream has been removed from this channel.
     *
     * \param streamID
     *     
     *     stream_id - the stream identifier (as defined in ListStreams)
     */
    void StreamRemoved(uint streamID);

    /**
     * Represents the signal "StreamStateChanged" on the remote object.
     * 
     * Emitted when a member&apos;s stream&apos;s state changes.
     *
     * \param streamID
     *     
     *     The stream identifier (as defined in ListStreams)
     *
     * \param streamState
     *     
     *     The new stream state (as defined in ListStreams)
     */
    void StreamStateChanged(uint streamID, uint streamState);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeTextInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.Text."
 */
class ChannelTypeTextInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.Text", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.Text";
    }

    /**
     * Creates a ChannelTypeTextInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTextInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeTextInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTextInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeTextInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeTextInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeTextInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeTextInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeTextInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTextInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AcknowledgePendingMessages" on the remote object.
     * 
     * Inform the channel that you have handled messages by displaying them to 
     * the user (or equivalent), so they can be removed from the pending queue.
     *
     * \param IDs
     *     
     *     The IDs of the messages to acknowledge
     */
    inline QDBusPendingReply<> AcknowledgePendingMessages(const Tp::UIntList& IDs)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(IDs);
        return asyncCallWithArgumentList(QLatin1String("AcknowledgePendingMessages"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetMessageTypes" on the remote object.
     * 
     * Return an array indicating which types of message may be sent on this 
     * channel.
     *
     * \return
     *     
     *     An array of integer message types (ChannelTextMessageType)
     */
    inline QDBusPendingReply<Tp::UIntList> GetMessageTypes()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetMessageTypes"));
    }

    /**
     * Begins a call to the D-Bus method "ListPendingMessages" on the remote object.
     * 
     * List the messages currently in the pending queue, and optionally remove 
     * then all.
     *
     * \param clear
     *     
     *     If true, behave as if AcknowledgePendingMessages had also been 
     *     called.
     *
     * \return
     *     
     *     An array of structs representing the pending queue. Each contains:
     *     <ul>
     *       <li>a numeric identifier</li>
     *       <li>a Unix timestamp indicating when the message was received</li>
     *       <li>the contact handle for the contact who sent the message</li>
     *       <li>the message type, taken from ChannelTextMessageType</li>
     *       <li>the bitwise-OR of the message flags from ChannelTextMessageFlags</li>
     *       <li>the text of the message</li>
     *     </ul>
     */
    inline QDBusPendingReply<Tp::PendingTextMessageList> ListPendingMessages(bool clear)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::PendingTextMessageList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(clear);
        return asyncCallWithArgumentList(QLatin1String("ListPendingMessages"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "Send" on the remote object.
     * 
     * <p>Request that a message be sent on this channel. When the message has
     *   been submitted for delivery, this method will return and the
     *   <tp:member-ref>Sent</tp:member-ref> signal will be emitted. If the
     *   message cannot be submitted for delivery, the method returns an error
     *   and no signal is emitted.</p>
     * 
     * <p>This method SHOULD return before the Sent signal is
     *   emitted.</p>
     * 
     * <tp:rationale>
     *   <p>When a Text channel implements the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Interface">Messages</tp:dbus-ref>
     *     interface, that &quot;SHOULD&quot; becomes a &quot;MUST&quot;.</p>
     * </tp:rationale>
     *
     * \param type
     *     
     *     An integer indicating the type of the message
     *
     * \param text
     *     
     *     The message to send
     */
    inline QDBusPendingReply<> Send(uint type, const QString& text)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(type) << QVariant::fromValue(text);
        return asyncCallWithArgumentList(QLatin1String("Send"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "LostMessage" on the remote object.
     * 
     * This signal is emitted to indicate that an incoming message was not 
     * able to be stored and forwarded by the connection manager due to lack 
     * of memory.
     */
    void LostMessage();

    /**
     * Represents the signal "Received" on the remote object.
     * 
     * Signals that a message with the given id, timestamp, sender, type and 
     * text has been received on this channel. Applications that catch this 
     * signal and reliably inform the user of the message should acknowledge 
     * that they have dealt with the message with the 
     * AcknowledgePendingMessages method.
     *
     * \param ID
     *     
     *     A numeric identifier for acknowledging the message
     *
     * \param timestamp
     *     
     *     A Unix timestamp indicating when the message was received
     *
     * \param sender
     *     
     *     The handle of the contact who sent the message
     *
     * \param type
     *     
     *     The type of the message (normal, action, notice, etc.)
     *
     * \param flags
     *     
     *     A bitwise OR of the message flags
     *
     * \param text
     *     
     *     The text of the message
     */
    void Received(uint ID, uint timestamp, uint sender, uint type, uint flags, const QString& text);

    /**
     * Represents the signal "SendError" on the remote object.
     * 
     * <p>Signals that an outgoing message has failed to send. The error
     *   will be one of the values from ChannelTextSendError.</p>
     * 
     * <p>This signal should only be emitted for messages for which
     *   <tp:member-ref>Sent</tp:member-ref> has already been emitted and
     *   <tp:member-ref>Send</tp:member-ref> has already returned success.</p>
     *
     * \param error
     *     
     *     The error that occurred
     *
     * \param timestamp
     *     
     *     The Unix timestamp indicating when the message was sent
     *
     * \param type
     *     
     *     The message type
     *
     * \param text
     *     
     *     The text of the message
     */
    void SendError(uint error, uint timestamp, uint type, const QString& text);

    /**
     * Represents the signal "Sent" on the remote object.
     * 
     * <p>Signals that a message has been submitted for sending.</p>
     *
     * \param timestamp
     *     
     *     Unix timestamp indicating when the message was sent
     *
     * \param type
     *     
     *     The message type (normal, action, notice, etc) from 
     *     ChannelTextMessageType
     *
     * \param text
     *     
     *     The text of the message. If the message was, or will be, altered 
     *     during transmission, this argument SHOULD reflect what other 
     *     contacts will receive rather than being a copy of the argument to 
     *     Send.
     */
    void Sent(uint timestamp, uint type, const QString& text);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ChannelTypeTubesInterface
 * \headerfile TelepathyQt4/channel.h "../Channel"
 * \ingroup clientchannel
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.Tubes."
 */
class ChannelTypeTubesInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.Tubes", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Channel.Type.Tubes";
    }

    /**
     * Creates a ChannelTypeTubesInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTubesInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeTubesInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTubesInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ChannelTypeTubesInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ChannelTypeTubesInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ChannelTypeTubesInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ChannelTypeTubesInterface(const Tp::Client::ChannelInterface& mainInterface);

    /**
     * Creates a ChannelTypeTubesInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ChannelTypeTubesInterface(const Tp::Client::ChannelInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetAvailableStreamTubeTypes" on the remote object.
     * 
     * List the available address types and access-control types for stream 
     * tubes.
     *
     * \return
     *     
     *     <p>A mapping from address types (members of Socket_Address_Type) to
     *     arrays of access-control type (members of Socket_Access_Control)
     *     that the connection manager supports for stream tubes with that
     *     address type. For simplicity, if a CM supports offering a
     *     particular type of tube, it is assumed to support accepting it.</p>
     *     
     *     <p>A typical value for a host without IPv6 support:</p>
     *     
     *     <pre>
     *       {
     *         Socket_Address_Type_IPv4:
     *           [Socket_Access_Control_Localhost, Socket_Access_Control_Port,
     *            Socket_Access_Control_Netmask],
     *         Socket_Address_Type_Unix:
     *           [Socket_Access_Control_Localhost, Socket_Access_Control_Credentials]
     *       }
     *     </pre>
     *     
     *     <p>If stream tubes are not supported, this will be an empty
     *       dictionary.</p>
     */
    inline QDBusPendingReply<Tp::SupportedSocketMap> GetAvailableStreamTubeTypes()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::SupportedSocketMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAvailableStreamTubeTypes"));
    }

    /**
     * Begins a call to the D-Bus method "GetAvailableTubeTypes" on the remote object.
     *
     * \return
     *     
     *     An array of the available tube types, as defined by the Tube_Type 
     *     enum.
     */
    inline QDBusPendingReply<Tp::UIntList> GetAvailableTubeTypes()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAvailableTubeTypes"));
    }

    /**
     * Begins a call to the D-Bus method "ListTubes" on the remote object.
     *
     * \return
     *     
     *     Return an array of tuples, each representing a tube, with the 
     *     following members: the tube&apos;s ID the tube&apos;s initiator the 
     *     tube&apos;s type the tube&apos;s service the tube&apos;s parameters 
     *     the tube&apos;s state
     */
    inline QDBusPendingReply<Tp::TubeInfoList> ListTubes()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::TubeInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ListTubes"));
    }

    /**
     * Begins a call to the D-Bus method "OfferDBusTube" on the remote object.
     * 
     * Offers a D-Bus tube providing the service specified.
     *
     * \param service
     *     
     *     A string representing the service name that will be used over the 
     *     tube. It should be a well-known D-Bus service name, of the form 
     *     com.example.ServiceName.
     *
     * \param parameters
     *     
     *     A dictionary of properties for the new tube; the allowable keys, 
     *     types and values are defined by the service. Connection managers 
     *     must support the value being any primitive (non-container) D-Bus 
     *     type, or a byte array &apos;ay&apos;.
     *
     * \return
     *     
     *     The ID of the new tube.
     */
    inline QDBusPendingReply<uint> OfferDBusTube(const QString& service, const QVariantMap& parameters)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(service) << QVariant::fromValue(parameters);
        return asyncCallWithArgumentList(QLatin1String("OfferDBusTube"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "OfferStreamTube" on the remote object.
     * 
     * Offer a stream tube exporting the local socket specified.
     *
     * \param service
     *     
     *     A string representing the service name that will be used over the
     *     tube.
     *     It should be a well-known TCP service name as defined by
     *     <a href="http://www.iana.org/assignments/port-numbers">
     *       http://www.iana.org/assignments/port-numbers</a> or
     *     <a href="http://www.dns-sd.org/ServiceTypes.html">
     *       http://www.dns-sd.org/ServiceTypes.html</a>, for instance
     *     &quot;rsync&quot; or &quot;daap&quot;.
     *
     * \param parameters
     *     
     *     <p>A dictionary of properties for the new tube; the allowable keys,
     *     types and values are defined by the service. Connection managers
     *     must support the value being any primitive (non-container)
     *     D-Bus type, or a byte array 'ay'.</p>
     *     <p>These should usually be the same key-value pairs specified for
     *     use in the DNS-SD TXT record for that service.</p>
     *
     * \param addressType
     *     
     *     The type of the listening address of the local service, as a member 
     *     of Socket_Address_Type.
     *
     * \param address
     *     
     *     The listening address of the local service, as indicated by the 
     *     address_type.
     *
     * \param accessControl
     *     
     *     The access control the local service applies to the local socket, 
     *     specified so the connection manager can behave appropriately when 
     *     it connects.
     *
     * \param accessControlParam
     *     
     *     A parameter for the access control type, to be interpreted as 
     *     specified in the documentation for the Socket_Access_Control enum.
     *
     * \return
     *     
     *     The ID of the new tube.
     */
    inline QDBusPendingReply<uint> OfferStreamTube(const QString& service, const QVariantMap& parameters, uint addressType, const QDBusVariant& address, uint accessControl, const QDBusVariant& accessControlParam)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(service) << QVariant::fromValue(parameters) << QVariant::fromValue(addressType) << QVariant::fromValue(address) << QVariant::fromValue(accessControl) << QVariant::fromValue(accessControlParam);
        return asyncCallWithArgumentList(QLatin1String("OfferStreamTube"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "AcceptDBusTube" on the remote object.
     * 
     * Accept a D-Bus tube that&apos;s in the &quot;local pending&quot; state. 
     * The connection manager will attempt to open the tube. The tube remains 
     * in the &quot;local pending&quot; state until the TubeStateChanged 
     * signal is emitted.
     *
     * \param ID
     *     
     *     The ID of the tube to accept.
     *
     * \return
     *     
     *     The string describing the address of the private bus. The client 
     *     should not attempt to connect to the address until the tube is open.
     */
    inline QDBusPendingReply<QString> AcceptDBusTube(uint ID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID);
        return asyncCallWithArgumentList(QLatin1String("AcceptDBusTube"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "AcceptStreamTube" on the remote object.
     * 
     * Accept a stream tube that&apos;s in the &quot;local pending&quot; 
     * state. The connection manager will attempt to open the tube. The tube 
     * remains in the &quot;local pending&quot; state until the 
     * TubeStateChanged signal is emitted.
     *
     * \param ID
     *     
     *     The ID of the tube to accept.
     *
     * \param addressType
     *     
     *     The type of address the connection manager should listen on.
     *
     * \param accessControl
     *     
     *     The type of access control the connection manager should apply to 
     *     the socket.
     *
     * \param accessControlParam
     *     
     *     A parameter for the access control type, to be interpreted as 
     *     specified in the documentation for the Socket_Access_Control enum.
     *
     * \return
     *     
     *     The address on which the connection manager will listen for 
     *     connections to this tube. The client should not attempt to connect 
     *     to the address until the tube is open.
     */
    inline QDBusPendingReply<QDBusVariant> AcceptStreamTube(uint ID, uint addressType, uint accessControl, const QDBusVariant& accessControlParam)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusVariant>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID) << QVariant::fromValue(addressType) << QVariant::fromValue(accessControl) << QVariant::fromValue(accessControlParam);
        return asyncCallWithArgumentList(QLatin1String("AcceptStreamTube"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "CloseTube" on the remote object.
     * 
     * Close a tube.
     *
     * \param ID
     *     
     *     The ID of the tube to close.
     */
    inline QDBusPendingReply<> CloseTube(uint ID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID);
        return asyncCallWithArgumentList(QLatin1String("CloseTube"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetDBusTubeAddress" on the remote object.
     * 
     * For a D-Bus tube, return a string describing the address of the private 
     * bus.
     *
     * \param ID
     *     
     *     The ID of the tube to get an address for.
     *
     * \return
     *     
     *     The bus address.
     */
    inline QDBusPendingReply<QString> GetDBusTubeAddress(uint ID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID);
        return asyncCallWithArgumentList(QLatin1String("GetDBusTubeAddress"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetDBusNames" on the remote object.
     * 
     * For a multi-user (i.e. Handle_Type_Room) D-Bus tube, obtain a mapping 
     * between contact handles and their unique bus names on this tube.
     *
     * \param ID
     *     
     *     The ID of the tube to get names for.
     *
     * \return
     *     
     *     An array of structures, each containing a contact handle and a 
     *     D-Bus bus name.
     */
    inline QDBusPendingReply<Tp::DBusTubeMemberList> GetDBusNames(uint ID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::DBusTubeMemberList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID);
        return asyncCallWithArgumentList(QLatin1String("GetDBusNames"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetStreamTubeSocketAddress" on the remote object.
     * 
     * For a stream tube, obtain the address of the socket used to communicate 
     * over this tube.
     *
     * \param ID
     *     
     *     The ID of the stream tube to get the socket for.
     *
     * \return
     *     
     *     The type of the listening address of the socket, as a member of 
     *     Socket_Address_Type.
     *
     * \return
     *     
     *     The listening address of the socket, as indicated by the 
     *     address_type.
     */
    inline QDBusPendingReply<uint, QDBusVariant> GetStreamTubeSocketAddress(uint ID)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint, QDBusVariant>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(ID);
        return asyncCallWithArgumentList(QLatin1String("GetStreamTubeSocketAddress"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "NewTube" on the remote object.
     * 
     * Emitted when a tube is created.
     *
     * \param ID
     *     
     *     The ID of the new tube.
     *
     * \param initiator
     *     
     *     The handle of the contact who initiated the tube.
     *
     * \param type
     *     
     *     The tube type, as defined by the Tube_Type enum.
     *
     * \param service
     *     
     *     A string representing the service that will be used over the tube.
     *
     * \param parameters
     *     
     *     The new tube&apos;s properties.
     *
     * \param state
     *     
     *     The new tube&apos;s state.
     */
    void NewTube(uint ID, uint initiator, uint type, const QString& service, const QVariantMap& parameters, uint state);

    /**
     * Represents the signal "TubeStateChanged" on the remote object.
     * 
     * Emitted when the state of a tube changes.
     *
     * \param ID
     *     
     *     The ID of the tube that changed state.
     *
     * \param state
     *     
     *     The new state of the tube; see the Tube_State enumeration.
     */
    void TubeStateChanged(uint ID, uint state);

    /**
     * Represents the signal "TubeClosed" on the remote object.
     * 
     * Emitted when a tube has been closed. The ID of a closed tube is no 
     * longer valid. The ID may later be reused for a new tube.
     *
     * \param ID
     *     
     *     The ID of the tube that was closed.
     */
    void TubeClosed(uint ID);

    /**
     * Represents the signal "DBusNamesChanged" on the remote object.
     * 
     * Emitted on a multi-user (i.e. Handle_Type_Room) D-Bus tube when a 
     * participant opens or closes the tube.
     *
     * \param ID
     *     
     *     The ID of the tube whose names have changed.
     *
     * \param added
     *     
     *     Array of handles and D-Bus names of new participants.
     *
     * \param removed
     *     
     *     Array of handles of former participants.
     */
    void DBusNamesChanged(uint ID, const Tp::DBusTubeMemberList& added, const Tp::UIntList& removed);

    /**
     * Represents the signal "StreamTubeNewConnection" on the remote object.
     * 
     * Emitted on a stream tube when a participant opens a new connection to 
     * its socket.
     *
     * \param ID
     *     
     *     The ID of the tube
     *
     * \param handle
     *     
     *     The handle of the participant who opened the new connection
     */
    void StreamTubeNewConnection(uint ID, uint handle);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};
}
}
Q_DECLARE_METATYPE(Tp::Client::ChannelInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceCallStateInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceChatStateInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceDTMFInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceGroupInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceHoldInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceMediaSignallingInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceMessagesInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfacePasswordInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelInterfaceTubeInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeContactListInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeFileTransferInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeRoomListInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeStreamTubeInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeStreamedMediaInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeTextInterface*)
Q_DECLARE_METATYPE(Tp::Client::ChannelTypeTubesInterface*)

#endif //#ifndef CLI_CHANNEL_H
