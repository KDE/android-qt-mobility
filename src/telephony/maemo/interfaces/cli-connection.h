/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef CLI_CONNECTION_H
#define CLI_CONNECTION_H

#include "maemo/interfaces/cli-types.h"

#include <QtCore/QtGlobal>

#include <QtCore/QString>
#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

#include "maemo/interfaces/abstract-interface.h"
#include "maemo/dbus-proxy.h"

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
namespace Client
{

/**
 * \class ConnectionInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection."
 */
class ConnectionInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection";
    }

    /**
     * Creates a ConnectionInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterface(Tp::DBusProxy *proxy);

    ~ConnectionInterface();

    /**
     * Represents property "Interfaces" on the remote object.
     * 
     * <p>The set of optional interfaces supported by this connection.
     *   Before the connection status changes to CONNECTED,
     *   this property may change at any time, but it is guaranteed that
     *   interfaces will only be added, not removed. After the connection
     *   status changes to CONNECTED, this property cannot
     *   change further.</p>
     * 
     * <p>There is no explicit change notification; reasonable behaviour
     *   for a client would be to retrieve the interfaces list once
     *   initially, and once more when it becomes CONNECTED.</p>
     * 
     * <tp:rationale>
     *   <p>In some connection managers, certain capabilities of a connection
     *     are known to be implemented for all connections (e.g. support
     *     for SimplePresence), and some interfaces (like SimplePresence) can
     *     even be used before connecting. Other capabilities may
     *     or may not exist, depending on server functionality; by the time
     *     the connection goes CONNECTED, the connection manager is expected
     *     to have evaluated the server's functionality and enabled any extra
     *     interfaces for the remainder of the Connection's lifetime.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(QStringList Interfaces READ Interfaces)

    /**
     * Getter for the remote object property "Interfaces".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList Interfaces() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("Interfaces"));
    }

    /**
     * Represents property "SelfHandle" on the remote object.
     * 
     * The handle which represents the user on this connection, which will 
     * remain valid for the lifetime of this connection, or until a change in 
     * the user&apos;s identifier is signalled by the SelfHandleChanged 
     * signal. If the connection is not yet in the CONNECTED state, the value 
     * of this property MAY be zero.
     */
    Q_PROPERTY(uint SelfHandle READ SelfHandle)

    /**
     * Getter for the remote object property "SelfHandle".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint SelfHandle() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("SelfHandle"));
    }

    /**
     * Represents property "Status" on the remote object.
     * 
     * <p>The current status of the connection. Change notification is via
     *   the <tp:member-ref>StatusChanged</tp:member-ref> signal.</p>
     * 
     * <p>If retrieval of property succeeds and yields the value Disconnected,
     *   this indicates that the connection has not yet been established.
     *   If connection has been attempted and failed, the Connection object
     *   SHOULD be removed from the bus entirely, meaning that retrieval of
     *   this property SHOULD fail.</p>
     */
    Q_PROPERTY(uint Status READ Status)

    /**
     * Getter for the remote object property "Status".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint Status() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("Status"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "Connect" on the remote object.
     * 
     * <p>Request that the connection be established. This will be done
     *   asynchronously and errors will be returned by emitting
     *   <tp:member-ref>StatusChanged</tp:member-ref> signals.</p>
     * 
     * <p>Calling this method on a Connection that is already connecting
     *   or connected is allowed, and has no effect.</p>
     */
    inline QDBusPendingReply<> Connect()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Connect"));
    }

    /**
     * Begins a call to the D-Bus method "Disconnect" on the remote object.
     * 
     * Request that the connection be closed. This closes the connection if 
     * it&apos;s not already in DISCONNECTED state, and destroys the 
     * connection object.
     */
    inline QDBusPendingReply<> Disconnect()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Disconnect"));
    }

    /**
     * Begins a call to the D-Bus method "GetInterfaces" on the remote object.
     * 
     * <p>Returns the set of optional interfaces supported by this
     *   connection. See <tp:member-ref>Interfaces</tp:member-ref> for more
     *   details.</p>
     *
     * \return
     *     
     *     The value of the Interfaces property
     */
    inline QDBusPendingReply<QStringList> GetInterfaces()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetInterfaces"));
    }

    /**
     * Begins a call to the D-Bus method "GetProtocol" on the remote object.
     * 
     * Get the protocol this connection is using.
     *
     * \return
     *     
     *     A string identifier for the protocol
     */
    inline QDBusPendingReply<QString> GetProtocol()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetProtocol"));
    }

    /**
     * Begins a call to the D-Bus method "GetSelfHandle" on the remote object.
     * 
     * Returns the value of the SelfHandle property. Change notification is 
     * via the SelfHandleChanged signal.
     *
     * \return
     *     
     *     The value of the SelfHandle property
     */
    inline QDBusPendingReply<uint> GetSelfHandle()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetSelfHandle"));
    }

    /**
     * Begins a call to the D-Bus method "GetStatus" on the remote object.
     * 
     * Get the current status as defined in the StatusChanged signal.
     *
     * \return
     *     
     *     The value of the Status property
     */
    inline QDBusPendingReply<uint> GetStatus()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetStatus"));
    }

    /**
     * Begins a call to the D-Bus method "HoldHandles" on the remote object.
     * 
     * <p>Notify the connection manger that your client is holding a copy
     * of handles which may not be in use in any existing channel or
     * list, and were not obtained by using the
     * <tp:member-ref>RequestHandles</tp:member-ref> method. For
     * example, a handle observed in an emitted signal, or displayed
     * somewhere in the UI that is not associated with a channel. The
     * connection manager must not deallocate a handle where any clients
     * have used this method to indicate it is in use until the
     * <tp:member-ref>ReleaseHandles</tp:member-ref>
     * method is called, or the clients disappear from the bus.</p>
     * 
     * <p>Note that HoldHandles is idempotent - calling it multiple times
     *   is equivalent to calling it once. If a handle is &quot;referenced&quot; by
     *   several components which share a D-Bus unique name, the client
     *   should perform reference counting internally, and only call
     *   ReleaseHandles when none of the cooperating components need the
     *   handle any longer.</p>
     *
     * \param handleType
     *     
     *     The type of handle to be held
     *
     * \param handles
     *     
     *     A array of integer handles to hold
     */
    inline QDBusPendingReply<> HoldHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("HoldHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "InspectHandles" on the remote object.
     * 
     * Return a string representation for a number of handles of a given type.
     *
     * \param handleType
     *     
     *     The type of handle to be inspected
     *
     * \param handles
     *     
     *     An array of integer handles of this type
     *
     * \return
     *     
     *     An array of identifiers corresponding to the given handles, in the 
     *     same order.
     */
    inline QDBusPendingReply<QStringList> InspectHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("InspectHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ListChannels" on the remote object.
     * 
     * List all the channels which currently exist on this connection.
     *
     * \return
     *     
     *     An array of structs representing channels.
     */
    inline QDBusPendingReply<Tp::ChannelInfoList> ListChannels()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ChannelInfoList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ListChannels"));
    }

    /**
     * Begins a call to the D-Bus method "ReleaseHandles" on the remote object.
     * 
     * Explicitly notify the connection manager that your client is no longer 
     * holding any references to the given handles, and that they may be 
     * deallocated if they are not held by any other clients or referenced by 
     * any existing channels. See HoldHandles for notes.
     *
     * \param handleType
     *     
     *     An integer handle type (as defined in RequestHandle)
     *
     * \param handles
     *     
     *     An array of integer handles being held by the client
     */
    inline QDBusPendingReply<> ReleaseHandles(uint handleType, const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("ReleaseHandles"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestChannel" on the remote object.
     * 
     * <p>Request a channel satisfying the specified type and communicating
     *   with the contact, room, list etc. indicated by the given
     *   handle_type and handle. The handle_type and handle may both be
     *   zero to request the creation of a new, empty channel, which may
     *   or may not be possible, depending on the protocol and channel
     *   type.</p>
     * 
     * <p>On success, the returned channel will always be of the requested
     *   type (i.e. implement the requested channel-type interface).</p>
     * 
     * <p>If a new, empty channel is requested, on success the returned
     *   channel will always be an &quot;anonymous&quot; channel for which the type
     *   and handle are both zero.</p>
     * 
     * <p>If a channel to a contact, room etc. is requested, on success, the
     *   returned channel may either be a new or existing channel to
     *   the requested entity (i.e. its
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandleType</tp:dbus-ref>
     *   and <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">TargetHandle</tp:dbus-ref>
     *   properties are the
     *   requested handle type and handle), or a newly created &quot;anonymous&quot;
     *   channel associated with the requested handle in some
     *   implementation-specific way.</p>
     * 
     * <p>For example, for a contact handle, the returned channel
     *   might be &quot;anonymous&quot;, but implement the groups interface and have
     *   the requested contact already present among the members.</p>
     * 
     * <p>If the request cannot be satisfied, an error is raised and no
     *   channel is created.</p>
     *
     * \param type
     *     
     *     A D-Bus interface name representing base channel type
     *
     * \param handleType
     *     
     *     An integer representing the handle type, or Handle_Type_None if no 
     *     handle is specified
     *
     * \param handle
     *     
     *     A nonzero integer handle representing a contact, room, list etc. 
     *     according to handle_type, or zero if the handle_type is 
     *     Handle_Type_None
     *
     * \param suppressHandler
     *     
     *     Clients SHOULD always set this to true. The historical meaning was 
     *     that clients that did not intend to take responsibility for 
     *     displaying the channel to the user could set this to FALSE, in 
     *     which case the channel dispatcher would launch an appropriate 
     *     channel handler. However, clients whose functionality relies on 
     *     having a working channel dispatcher should obtain that 
     *     functionality by calling methods on the channel dispatcher, so that 
     *     they will get an appropriate error if the channel dispatcher is 
     *     missing or not working. The channel dispatcher itself should set 
     *     this to true too, so that it will ignore the NewChannel signal that 
     *     results from the creation of the channel. It can then dispatch the 
     *     channel returned from this method to an appropriate handler. So, 
     *     there is no sensible use-case for setting this to false, and 
     *     setting it to false can result in unhandled channels (in the case 
     *     where clients assume that a channel dispatcher is present, but it 
     *     isn&apos;t).
     *
     * \return
     *     
     *     The D-Bus object path for the channel created or retrieved
     */
    inline QDBusPendingReply<QDBusObjectPath> RequestChannel(const QString& type, uint handleType, uint handle, bool suppressHandler)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusObjectPath>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(type) << QVariant::fromValue(handleType) << QVariant::fromValue(handle) << QVariant::fromValue(suppressHandler);
        return asyncCallWithArgumentList(QLatin1String("RequestChannel"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestHandles" on the remote object.
     * 
     * Request several handles from the connection manager which represent a 
     * number of contacts, rooms or server-stored lists on the service. The 
     * connection manager should record that these handles are in use by the 
     * client who invokes this method, and must not deallocate the handles 
     * until the client disconnects from the bus or calls the ReleaseHandles 
     * method. Where the identifier refers to an entity that already has a 
     * handle in this connection manager, this handle should be returned 
     * instead. The handle number 0 must not be returned by the connection 
     * manager.
     *
     * \param handleType
     *     
     *     The type of handle required
     *
     * \param identifiers
     *     
     *     An array of identifiers of entities to request handles for
     *
     * \return
     *     
     *     An array of integer handle numbers in the same order as the given 
     *     identifiers.
     */
    inline QDBusPendingReply<Tp::UIntList> RequestHandles(uint handleType, const QStringList& identifiers)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::UIntList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handleType) << QVariant::fromValue(identifiers);
        return asyncCallWithArgumentList(QLatin1String("RequestHandles"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "SelfHandleChanged" on the remote object.
     * 
     * Emitted whenever the SelfHandle property changes. If the connection is 
     * not yet in the CONNECTED state, this signal is not guaranteed to be 
     * emitted.
     *
     * \param selfHandle
     *     
     *     The new value of the SelfHandle property.
     */
    void SelfHandleChanged(uint selfHandle);

    /**
     * Represents the signal "NewChannel" on the remote object.
     * 
     * Emitted when a new Channel object is created, either through user 
     * request or incoming information from the service.
     *
     * \param objectPath
     *     
     *     A D-Bus object path for the channel object on this service
     *
     * \param channelType
     *     
     *     A D-Bus interface name representing the channel type
     *
     * \param handleType
     *     
     *     An integer representing the type of handle this channel 
     *     communicates with, or Handle_Type_None if no handle is specified
     *
     * \param handle
     *     
     *     A handle indicating the specific contact, room or list this channel 
     *     communicates with, or zero if no handle is specified
     *
     * \param suppressHandler
     *     
     *     <p>If true, the channel was requested by a client that intends to
     *       present it to the user itself (i.e. it passed suppress_handler=TRUE
     *       to the <tp:member-ref>RequestChannel</tp:member-ref> method), so no
     *       other handler should be
     *       launched. Clients MAY assume that channels where this is true
     *       were created by a user request.</p>
     *     
     *     <p>If false, either the channel was created due to incoming
     *       information from the service, or the channel was requested by
     *       a local client that does not intend to handle the channel itself
     *       (this usage is deprecated).</p>
     *     
     *     <p>Clients MUST NOT assume that only incoming channels will have
     *       this flag set to false.</p>
     */
    void NewChannel(const QDBusObjectPath& objectPath, const QString& channelType, uint handleType, uint handle, bool suppressHandler);

    /**
     * Represents the signal "ConnectionError" on the remote object.
     * 
     * <p>Emitted when an error occurs that renders this connection unusable.
     * </p>
     * 
     * <p>Whenever this signal is emitted, it MUST immediately be followed by
     *   a <tp:member-ref>StatusChanged</tp:member-ref> signal with status
     *   Connection_Status_Disconnected and an appropriate reason
     *   code.</p>
     * 
     * <p>Connection managers SHOULD emit this signal on disconnection, but
     *   need not do so. Clients MUST support connection managers that emit
     *   StatusChanged(Disconnected, ...) without first emitting
     *   ConnectionError.</p>
     * 
     * <tp:rationale>
     *   <p>This signal provides additional information about the reason
     *     for disconnection. The reason for connection is always
     *     straightforward - it was requested - so it does not need further
     *     explanation. However, on errors, it can be useful to provide
     *     additional information.</p>
     * 
     *   <p>The <tp:type>Connection_Status_Reason</tp:type> is not given
     *     here, since it will be signalled in
     *     <tp:member-ref>StatusChanged</tp:member-ref>. A reasonable client
     *     implementation would be to store the information given by this
     *     signal until StatusChanged is received, at which point the
     *     information given by this signal can be used to supplement the
     *     StatusChanged signal.</p>
     * </tp:rationale>
     *
     * \param error
     *     
     *     The name of a D-Bus error describing the error that occurred, which 
     *     may correspond to a Connection_Status_Reason, or may be a more 
     *     specific Telepathy error (such as 
     *     org.freedesktop.Telepathy.Errors.ConnectionRefused for 
     *     Connection_Status_Reason_Network_Error) or a protocol-specific or 
     *     connection-manager-specific error in a suitable namespace. For 
     *     instance, a SIP connection manager could signal &quot;402 Payment 
     *     Required&quot; as an error in a connection-manager-specific 
     *     namespace, or a link-local XMPP implementation that used Avahi 
     *     could provide the error given to it by the avahi-daemon.
     *
     * \param details
     *     
     *     <p>Additional information about the error, which may include
     *       the following well-known keys:</p>
     *     
     *     <dl>
     *       <dt>debug-message (s)</dt>
     *       <dd>Debugging information on the change, corresponding to the
     *         message part of a D-Bus error message, which SHOULD NOT be
     *         displayed to users under normal circumstances</dd>
     *     </dl>
     *     
     *     <tp:rationale>
     *       <p>This argument allows for future extensions. For instance,
     *         if indicating DNS lookup failure, we could define a key
     *         that indicates the hostname that could not be found.</p>
     *     </tp:rationale>
     */
    void ConnectionError(const QString& error, const QVariantMap& details);

    /**
     * Represents the signal "StatusChanged" on the remote object.
     * 
     * Emitted when the status of the connection changes. All states and 
     * reasons have numerical values, as defined in ConnectionStatus and 
     * ConnectionStatusReason.
     *
     * \param status
     *     
     *     An integer indicating the new status, as defined by ConnectionStatus
     *
     * \param reason
     *     
     *     An integer indicating the reason for the status change, as defined 
     *     by ConnectionStatusReason
     */
    void StatusChanged(uint status, uint reason);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceAliasingInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Aliasing."
 */
class ConnectionInterfaceAliasingInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Aliasing", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Aliasing";
    }

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceAliasingInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceAliasingInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceAliasingInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAliasingInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetAliasFlags" on the remote object.
     * 
     * Return a bitwise OR of flags detailing the behaviour of aliases on this 
     * connection.
     *
     * \return
     *     
     *     An integer with a bitwise OR of flags from ConnectionAliasFlags
     */
    inline QDBusPendingReply<uint> GetAliasFlags()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAliasFlags"));
    }

    /**
     * Begins a call to the D-Bus method "RequestAliases" on the remote object.
     * 
     * Request the value of several contacts&apos; aliases at once.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A list of aliases in the same order as the contact handles
     */
    inline QDBusPendingReply<QStringList> RequestAliases(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestAliases"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetAliases" on the remote object.
     * 
     * Request the value of several contacts&apos; aliases at once. This 
     * SHOULD only return cached aliases, falling back on the contact 
     * identifier (i.e. the string corresponding to the handle) if none is 
     * present. Also if there was no cached alias, a request SHOULD be started 
     * of which the result is later signalled by AliasesChanged.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A dictionary mapping contact handles to aliases
     */
    inline QDBusPendingReply<Tp::AliasMap> GetAliases(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::AliasMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetAliases"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetAliases" on the remote object.
     * 
     * Request that the alias of the given contact be changed. Success will be 
     * indicated by emitting an AliasesChanged signal. On connections where 
     * the CONNECTION_ALIAS_FLAG_USER_SET flag is not set, this method will 
     * only ever succeed if the contact is the user&apos;s own handle (as 
     * returned by Connection.GetSelfHandle).
     *
     * \param aliases
     *     
     *     A dictionary mapping integer handles of contacts to strings of the 
     *     new alias to set.
     */
    inline QDBusPendingReply<> SetAliases(const Tp::AliasMap& aliases)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(aliases);
        return asyncCallWithArgumentList(QLatin1String("SetAliases"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "AliasesChanged" on the remote object.
     * 
     * Signal emitted when a contact&apos;s alias (or that of the user) is 
     * changed.
     *
     * \param aliases
     *     
     *     An array containing structs of:
     *     <ul>
     *       <li>the handle representing the contact</li>
     *       <li>the new alias</li>
     *     </ul>
     */
    void AliasesChanged(const Tp::AliasPairList& aliases);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceAvatarsInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Avatars."
 */
class ConnectionInterfaceAvatarsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Avatars", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Avatars";
    }

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceAvatarsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceAvatarsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceAvatarsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceAvatarsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "SupportedAvatarMIMETypes" on the remote object.
     * 
     * An array of supported MIME types (e.g. &quot;image/jpeg&quot;). Clients 
     * MAY assume that the first type in this array is preferred. This 
     * property cannot change after the Connection goes to the Connected state.
     */
    Q_PROPERTY(QStringList SupportedAvatarMIMETypes READ SupportedAvatarMIMETypes)

    /**
     * Getter for the remote object property "SupportedAvatarMIMETypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList SupportedAvatarMIMETypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("SupportedAvatarMIMETypes"));
    }

    /**
     * Represents property "MinimumAvatarHeight" on the remote object.
     * 
     * The minimum height in pixels of an avatar on this protocol, which MAY 
     * be 0. This property cannot change after the Connection goes to the 
     * Connected state.
     */
    Q_PROPERTY(uint MinimumAvatarHeight READ MinimumAvatarHeight)

    /**
     * Getter for the remote object property "MinimumAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MinimumAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MinimumAvatarHeight"));
    }

    /**
     * Represents property "MinimumAvatarWidth" on the remote object.
     * 
     * The minimum width in pixels of an avatar on this protocol, which MAY be 
     * 0. This property cannot change after the Connection goes to the 
     * Connected state.
     */
    Q_PROPERTY(uint MinimumAvatarWidth READ MinimumAvatarWidth)

    /**
     * Getter for the remote object property "MinimumAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MinimumAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MinimumAvatarWidth"));
    }

    /**
     * Represents property "RecommendedAvatarHeight" on the remote object.
     * 
     * The recommended height in pixels of an avatar on this protocol, or 0 if 
     * there is no preferred height. This property cannot change after the 
     * Connection goes to the Connected state. In XMPP a recommended width is 
     * given by the protocol specification; in proprietary protocols, using 
     * the same avatar size as the proprietary client is likely to lead to the 
     * best display to other users.
     */
    Q_PROPERTY(uint RecommendedAvatarHeight READ RecommendedAvatarHeight)

    /**
     * Getter for the remote object property "RecommendedAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint RecommendedAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("RecommendedAvatarHeight"));
    }

    /**
     * Represents property "RecommendedAvatarWidth" on the remote object.
     * 
     * The recommended width in pixels of an avatar on this protocol, or 0 if 
     * there is no preferred width. This property cannot change after the 
     * Connection goes to the Connected state. The rationale is the same as 
     * for RecommendedAvatarHeight.
     */
    Q_PROPERTY(uint RecommendedAvatarWidth READ RecommendedAvatarWidth)

    /**
     * Getter for the remote object property "RecommendedAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint RecommendedAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("RecommendedAvatarWidth"));
    }

    /**
     * Represents property "MaximumAvatarHeight" on the remote object.
     * 
     * The maximum height in pixels of an avatar on this protocol, or 0 if 
     * there is no limit. This property cannot change after the Connection 
     * goes to the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarHeight READ MaximumAvatarHeight)

    /**
     * Getter for the remote object property "MaximumAvatarHeight".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarHeight() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarHeight"));
    }

    /**
     * Represents property "MaximumAvatarWidth" on the remote object.
     * 
     * The maximum width in pixels of an avatar on this protocol, or 0 if 
     * there is no limit. This property cannot change after the Connection 
     * goes to the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarWidth READ MaximumAvatarWidth)

    /**
     * Getter for the remote object property "MaximumAvatarWidth".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarWidth() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarWidth"));
    }

    /**
     * Represents property "MaximumAvatarBytes" on the remote object.
     * 
     * The maximum size in bytes of an avatar on this protocol, or 0 if there 
     * is no limit. This property cannot change after the Connection goes to 
     * the Connected state.
     */
    Q_PROPERTY(uint MaximumAvatarBytes READ MaximumAvatarBytes)

    /**
     * Getter for the remote object property "MaximumAvatarBytes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint MaximumAvatarBytes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("MaximumAvatarBytes"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetAvatarRequirements" on the remote object.
     * 
     * Get the required format of avatars on this connection.
     *
     * \return
     *     
     *     An array of supported MIME types (eg image/jpeg)
     *
     * \return
     *     
     *     The minimum image width in pixels
     *
     * \return
     *     
     *     The minimum image height in pixels
     *
     * \return
     *     
     *     The maximum image width in pixels, or 0 if there is no limit
     *
     * \return
     *     
     *     The maximum image height in pixels, or 0 if there is no limit
     *
     * \return
     *     
     *     The maximum image size in bytes, or 0 if there is no limit
     */
    inline QDBusPendingReply<QStringList, ushort, ushort, ushort, ushort, uint> GetAvatarRequirements()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList, ushort, ushort, ushort, ushort, uint>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetAvatarRequirements"));
    }

    /**
     * Begins a call to the D-Bus method "GetAvatarTokens" on the remote object.
     * 
     * Get the unique tokens for all of the given contacts&apos; avatars. 
     * Using this method in new Telepathy clients is deprecated; use 
     * GetKnownAvatarTokens instead.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     An array of avatar tokens or empty strings (if no avatar is set) in 
     *     the same order as the given array of contact handles
     */
    inline QDBusPendingReply<QStringList> GetAvatarTokens(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetAvatarTokens"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetKnownAvatarTokens" on the remote object.
     * 
     * Get the unique tokens for the given contacts&apos; avatars. These 
     * tokens can be persisted across connections, and should be used by the 
     * client to check whether the avatars have been updated. For handles 
     * other than the self handle, only tokens that are already known are 
     * returned; an empty token means the given contact has no avatar. 
     * However, a CM must always have the tokens for the self handle if one is 
     * set (even if it is set to no avatar). On protocols where the avatar 
     * does not persist between connections, a CM should omit the self handle 
     * from the returned map until an avatar is explicitly set or cleared.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts
     *
     * \return
     *     
     *     A dictionary of handles mapped to avatar tokens, containing only 
     *     the known avatar tokens.
     */
    inline QDBusPendingReply<Tp::AvatarTokenMap> GetKnownAvatarTokens(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::AvatarTokenMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetKnownAvatarTokens"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestAvatar" on the remote object.
     * 
     * Request the avatar for a given contact. Using this method in new 
     * Telepathy clients is deprecated; use RequestAvatars instead.
     *
     * \param contact
     *     
     *     An integer handle for the contact to request the avatar for
     *
     * \return
     *     
     *     An array of bytes containing the image data
     *
     * \return
     *     
     *     A string containing the image MIME type (eg image/jpeg), or empty 
     *     if unknown
     */
    inline QDBusPendingReply<QByteArray, QString> RequestAvatar(uint contact)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QByteArray, QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contact);
        return asyncCallWithArgumentList(QLatin1String("RequestAvatar"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestAvatars" on the remote object.
     * 
     * Request avatars for a number of contacts. The AvatarRetrieved signal is 
     * emitted for each avatar retrieved. If the handles are valid but 
     * retrieving an avatar fails (for any reason, including the contact not 
     * having an avatar) the AvatarRetrieved signal is not emitted for that 
     * contact.
     *
     * \param contacts
     *     
     *     The contacts to retrieve avatars for
     */
    inline QDBusPendingReply<> RequestAvatars(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestAvatars"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetAvatar" on the remote object.
     * 
     * Set a new avatar image for this connection. The avatar image must 
     * respect the requirements obtained by GetAvatarRequirements.
     *
     * \param avatar
     *     
     *     An array of bytes representing the avatar image data
     *
     * \param MIMEType
     *     
     *     A string representing the image MIME type
     *
     * \return
     *     
     *     The string token of the new avatar
     */
    inline QDBusPendingReply<QString> SetAvatar(const QByteArray& avatar, const QString& MIMEType)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QString>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(avatar) << QVariant::fromValue(MIMEType);
        return asyncCallWithArgumentList(QLatin1String("SetAvatar"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ClearAvatar" on the remote object.
     * 
     * Remove the avatar image for this connection.
     */
    inline QDBusPendingReply<> ClearAvatar()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ClearAvatar"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "AvatarUpdated" on the remote object.
     * 
     * Emitted when the avatar for a contact has been updated, or first 
     * discovered on this connection. If the token differs from the token 
     * associated with the client&apos;s cached avatar for this contact, the 
     * new avatar should be requested with RequestAvatars.
     *
     * \param contact
     *     
     *     An integer handle for the contact whose avatar has changed
     *
     * \param newAvatarToken
     *     
     *     Unique token for their new avatar
     */
    void AvatarUpdated(uint contact, const QString& newAvatarToken);

    /**
     * Represents the signal "AvatarRetrieved" on the remote object.
     * 
     * Emitted when the avatar for a contact has been retrieved.
     *
     * \param contact
     *     
     *     The contact whose avatar has been retrieved
     *
     * \param token
     *     
     *     The token corresponding to the avatar
     *
     * \param avatar
     *     
     *     An array of bytes containing the image data
     *
     * \param type
     *     
     *     A string containing the image MIME type (eg image/jpeg), or empty 
     *     if unknown
     */
    void AvatarRetrieved(uint contact, const QString& token, const QByteArray& avatar, const QString& type);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceBalanceInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Balance."
 */
class ConnectionInterfaceBalanceInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Balance", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Balance";
    }

    /**
     * Creates a ConnectionInterfaceBalanceInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceBalanceInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceBalanceInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceBalanceInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceBalanceInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceBalanceInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceBalanceInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceBalanceInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceBalanceInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceBalanceInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "AccountBalance" on the remote object.
     * 
     * <p>The user's balance on the account corresponding to this Connection.
     *   A negative amount may be possible on some services, and indicates
     *   that the user owes money to the service provider.</p>
     * 
     * <p>On initial connection, this property may have an unknown
     *   value, represented by Amount = 0, Scale = 2**32 - 1 (the largest
     *   possible 32-bit unsigned integer) and Currency = &quot;&quot;.</p>
     */
    Q_PROPERTY(Tp::CurrencyAmount AccountBalance READ AccountBalance)

    /**
     * Getter for the remote object property "AccountBalance".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::CurrencyAmount AccountBalance() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::CurrencyAmount>(internalPropGet("AccountBalance"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "BalanceChanged" on the remote object.
     * 
     * <p>Emitted when the user's balance has changed.</p>
     *
     * \param balance
     *     
     *     <p>The new value of the <tp:member-ref>AccountBalance</tp:member-ref>
     *       property.</p>
     */
    void BalanceChanged(const Tp::CurrencyAmount& balance);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceCapabilitiesInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Capabilities."
 */
class ConnectionInterfaceCapabilitiesInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Capabilities", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Capabilities";
    }

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceCapabilitiesInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceCapabilitiesInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AdvertiseCapabilities" on the remote object.
     * 
     * <p>Used by user interfaces to indicate which channel types they are able
     * to handle on this connection. Because these may be provided by
     * different client processes, this method accepts channel types to add
     * and remove from the set already advertised on this connection. The type
     * of advertised capabilities (create versus invite) is protocol-dependent
     * and hence cannot be set by the this method. In the case of a client
     * adding an already advertised channel type but with new channel type
     * specific flags, the connection manager should simply add the new flags
     * to the set of advertised capabilities.</p>
     * 
     * <p>Upon a successful invocation of this method, the
     * <tp:member-ref>CapabilitiesChanged</tp:member-ref>
     * signal will be emitted for the user's own handle ( <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.GetSelfHandle</tp:dbus-ref>)
     * by the connection manager to indicate the changes
     * that have been made.  This signal should also be monitored to ensure
     * that the set is kept accurate - for example, a client may remove
     * capabilities or type specific capability flags when it exits
     * which are still provided by another client.</p>
     * 
     * <p>On connections managed by the <tp:dbus-ref namespace="org.freedesktop.Telepathy">ChannelDispatcher</tp:dbus-ref>,
     *   this method SHOULD NOT be used by clients other than the
     *   ChannelDispatcher itself.</p>
     *
     * \param add
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of type specific capability flags</li>
     *     </ul>
     *
     * \param remove
     *     
     *     An array of D-Bus interface names of channel types to remove
     *
     * \return
     *     
     *     An array of structures describing the current capabilities 
     *     containing: a string channel type a bitwise OR of type specific 
     *     capability flags
     */
    inline QDBusPendingReply<Tp::CapabilityPairList> AdvertiseCapabilities(const Tp::CapabilityPairList& add, const QStringList& remove)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::CapabilityPairList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(add) << QVariant::fromValue(remove);
        return asyncCallWithArgumentList(QLatin1String("AdvertiseCapabilities"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetCapabilities" on the remote object.
     * 
     * Returns an array of capabilities for the given contact handles.
     *
     * \param handles
     *     
     *     <p>An array of contact handles for this connection.</p>
     *     
     *     <p>This may include zero, which originally meant a query for
     *       capabilities available on the connection itself. This usage
     *       is deprecated; clients SHOULD NOT do this, and connection managers
     *       SHOULD proceed as though zero had not been present in this
     *       list.</p>
     *
     * \return
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>an integer handle representing the contact</li>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of generic capability flags for the type</li>
     *       <li>a bitwise OR of type specific capability flags for the type</li>
     *     </ul>
     */
    inline QDBusPendingReply<Tp::ContactCapabilityList> GetCapabilities(const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactCapabilityList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("GetCapabilities"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "CapabilitiesChanged" on the remote object.
     * 
     * <p>Announce that there has been a change of capabilities on the
     *   given handle.</p>
     * 
     * <p>If the handle is zero, the capabilities refer to the connection
     *   itself, in some poorly defined way. This usage is deprecated and
     *   clients should ignore it.</p>
     *
     * \param caps
     *     
     *     An array of structures containing:
     *     <ul>
     *       <li>an integer handle representing the contact</li>
     *       <li>a string channel type</li>
     *       <li>a bitwise OR of the contact's old generic capability flags</li>
     *       <li>a bitwise OR of the contact's new generic capability flags</li>
     *       <li>a bitwise OR of the contact's old type specific capability flags</li>
     *       <li>a bitwise OR of the contact's new type specific capability flags</li>
     *     </ul>
     */
    void CapabilitiesChanged(const Tp::CapabilityChangeList& caps);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceContactCapabilitiesInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities."
 */
class ConnectionInterfaceContactCapabilitiesInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities";
    }

    /**
     * Creates a ConnectionInterfaceContactCapabilitiesInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactCapabilitiesInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactCapabilitiesInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactCapabilitiesInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactCapabilitiesInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceContactCapabilitiesInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceContactCapabilitiesInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceContactCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceContactCapabilitiesInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactCapabilitiesInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "UpdateCapabilities" on the remote object.
     * 
     * <p>Alter the connection's advertised capabilities to include
     *   the intersection of the given clients' capabilities with what the
     *   connection manager is able to implement.</p>
     * 
     * <p>On connections managed by the ChannelDispatcher, processes other
     *   than the ChannelDispatcher SHOULD NOT call this method, and the
     *   ChannelDispatcher SHOULD use this method to advertise the
     *   capabilities of all the registered <tp:dbus-ref namespace="org.freedesktop.Telepathy">Client.Handler</tp:dbus-ref>
     *   implementations.On connections not managed by the ChannelDispatcher,
     *   clients MAY use this method directly, to indicate the channels they
     *   will handle and the extra capabilities they have.</p>
     * 
     * <p>Upon a successful invocation of this method, the connection manager
     *   will only emit the
     *   <tp:member-ref>ContactCapabilitiesChanged</tp:member-ref> signal
     *   for the user's <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">SelfHandle</tp:dbus-ref>
     *   if, in the underlying protocol, the new capabilities are distinct
     *   from the previous state.</p>
     * 
     * <tp:rationale>
     *   <p>The connection manager will essentially intersect the provided
     *     capabilities and the channel classes it implements. Therefore,
     *     certain properties which are never fixed for a channel class
     *     (such as the target handle, or the Parameters property of a tube
     *     channel) will almost certainly not be advertised.</p>
     * </tp:rationale>
     * 
     * <p>This method MAY be called on a newly-created connection while it
     *   is still in the DISCONNECTED state, to request that when the
     *   connection connects, it will do so with the appropriate
     *   capabilities. Doing so MUST NOT fail.</p>
     *
     * \param handlerCapabilities
     *     
     *     The capabilities of one or more clients. For each client in the 
     *     given list, any capabilities previously advertised for the same 
     *     client name are discarded, then replaced by the capabilities 
     *     indicated. As a result, if a client becomes unavailable, this 
     *     method SHOULD be called with a Handler_Capabilities structure 
     *     containing its name, an empty list of channel classes, and an empty 
     *     list of capabilities. When this is done, the connection manager 
     *     SHOULD free all memory associated with that client name. This 
     *     method takes a list of clients so that when the channel dispatcher 
     *     first calls it (with a list of all the Handlers that are initially 
     *     available), the changes can be made atomically, with only one 
     *     transmission of updated capabilities to the network. Afterwards, 
     *     the channel dispatcher will call this method with a single-element 
     *     list every time a Handler becomes available or unavailable. The 
     *     connection manager MUST ignore any channel classes and client 
     *     capabilities for which there is no representation in the protocol 
     *     or no support in the connection manager.
     */
    inline QDBusPendingReply<> UpdateCapabilities(const Tp::HandlerCapabilitiesList& handlerCapabilities)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handlerCapabilities);
        return asyncCallWithArgumentList(QLatin1String("UpdateCapabilities"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetContactCapabilities" on the remote object.
     * 
     * <p>Returns an array of requestable channel classes for the given
     *   contact handles, representing the channel requests that are
     *   expected to succeed.</p>
     *
     * \param handles
     *     
     *     <p>An array of contact handles for this connection.</p>
     *     
     *     <p>The handle zero MUST NOT be included in the request.</p>
     *
     * \return
     *     
     *     <p>A map from contact handles to lists of requestable channel
     *       classes, representing the channel requests that are expected
     *       to succeed for that contact.</p>
     *     
     *     <p>Contacts listed among Handles whose capabilities are unknown
     *       SHOULD be omitted from this map; contacts known to have an empty
     *       set of capabilities SHOULD be included in the keys of this map,
     *       with an empty array as the corresponding value.</p>
     */
    inline QDBusPendingReply<Tp::ContactCapabilitiesMap> GetContactCapabilities(const Tp::UIntList& handles)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactCapabilitiesMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles);
        return asyncCallWithArgumentList(QLatin1String("GetContactCapabilities"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "ContactCapabilitiesChanged" on the remote object.
     * 
     * <p>Announce that there has been a change of capabilities on the
     *   given handles. A single signal can be emitted for several
     * contacts.</p>
     * 
     * <tp:rationale>
     *   <p>The underlying protocol can get several contacts' capabilities at
     *     the same time.</p>
     * </tp:rationale>
     *
     * \param caps
     *     
     *     All the capabilities of the contacts
     */
    void ContactCapabilitiesChanged(const Tp::ContactCapabilitiesMap& caps);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceContactInfoInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.ContactInfo."
 */
class ConnectionInterfaceContactInfoInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.ContactInfo", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.ContactInfo";
    }

    /**
     * Creates a ConnectionInterfaceContactInfoInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactInfoInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactInfoInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactInfoInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactInfoInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceContactInfoInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceContactInfoInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceContactInfoInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceContactInfoInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactInfoInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "ContactInfoFlags" on the remote object.
     * 
     * <p>An integer representing the bitwise-OR of flags on this
     *   connection.</p>
     * 
     * <p>This property MAY change, without change notification, at any time
     *   before the connection moves to status Connection_Status_Connected.
     *   It MUST NOT change after that point.</p>
     * 
     * <tp:rationale>
     *   <p>Some XMPP servers, like Facebook Chat, do not allow the vCard to
     *     be changed (and so would not have the Can_Set flag). Whether the
     *     user's server is one of these cannot necessarily be detected until
     *     quite late in the connection process.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(uint ContactInfoFlags READ ContactInfoFlags)

    /**
     * Getter for the remote object property "ContactInfoFlags".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint ContactInfoFlags() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("ContactInfoFlags"));
    }

    /**
     * Represents property "SupportedFields" on the remote object.
     * 
     *         <p>A list of field specifications describing the kinds of fields which may
     *           be passed to <tp:member-ref>SetContactInfo</tp:member-ref>.  The empty
     *           list indicates that arbitrary vCard fields are permitted.  This
     *           property SHOULD be the empty list, and be ignored by clients, if
     *           <tp:member-ref>ContactInfoFlags</tp:member-ref> does not contain the
     *           Can_Set flag.</p>
     * 
     *         <p>For example, a protocol in which arbitrary vCards were stored
     *           as-is would set this property to the
     *           empty list. A protocol whose notion of contact information is one
     *           each of personal phone number, mobile phone number, location, email
     *           address and date of birth, with no attributes allowed on each piece
     *           of information, would set this property to (in Python-like
     *           syntax):</p>
     * 
     *         <pre>
     * [
     *   ('tel', ['type=home'], Parameters_Exact, 1),
     *   ('tel', ['type=cell'], Parameters_Exact, 1),
     *   ('adr', [], Parameters_Exact, 1),
     *   ('bday', [], Parameters_Exact, 1),
     *   ('email', ['type=internet'], Parameters_Exact, 1),
     * ]</pre>
     * 
     *         <p>A protocol which allows users to specify up to four phone numbers,
     *           which may be labelled as personal and/or mobile, would set this
     *           property to
     *           <code>[ ('tel', ['type=home', 'type=cell'], 0, 4), ]</code>.</p>
     * 
     *         <tp:rationale>
     *           <p>Studying existing IM protocols shows that in practice protocols
     *             allow either a very restricted set of fields (such as MSN, which
     *             seems to correspond roughly to the largest example above), or
     *             something mapping 1:1 to a large subset of vCard (such as XMPP's
     *             XEP-0054).</p>
     *         </tp:rationale>
     * 
     *         <p>This property MAY change, without change notification, at any time
     *           before the connection moves to status Connection_Status_Connected.
     *           It MUST NOT change after that point.</p>
     * 
     *         <tp:rationale>
     *           <p>Some XMPP servers, like Google Talk, only allow a small subset of
     *             the &quot;vcard-temp&quot; protocol. Whether the user's server is one of
     *             these cannot be detected until quite late in the connection
     *             process.</p>
     *         </tp:rationale>
     */
    Q_PROPERTY(Tp::FieldSpecs SupportedFields READ SupportedFields)

    /**
     * Getter for the remote object property "SupportedFields".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::FieldSpecs SupportedFields() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::FieldSpecs>(internalPropGet("SupportedFields"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetContactInfo" on the remote object.
     * 
     * Request information on several contacts at once. This SHOULD only 
     * return cached information, omitting handles for which no information is 
     * cached from the returned map.
     *
     * \param contacts
     *     
     *     An array of handles representing contacts.
     *
     * \return
     *     
     *     A dictionary mapping contact handles to information, whose keys are 
     *     the subset of the requested list of handles for which information 
     *     was cached.
     */
    inline QDBusPendingReply<Tp::ContactInfoMap> GetContactInfo(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactInfoMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetContactInfo"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RefreshContactInfo" on the remote object.
     * 
     * Retrieve information for the given contact, requesting it from the 
     * network if an up-to-date version is not cached locally. This method 
     * SHOULD return immediately, emitting ContactInfoChanged when the 
     * contacts&apos; updated contact information is returned. This method 
     * allows a client with cached contact information to update its cache 
     * after a number of days.
     *
     * \param contacts
     *     
     *     Integer handles for contacts.
     */
    inline QDBusPendingReply<> RefreshContactInfo(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RefreshContactInfo"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestContactInfo" on the remote object.
     * 
     * Retrieve information for a contact, requesting it from the network if 
     * it is not cached locally. This method is appropriate for an explicit 
     * user request to show a contact&apos;s information; it allows a UI to 
     * wait for the contact info to be returned.
     *
     * \param contact
     *     
     *     An integer handle for a contact.
     *
     * \return
     *     
     *     Information about that contact.
     */
    inline QDBusPendingReply<Tp::ContactInfoFieldList> RequestContactInfo(uint contact)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactInfoFieldList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contact);
        return asyncCallWithArgumentList(QLatin1String("RequestContactInfo"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetContactInfo" on the remote object.
     * 
     * Set new contact information for this connection, replacing existing 
     * information. This method is only suppported if ContactInfoFlags 
     * contains Can_Set, and may only be passed fields conforming to 
     * SupportedFields.
     *
     * \param contactInfo
     *     
     *     The new information to be set.
     */
    inline QDBusPendingReply<> SetContactInfo(const Tp::ContactInfoFieldList& contactInfo)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contactInfo);
        return asyncCallWithArgumentList(QLatin1String("SetContactInfo"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "ContactInfoChanged" on the remote object.
     * 
     * Emitted when a contact&apos;s information has changed or been received 
     * for the first time on this connection.
     *
     * \param contact
     *     
     *     An integer handle for the contact whose info has changed.
     *
     * \param contactInfo
     *     
     *     An array of fields representing information about this contact.
     */
    void ContactInfoChanged(uint contact, const Tp::ContactInfoFieldList& contactInfo);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceContactsInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Contacts."
 */
class ConnectionInterfaceContactsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Contacts", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Contacts";
    }

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceContactsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceContactsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceContactsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceContactsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "ContactAttributeInterfaces" on the remote object.
     * 
     * A list of D-Bus interfaces for which GetContactAttributes is expected 
     * to work. This cannot change during the lifetime of the Connection.
     */
    Q_PROPERTY(QStringList ContactAttributeInterfaces READ ContactAttributeInterfaces)

    /**
     * Getter for the remote object property "ContactAttributeInterfaces".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList ContactAttributeInterfaces() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("ContactAttributeInterfaces"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetContactAttributes" on the remote object.
     * 
     * Return any number of contact attributes for the given handles.
     *
     * \param handles
     *     
     *     An array of handles representing contacts.
     *
     * \param interfaces
     *     
     *     <p>A list of strings indicating which D-Bus interfaces the calling
     *       process is interested in. All supported attributes from these
     *       interfaces, whose values can be obtained without additional network
     *       activity, will be in the reply.</p>
     *     
     *     <p>Connection managers SHOULD ignore interfaces requested which they
     *       do not support (i.e. those not mentioned in the
     *       <tp:member-ref>ContactAttributeInterfaces</tp:member-ref>
     *       property.)</p>
     *     
     *     <tp:rationale>
     *       <p>This simplifies client-side code. Clients which care may
     *         distinguish between unsupported interfaces (e.g. this Connection
     *         does not support Avatars), and interfaces on which no information
     *         is known for these contacts (e.g. we don't know the avatar tokens
     *         of any of the contacts, so we omitted them all) by inspecting
     *         <tp:member-ref>ContactAttributeInterfaces</tp:member-ref>.</p>
     *     </tp:rationale>
     *     
     *     <p>Attributes from the interface
     *       <tp:dbus-ref>org.freedesktop.Telepathy.Connection</tp:dbus-ref>
     *       are always returned, and need not be requested explicitly.</p>
     *     
     *     <p>As well as returning cached information immediately, the
     *       connection MAY start asynchronous requests to obtain better
     *       values for the contact attributes. If better values are later
     *       obtained by this process, they will be indicated with the usual
     *       signals (such as <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface.Aliasing">AliasesChanged</tp:dbus-ref>).</p>
     *     
     *     <tp:rationale>
     *       For instance, an XMPP connection manager could download vCards
     *       in response to a request for <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">Aliasing</tp:dbus-ref>
     *       attributes.
     *     </tp:rationale>
     *
     * \param hold
     *     
     *     If true, all handles in the result have been held on behalf of the 
     *     calling process, as if by a call to Connection.HoldHandles. For 
     *     further round-trip avoidance.
     *
     * \return
     *     
     *     <p>A dictionary mapping the contact handles to contact attributes.
     *       If any of the requested handles are in fact invalid, they are
     *       simply omitted from this mapping. If contact attributes are not
     *       immediately known, the behaviour is defined by the interface;
     *       the attribute should either be omitted from the result or
     *       replaced with a default value.</p>
     *     
     *     <p>Each contact's attributes will always include at least the
     *       identifier that would be obtained by inspecting the handle
     *       (<code>org.freedesktop.Telepathy.Connection/contact-id</code>).</p>
     */
    inline QDBusPendingReply<Tp::ContactAttributesMap> GetContactAttributes(const Tp::UIntList& handles, const QStringList& interfaces, bool hold)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactAttributesMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(handles) << QVariant::fromValue(interfaces) << QVariant::fromValue(hold);
        return asyncCallWithArgumentList(QLatin1String("GetContactAttributes"), argumentList);
    }

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceLocationInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Location."
 */
class ConnectionInterfaceLocationInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Location", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Location";
    }

    /**
     * Creates a ConnectionInterfaceLocationInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceLocationInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceLocationInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceLocationInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceLocationInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceLocationInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceLocationInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceLocationInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceLocationInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceLocationInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "LocationAccessControlTypes" on the remote object.
     * 
     * The types of access control that are supported by this connection.
     */
    Q_PROPERTY(Tp::UIntList LocationAccessControlTypes READ LocationAccessControlTypes)

    /**
     * Getter for the remote object property "LocationAccessControlTypes".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::UIntList LocationAccessControlTypes() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::UIntList>(internalPropGet("LocationAccessControlTypes"));
    }

    /**
     * Represents property "LocationAccessControl" on the remote object.
     * 
     * The current access control mechanism and settings for this connection. 
     * Before publishing location for the first time, if this has not been set 
     * by a client, implementations SHOULD set it to be as restrictive as 
     * possible (an empty whitelist, if supported).
     */
    Q_PROPERTY(Tp::RichPresenceAccessControl LocationAccessControl READ LocationAccessControl WRITE setLocationAccessControl)

    /**
     * Getter for the remote object property "LocationAccessControl".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::RichPresenceAccessControl LocationAccessControl() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::RichPresenceAccessControl>(internalPropGet("LocationAccessControl"));
    }

    /**
     * Setter for the remote object property "LocationAccessControl".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setLocationAccessControl(const Tp::RichPresenceAccessControl& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("LocationAccessControl", QVariant::fromValue(newValue));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "GetLocations" on the remote object.
     * 
     * Return the current locations of the given contacts, if they are already 
     * known. If any of the given contacts&apos; locations are not known, 
     * request their current locations, but return immediately without waiting 
     * for a reply; if a reply with a non-empty location is later received for 
     * those contacts, the LocationUpdated signal will be emitted for them. 
     * This method is appropriate for &quot;lazy&quot; location finding, for 
     * instance displaying the location (if available) of everyone in your 
     * contact list.
     *
     * \param contacts
     *     
     *     The contacts whose locations should be returned or signalled.
     *
     * \return
     *     
     *     The contacts&apos; locations, if already known. Contacts whose 
     *     locations are not already known are omitted from the mapping; 
     *     contacts known to have no location information appear in the 
     *     mapping with an empty Location dictionary.
     */
    inline QDBusPendingReply<Tp::ContactLocations> GetLocations(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactLocations>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetLocations"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestLocation" on the remote object.
     * 
     * Return the current location of the given contact. If necessary, make a 
     * request to the server for up-to-date information, and wait for a reply. 
     * This method is appropriate for use in a &quot;Contact 
     * Information...&quot; dialog; it can be used to show progress 
     * information (while waiting for the method to return), and can 
     * distinguish between various error conditions.
     *
     * \param contact
     *     
     *     The contact whose location should be returned.
     *
     * \return
     *     
     *     The contact&apos;s location. It MAY be empty, indicating that no 
     *     location information was found.
     */
    inline QDBusPendingReply<QVariantMap> RequestLocation(uint contact)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QVariantMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contact);
        return asyncCallWithArgumentList(QLatin1String("RequestLocation"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetLocation" on the remote object.
     * 
     * Set the local user&apos;s own location.
     *
     * \param location
     *     
     *     The location to advertise. If the user wants to obscure their exact 
     *     location by reducing the precision or accuracy, clients MUST do 
     *     this themselves, rather than relying on the connection manager to 
     *     do so. Clients that interact with more than one connection SHOULD 
     *     advertise the same reduced-accuracy location to all of them, so 
     *     that contacts cannot obtain an undesirably accurate location by 
     *     assuming that random errors have been added and averaging the 
     *     locations advertised on multiple connections.
     */
    inline QDBusPendingReply<> SetLocation(const QVariantMap& location)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(location);
        return asyncCallWithArgumentList(QLatin1String("SetLocation"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "LocationUpdated" on the remote object.
     * 
     * Emitted when a contact&apos;s location changes or becomes known.
     *
     * \param contact
     *     
     *     The contact
     *
     * \param location
     *     
     *     The contact&apos;s location, or empty to indicate that nothing is 
     *     known about the contact&apos;s location.
     */
    void LocationUpdated(uint contact, const QVariantMap& location);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfacePresenceInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Presence."
 */
class ConnectionInterfacePresenceInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Presence", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Presence";
    }

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfacePresenceInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfacePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfacePresenceInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfacePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "AddStatus" on the remote object.
     * 
     * Request that a single presence status is published for the user, along 
     * with any desired parameters. Changes will be indicated by 
     * PresenceUpdate signals being emitted.
     *
     * \param status
     *     
     *     The string identifier of the desired status
     *
     * \param parameters
     *     
     *     A dictionary of optional parameter names mapped to their 
     *     variant-boxed values
     */
    inline QDBusPendingReply<> AddStatus(const QString& status, const QVariantMap& parameters)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status) << QVariant::fromValue(parameters);
        return asyncCallWithArgumentList(QLatin1String("AddStatus"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "ClearStatus" on the remote object.
     * 
     * Request that all of a user&apos;s presence statuses be removed. Be 
     * aware that this request may simply result in the statuses being 
     * replaced by a default available status. Changes will be indicated by 
     * PresenceUpdate signals being emitted.
     */
    inline QDBusPendingReply<> ClearStatus()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("ClearStatus"));
    }

    /**
     * Begins a call to the D-Bus method "GetPresence" on the remote object.
     * 
     * Get presence previously emitted by PresenceUpdate for the given 
     * contacts. Data is returned in the same structure as the PresenceUpdate 
     * signal. Using this method in favour of RequestPresence has the 
     * advantage that it will not wake up each client connected to the 
     * PresenceUpdate signal.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained
     *
     * \return
     *     
     *     Presence information in the same format as for the PresenceUpdate 
     *     signal
     */
    inline QDBusPendingReply<Tp::ContactPresences> GetPresence(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::ContactPresences>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetStatuses" on the remote object.
     * 
     * Get a dictionary of the valid presence statuses for this connection. 
     * This is only available when online because only some statuses will be 
     * available on some servers.
     *
     * \return
     *     
     *     A dictionary of string identifiers mapped to a struct for each 
     *     status, containing: a type value from one of the values above a 
     *     boolean to indicate if this status may be set on yourself a boolean 
     *     to indicate if this is an exclusive status which you may not set 
     *     alongside any other a dictionary of valid optional string argument 
     *     names mapped to their types
     */
    inline QDBusPendingReply<Tp::StatusSpecMap> GetStatuses()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::StatusSpecMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("GetStatuses"));
    }

    /**
     * Begins a call to the D-Bus method "RemoveStatus" on the remote object.
     * 
     * Request that the given presence status is no longer published for the 
     * user. Changes will be indicated by PresenceUpdate signals being 
     * emitted. As with ClearStatus, removing a status may actually result in 
     * it being replaced by a default available status.
     *
     * \param status
     *     
     *     The string identifier of the status not to publish anymore for the 
     *     user
     */
    inline QDBusPendingReply<> RemoveStatus(const QString& status)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status);
        return asyncCallWithArgumentList(QLatin1String("RemoveStatus"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "RequestPresence" on the remote object.
     * 
     * Request the presence for contacts on this connection. A PresenceUpdate 
     * signal will be emitted when they are received. This is not the same as 
     * subscribing to the presence of a contact, which must be done using the 
     * &apos;subscription&apos; ContactList, and on some protocols presence 
     * information may not be available unless a subscription exists.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained
     */
    inline QDBusPendingReply<> RequestPresence(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("RequestPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetLastActivityTime" on the remote object.
     * 
     * Request that the recorded last activity time for the user be updated on 
     * the server.
     *
     * \param time
     *     
     *     A UNIX timestamp of the user&apos;s last activity time (in UTC)
     */
    inline QDBusPendingReply<> SetLastActivityTime(uint time)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(time);
        return asyncCallWithArgumentList(QLatin1String("SetLastActivityTime"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "SetStatus" on the remote object.
     * 
     * <p>Request that the user's presence be changed to the given statuses
     *   and desired parameters. Changes will be reflected by
     *   <tp:member-ref>PresenceUpdate</tp:member-ref>
     *   signals being emitted.</p>
     * 
     * <p>Statuses whose <tp:type>Connection_Presence_Type</tp:type>
     *   is Offline, Error or Unknown MUST NOT be passed to this
     *   function. Connection managers SHOULD reject these statuses.</p>
     * 
     * <tp:rationale>
     *   <p>The same rationale as for <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection.Interface">SimplePresence.SetPresence</tp:dbus-ref>
     *     applies.</p>
     * </tp:rationale>
     * 
     * <p>On certain protocols, this method may be
     *   called on a newly-created connection which is still in the
     *   DISCONNECTED state, and will sign on with the requested status.
     *   If the requested status is not available after signing on,
     *   NotAvailable will be returned and the connection will remain
     *   offline, or if the protocol does not support signing on with
     *   a certain status, Disconnected will be returned.</p>
     *
     * \param statuses
     *     
     *     A dictionary mapping status identifiers to dictionaries, which map 
     *     optional parameter names to their variant-boxed values
     */
    inline QDBusPendingReply<> SetStatus(const Tp::MultipleStatusMap& statuses)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(statuses);
        return asyncCallWithArgumentList(QLatin1String("SetStatus"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "PresenceUpdate" on the remote object.
     * 
     * This signal should be emitted when your own presence has been changed, 
     * or the presence of the member of any of the connection&apos;s channels 
     * has been changed, or when the presence requested by RequestPresence is 
     * available.
     *
     * \param presence
     *     
     *     A dictionary of contact handles mapped to a struct containing a 
     *     UNIX timestamp of the last activity time (in UTC), and a dictionary 
     *     mapping the contact&apos;s current status identifiers to a 
     *     dictionary of optional parameter names mapped to their 
     *     variant-boxed values
     */
    void PresenceUpdate(const Tp::ContactPresences& presence);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceRequestsInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.Requests."
 */
class ConnectionInterfaceRequestsInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.Requests", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.Requests";
    }

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceRequestsInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceRequestsInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceRequestsInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceRequestsInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    ~ConnectionInterfaceRequestsInterface();
    /**
     * Represents property "Channels" on the remote object.
     * 
     * A list of all the channels which currently exist on this connection. 
     * Change notification is via the NewChannels and ChannelClosed signals.
     */
    Q_PROPERTY(Tp::ChannelDetailsList Channels READ Channels)

    /**
     * Getter for the remote object property "Channels".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::ChannelDetailsList Channels() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::ChannelDetailsList>(internalPropGet("Channels"));
    }

    /**
     * Represents property "RequestableChannelClasses" on the remote object.
     * 
     * <p>The classes of channel that are expected to be available on this
     *   connection, i.e. those for which
     *   <tp:member-ref>CreateChannel</tp:member-ref> can reasonably
     *   be expected to succeed. User interfaces can use this information
     *   to show or hide UI components.</p>
     * 
     * <p>This property cannot change after the connection has gone to
     *   state Connection_Status_Connected, so there is no change
     *   notification (if the connection has context-dependent capabilities,
     *   it SHOULD advertise support for all classes of channel that it might
     *   support during its lifetime). Before this state has been reached,
     *   the value of this property is undefined.</p>
     * 
     * <tp:rationale>
     *   <p>This is not on an optional interface, because connection
     *     managers can always offer some sort of clue about the channel
     *     classes they expect to support (at worst, they can announce
     *     support for everything for which they have code).</p>
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::RequestableChannelClassList RequestableChannelClasses READ RequestableChannelClasses)

    /**
     * Getter for the remote object property "RequestableChannelClasses".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::RequestableChannelClassList RequestableChannelClasses() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::RequestableChannelClassList>(internalPropGet("RequestableChannelClasses"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "CreateChannel" on the remote object.
     * 
     * <p>Request that an entirely new channel is created.</p>
     * 
     * <tp:rationale>
     *   <p>There is deliberately no flag corresponding to the
     *     suppress_handler argument to
     *     <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.RequestChannel</tp:dbus-ref>,
     *     because passing a FALSE value for that argument is deprecated.
     *     Requests made using this interface always behave as though
     *     suppress_handler was TRUE.</p>
     * </tp:rationale>
     *
     * \param request
     *     
     *     <p>A dictionary containing desirable properties, which MUST include
     *       <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel">ChannelType</tp:dbus-ref>.
     *       Some properties
     *       are defined such that only an exact match makes sense, and
     *       connection managers MUST NOT satisfy a request with a channel
     *       where that property does not match; some properties are defined
     *       such that the connection manager MAY treat the request as merely
     *       a hint, and make a best-effort attempt to satisfy it. This is
     *       documented separately for each property.</p>
     *     
     *     <p>If this dictionary contains a property whose semantics
     *       are not known to the connection manager, this method MUST fail
     *       without side-effects (in particular it must not create a new
     *       channel).</p>
     *     
     *     <tp:rationale>
     *       <p>This is necessary if we want to be able to invent properties
     *         in future that, when used in a request, are hard requirements
     *         rather than just hints. A connection manager that did not know
     *         the semantics of those properties could incorrectly return a
     *         new channel that did not satisfy the requirements.</p>
     *     </tp:rationale>
     *     
     *     <p>The connection manager MUST NOT respond successfully,
     *       and SHOULD NOT create a new channel or cause any other
     *       side-effects, unless it can create a new channel that satisfies
     *       the client's requirements.</p>
     *     
     *     <p>Properties that will be set by this argument need not have write
     *       access after the channel has been created - indeed, it is
     *       expected that most will be read-only.</p>
     *
     * \return
     *     
     *     <p>The Channel object, which MUST NOT be signalled with
     *       <tp:member-ref>NewChannels</tp:member-ref> until after this method
     *       returns.</p>
     *     
     *     <tp:rationale>
     *       <p>This allows the requester to alter its handling of
     *         NewChannels by knowing whether one of the channels satisfied
     *         a request it made.</p>
     *     </tp:rationale>
     *
     * \return
     *     
     *     <p>Properties of the channel that was produced, equivalent to
     *       the properties in <tp:type>Channel_Details</tp:type>.
     *       Connection managers MUST NOT include properties here whose
     *       values can change, for the same reasons as in
     *       <tp:type>Channel_Details</tp:type>.</p>
     */
    inline QDBusPendingReply<QDBusObjectPath, QVariantMap> CreateChannel(const QVariantMap& request)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QDBusObjectPath, QVariantMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(request);
        return asyncCallWithArgumentList(QLatin1String("CreateChannel"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "EnsureChannel" on the remote object.
     * 
     * <p>Request that channels are ensured to exist.</p>
     * 
     * <tp:rationale>
     *   <p>The connection manager is in the best position to determine which
     *     existing channels could satisfy which requests.</p>
     * </tp:rationale>
     *
     * \param request
     *     
     *     <p>A dictionary containing desirable properties, with the same
     *       semantics as the corresponding parameter to
     *       <tp:member-ref>CreateChannel</tp:member-ref>.</p>
     *
     * \return
     *     
     *     <p>If false, the caller of EnsureChannel MUST assume that some
     *       other process is handling this channel; if true, the caller of
     *       EnsureChannel SHOULD handle it themselves or delegate it to another
     *       client.</p>
     *     
     *     <p>If the creation of a channel makes several calls to EnsureChannel
     *       (and no other requests) successful, exactly one of those calls MUST
     *       return a true value for this argument.</p>
     *     
     *     <p>If the creation of a channel makes other requests successful,
     *       the value returned for this argument MUST be such that exactly
     *       one of the clients making requests ends up responsible for the
     *       channel. In particular, if
     *       <tp:member-ref>CreateChannel</tp:member-ref> returns a channel
     *       <em>C</em>, any EnsureChannel calls that also return <em>C</em>
     *       MUST return a false value for this argument.</p>
     *
     * \return
     *     
     *     The Channel object. If it was created as a result of this method 
     *     call, it MUST NOT be signalled by NewChannels until after this 
     *     method returns. This allows the requester to alter its handling of 
     *     NewChannels by knowing whether one of the channels satisfied a 
     *     request it made.
     *
     * \return
     *     
     *     <p>Properties of the channel that was produced, equivalent to
     *       the properties in <tp:type>Channel_Details</tp:type>.
     *       Connection managers MUST NOT include properties here whose
     *       values can change, for the same reasons as in
     *       <tp:type>Channel_Details</tp:type>.</p>
     */
    inline QDBusPendingReply<bool, QDBusObjectPath, QVariantMap> EnsureChannel(const QVariantMap& request)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<bool, QDBusObjectPath, QVariantMap>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(request);
        return asyncCallWithArgumentList(QLatin1String("EnsureChannel"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "NewChannels" on the remote object.
     * 
     * <p>New channels have been created. The connection manager SHOULD emit
     *   a single signal for any group of closely related channels that are
     *   created at the same time, so that the channel dispatcher can try to
     *   dispatch them to a handler as a unit.</p>
     * 
     * <p>In particular, if additional channels are created as a side-effect
     *   of a call to <tp:member-ref>CreateChannel</tp:member-ref>,
     *   these channels SHOULD appear in the same NewChannels signal as
     *   the channel that satisfies the request.</p>
     * 
     * <tp:rationale>
     *   <p>Joining a MUC Tube in XMPP requires joining the corresponding
     *     MUC (chatroom), so a <tp:dbus-ref namespace="org.freedesktop.Telepathy.Channel.Type">Text</tp:dbus-ref>
     *     channel can be created as a side-effect.</p>
     * </tp:rationale>
     * 
     * <p>Every time NewChannels is emitted, it MUST be followed by
     *   a <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection.NewChannel</tp:dbus-ref>
     *   signal for each channel.</p>
     * 
     * <tp:rationale>
     *   <p>The double signal emission is for the benefit of older Telepathy
     *     clients, which won't be listening for NewChannels.</p>
     * 
     *   <p>The more informative NewChannels signal comes first so that
     *     clients that did not examine the connection to find
     *     out whether Requests is supported will see the more informative
     *     signal for each channel first, and then ignore the less
     *     informative signal because it announces a new channel of which
     *     they are already aware.</p>
     * </tp:rationale>
     *
     * \param channels
     *     
     *     The channels and their details. All channels that are signalled 
     *     together like this MUST have the same Bundle property, which may 
     *     either refer to an existing bundle, or establish a new bundle.
     */
    void NewChannels(const Tp::ChannelDetailsList& channels);

    /**
     * Represents the signal "ChannelClosed" on the remote object.
     * 
     * Emitted when a channel is closed and hence disappears from the Channels 
     * property. This is redundant with the Closed signal on the channel 
     * itself, but it does provide full change notification for the Channels 
     * property.
     *
     * \param removed
     *     
     *     The channel which has been removed from the Channels property
     */
    void ChannelClosed(const QDBusObjectPath& removed);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class ConnectionInterfaceSimplePresenceInterface
 * \headerfile TelepathyQt4/connection.h "../Connection"
 * \ingroup clientconn
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Connection.Interface.SimplePresence."
 */
class ConnectionInterfaceSimplePresenceInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Connection.Interface.SimplePresence", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Connection.Interface.SimplePresence";
    }

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    ConnectionInterfaceSimplePresenceInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit ConnectionInterfaceSimplePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface);

    /**
     * Creates a ConnectionInterfaceSimplePresenceInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    ConnectionInterfaceSimplePresenceInterface(const Tp::Client::ConnectionInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Statuses" on the remote object.
     * 
     * <p>A dictionary where the keys are the presence statuses that are
     *   available on this connection, and the values are the corresponding
     *   presence types.</p>
     * 
     * <p>While the connection is in the DISCONNECTED state, it contains
     *   the set of presence statuses allowed to be set before connecting.
     *   The connection manager will attempt to set the appropriate status
     *   when the connection becomes connected, but cannot necessarily
     *   guarantee it. The available statuses cannot change until the
     *   connection status changes, so there is no change notification.</p>
     * 
     * <p>While the connection is in the CONNECTED state, this property
     *   contains the set of presence statuses which are actually available
     *   on this protocol. This set is constant for the remaining lifetime
     *   of the connection, so again, there is no change notification.</p>
     * 
     * <p>While the connection is in the CONNECTING state, the value of
     *   this property is undefined and SHOULD NOT be used. It can change
     *   at any time without notification (in particular, any cached values
     *   from when the connection was in the DISCONNECTED or CONNECTING
     *   state MUST NOT be assumed to still be correct when the state has
     *   become CONNECTED).</p>
     * 
     * <p>This property MUST include the special statuses &quot;unknown&quot; and
     *   &quot;error&quot; if and only if the connection manager can emit them
     *   as a contact's status.</p>
     * 
     * <tp:rationale>
     *   For instance, connection managers for local-xmpp (XEP-0174) would
     *   omit &quot;unknown&quot; since there is no such concept.
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::SimpleStatusSpecMap Statuses READ Statuses)

    /**
     * Getter for the remote object property "Statuses".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SimpleStatusSpecMap Statuses() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SimpleStatusSpecMap>(internalPropGet("Statuses"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "SetPresence" on the remote object.
     * 
     * <p>Request that the presence status and status message are published for
     *   the connection.  Changes will be indicated by
     *   <tp:member-ref>PresencesChanged</tp:member-ref>
     *   signals being emitted.</p>
     * 
     * <p>This method may be called on a newly-created connection while it
     *   is still in the DISCONNECTED state, to request that when the
     *   connection connects, it will do so with the selected status.</p>
     * 
     * <p>In DISCONNECTED state the
     *   <tp:member-ref>Statuses</tp:member-ref>
     *   property will indicate which statuses are allowed to be set
     *   while DISCONNECTED (none, if the Connection Manager doesn't allow
     *   this). This value MUST NOT be cached, as the set of allowed
     *   presences might change upon connecting.</p>
     *
     * \param status
     *     
     *     <p>The string identifier of the desired status. Possible status
     *       identifiers are defined in the
     *       <tp:member-ref>Statuses</tp:member-ref> property.</p>
     *     
     *     <p>Clients MUST NOT set a status whose string value they do not
     *       recognise, even if its presence type in Statuses
     *       matches what the user requested.</p>
     *     
     *     <tp:rationale>
     *       <p>Suppose a protocol has statuses that include 'phone' (of type
     *         BUSY) and 'in-a-meeting' (of type BUSY), but there is no
     *         generic 'busy' status.</p>
     *     
     *       <p>If the user requests &quot;Busy&quot; status from a menu, a
     *         client author might be tempted to pick an arbitrary status
     *         that has type BUSY. However, on this protocol, neither of
     *         the choices would be appropriate, and incorrect information
     *         about the user would be conveyed.</p>
     *     </tp:rationale>
     *     
     *     <p>Statuses whose <tp:type>Connection_Presence_Type</tp:type>
     *       is Offline, Error or Unknown MUST NOT be passed to this
     *       function. Connection managers SHOULD reject these statuses.</p>
     *     
     *     <tp:rationale>
     *       <p>To go offline, call <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">Disconnect</tp:dbus-ref>
     *       instead. The &quot;error&quot; and &quot;unknown&quot; statuses make no sense.</p>
     *     </tp:rationale>
     *
     * \param statusMessage
     *     
     *     The status message associated with the current status.
     */
    inline QDBusPendingReply<> SetPresence(const QString& status, const QString& statusMessage)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(status) << QVariant::fromValue(statusMessage);
        return asyncCallWithArgumentList(QLatin1String("SetPresence"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "GetPresences" on the remote object.
     * 
     * Get presence previously emitted by PresencesChanged for the given 
     * contacts. Data is returned in the same structure as the 
     * PresencesChanged signal; no additional network requests are made.
     *
     * \param contacts
     *     
     *     An array of the contacts whose presence should be obtained.
     *
     * \return
     *     
     *     <p>Presence information in the same format as for the
     *       <tp:member-ref>PresencesChanged</tp:member-ref> signal.
     *       The returned mapping MUST include an entry for each contact
     *       in the method's argument.</p>
     *     
     *     <p>The definition of the connection presence types Unknown
     *       and Offline means that if a connection manager will return
     *       Unknown for contacts not on the subscribe list, it MUST delay
     *       the reply to this method call until it has found out which
     *       contacts are, in fact, on the subscribe list.</p>
     */
    inline QDBusPendingReply<Tp::SimpleContactPresences> GetPresences(const Tp::UIntList& contacts)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<Tp::SimpleContactPresences>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(contacts);
        return asyncCallWithArgumentList(QLatin1String("GetPresences"), argumentList);
    }

Q_SIGNALS:
    /**
     * Represents the signal "PresencesChanged" on the remote object.
     * 
     * This signal should be emitted when your own presence has been changed, 
     * or the presence of the member of any of the connection&apos;s channels 
     * has been changed.
     *
     * \param presence
     *     
     *     A dictionary of contact handles mapped to the status, presence type 
     *     and status message.
     */
    void PresencesChanged(const Tp::SimpleContactPresences& presence);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};
}
}
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceAliasingInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceAvatarsInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceBalanceInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceCapabilitiesInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceContactCapabilitiesInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceContactInfoInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceContactsInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceLocationInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfacePresenceInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceRequestsInterface*)
Q_DECLARE_METATYPE(Tp::Client::ConnectionInterfaceSimplePresenceInterface*)

#endif //#ifndef CLI_CONNECTION_H
