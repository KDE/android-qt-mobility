/*
 * This file contains D-Bus client proxy classes generated by qt4-client-gen.py.
 *
 * This file can be distributed under the same terms as the specification from
 * which it was generated.
 */

#ifndef CLI_ACCOUNT_H
#define CLI_ACCOUNT_H

#include <QtCore/QtGlobal>

#include <QtCore/QString>
#include <QtCore/QObject>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

#include "maemo/interfaces/cli-types.h"
#include "maemo/interfaces/abstract-interface.h"
#include "maemo/dbus-proxy.h"

// basically the same as GLib's G_GNUC_DEPRECATED
#ifndef TELEPATHY_GNUC_DEPRECATED
#   if defined(Q_CC_GNUC) && __GNUC__ >= 4
#       define TELEPATHY_GNUC_DEPRECATED __attribute__((__deprecated__))
#   else
#       define TELEPATHY_GNUC_DEPRECATED
#   endif
#endif
namespace Tp
{
namespace Client
{

/**
 * \class AccountInterface
 * \headerfile TelepathyQt4/account.h "../AccountManager"
 * \ingroup clientaccount
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Account."
 */
class AccountInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Account", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Account";
    }

    /**
     * Creates a AccountInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    AccountInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a AccountInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    AccountInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a AccountInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    AccountInterface(Tp::DBusProxy *proxy);

    /**
     * Represents property "Interfaces" on the remote object.
     * 
     * A list of the extra interfaces provided by this account.
     */
    Q_PROPERTY(QStringList Interfaces READ Interfaces)

    /**
     * Getter for the remote object property "Interfaces".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QStringList Interfaces() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QStringList>(internalPropGet("Interfaces"));
    }

    /**
     * Represents property "DisplayName" on the remote object.
     * 
     * The user-visible name of this account. This SHOULD be chosen by the 
     * user at account creation time. The account creation user interface is 
     * responsible for setting a reasonable default value in the user&apos;s 
     * locale; something like &quot;Jabber (bob@example.com)&quot; would be 
     * sensible. This approximately corresponds to &quot;display name&quot; in 
     * NMC 4.x and Decibel.
     */
    Q_PROPERTY(QString DisplayName READ DisplayName WRITE setDisplayName)

    /**
     * Getter for the remote object property "DisplayName".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString DisplayName() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("DisplayName"));
    }

    /**
     * Setter for the remote object property "DisplayName".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setDisplayName(const QString& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("DisplayName", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "Icon" on the remote object.
     * 
     * The name of an icon in the system&apos;s icon theme, such as 
     * &quot;im-msn&quot;, or the empty string to not specify an icon. If the 
     * icon is set to an empty string, the account manager or any client MAY 
     * derive a default icon, for instance from the protocol. This 
     * approximately corresponds to mc_profile_get_icon_name (or possibly 
     * mc_profile_get_branding_icon_name) in NMC 4.x. It&apos;s accessed via 
     * the account rather than the profile because we no longer have profiles 
     * as a core concept.
     */
    Q_PROPERTY(QString Icon READ Icon WRITE setIcon)

    /**
     * Getter for the remote object property "Icon".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Icon() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Icon"));
    }

    /**
     * Setter for the remote object property "Icon".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setIcon(const QString& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("Icon", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "Valid" on the remote object.
     * 
     * If true, this account is considered by the account manager to be 
     * complete and usable. If false, user action is required to make it 
     * usable, and it will never attempt to connect (for instance, this might 
     * be caused by the absence of a required parameter). For connection 
     * managers with a plugin architecture, like telepathy-haze, we have 
     * little or no control over the parameters offered; for platforms with 
     * package management, we have little or no control over the CMs offered. 
     * NMC 4.x would just pretend the account didn&apos;t exist in these 
     * circumstances, but silent data loss is bad, and UIs with CM-specific 
     * knowledge (or a user filling in newly-required parameters) might be 
     * able to rescue a broken account.
     */
    Q_PROPERTY(bool Valid READ Valid)

    /**
     * Getter for the remote object property "Valid".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool Valid() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("Valid"));
    }

    /**
     * Represents property "Enabled" on the remote object.
     * 
     * <p>This property gives the users the possibility to prevent an account
     *   from being used. This flag does not change the validity of the
     *   account.</p>
     * 
     * <p>A disabled account can never be put online.</p>
     * 
     * <tp:rationale>
     *   <p>Use cases:</p>
     * 
     *   <ul>
     *     <li>user has two or more accounts capable of calling contact X, but
     *       he doesn't want the UI to prompt him everytime about which one he
     *       wants to use for the call. He can then disable all the equivalent
     *       accounts but one.</li>
     * 
     *     <li>There is some temporary server error and the user doesn't want
     *       to be be bother by error messages, or change the account
     *       configuration: temporarily disabling the account is quicker.</li>
     *   </ul>
     * </tp:rationale>
     * 
     * <p>The AccountManager SHOULD allow this property to be set on invalid
     *   accounts, but MUST NOT attempt to put invalid accounts online
     *   even if they become Enabled.</p>
     * 
     * <tp:rationale>
     *   <p>There doesn't seem to be any good reason not to allow this.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(bool Enabled READ Enabled WRITE setEnabled)

    /**
     * Getter for the remote object property "Enabled".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool Enabled() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("Enabled"));
    }

    /**
     * Setter for the remote object property "Enabled".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setEnabled(bool newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("Enabled", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "Nickname" on the remote object.
     * 
     * The nickname to set on this account for display to other contacts, as 
     * set by the user. When the account becomes connected, the account 
     * manager SHOULD set this as the user&apos;s alias using SetAliases if 
     * appropriate. In a later specification revision, we plan to separate the 
     * concepts of a contact&apos;s nickname as set by themselves, and the 
     * local name for them in our contact list (a &quot;handle&quot; or 
     * &quot;pet name&quot; as described in XEP-0165 and its references). The 
     * terminology change from alias to nickname here is a step in that 
     * direction. This corresponds to NMC 4.x mc_account_get_alias.
     */
    Q_PROPERTY(QString Nickname READ Nickname WRITE setNickname)

    /**
     * Getter for the remote object property "Nickname".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString Nickname() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("Nickname"));
    }

    /**
     * Setter for the remote object property "Nickname".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setNickname(const QString& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("Nickname", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "Parameters" on the remote object.
     * 
     * <p>A map from connection manager parameter names (as in the
     *   <tp:dbus-ref namespace="org.freedesktop.Telepathy">ConnectionManager</tp:dbus-ref>
     *   interface) to their values. This property includes
     *   only those parameters that are stored for this account, and SHOULD
     *   only include those parameters that the user has explicitly set.
     * </p>
     * <p>This property cannot be altered using Set() - use
     *   <tp:member-ref>UpdateParameters</tp:member-ref> instead.</p>
     * 
     * <tp:rationale>
     *   This avoids NMC being tied to gconf as a matter of API.
     * </tp:rationale>
     */
    Q_PROPERTY(QVariantMap Parameters READ Parameters)

    /**
     * Getter for the remote object property "Parameters".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QVariantMap Parameters() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QVariantMap>(internalPropGet("Parameters"));
    }

    /**
     * Represents property "AutomaticPresence" on the remote object.
     * 
     * <p>The presence status that this account should have if it is brought
     *   online.</p>
     * 
     * <p>Setting this property MUST NOT actually change the account's
     *   status until the next time it is (re)connected for some reason.</p>
     * 
     * <p>The <tp:type>Connection_Presence_Type</tp:type> in the structure
     *   SHOULD NOT be Offline or Unset.</p>
     * 
     * <tp:rationale>
     *   In ITOS2007 and ITOS2008 this is a global preference, not visible
     *   on D-Bus (the &quot;default presence&quot;). &quot;Automatic presence&quot; better
     *   describes when it is used.
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::SimplePresence AutomaticPresence READ AutomaticPresence WRITE setAutomaticPresence)

    /**
     * Getter for the remote object property "AutomaticPresence".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SimplePresence AutomaticPresence() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SimplePresence>(internalPropGet("AutomaticPresence"));
    }

    /**
     * Setter for the remote object property "AutomaticPresence".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setAutomaticPresence(const Tp::SimplePresence& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("AutomaticPresence", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "ConnectAutomatically" on the remote object.
     * 
     * If true, the account manager SHOULD attempt to put this account online 
     * with the AutomaticPresence whenever possible (in the base Account 
     * interface this is deliberately left vague). If false, it MUST NOT put 
     * the account online automatically in response to, for instance, 
     * connectivity changes, but SHOULD still put the account online with the 
     * AutomaticPresence if requested by the user (for instance, if the user 
     * tries to start a conversation using this account). This approximately 
     * corresponds to NMC 4.x &quot;enabled&quot; and Decibel 
     * &quot;autoreconnect&quot;.
     */
    Q_PROPERTY(bool ConnectAutomatically READ ConnectAutomatically WRITE setConnectAutomatically)

    /**
     * Getter for the remote object property "ConnectAutomatically".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool ConnectAutomatically() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("ConnectAutomatically"));
    }

    /**
     * Setter for the remote object property "ConnectAutomatically".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setConnectAutomatically(bool newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("ConnectAutomatically", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "Connection" on the remote object.
     * 
     * <p>Either the object path of the <tp:dbus-ref namespace="org.freedesktop.Telepathy">Connection</tp:dbus-ref> to
     * this account, or the special value <code>'/'</code> if there is no
     * connection.</p>
     * 
     * <p>If this object path is not '/', the Connection's well-known bus
     *   name can be derived from this object path by removing the first '/'
     *   and replacing subsequent '/' characters with '.'.</p>
     * 
     * <tp:rationale>
     *   Object paths aren't nullable, so we can't use an empty string.
     * </tp:rationale>
     */
    Q_PROPERTY(QDBusObjectPath Connection READ Connection)

    /**
     * Getter for the remote object property "Connection".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QDBusObjectPath Connection() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QDBusObjectPath>(internalPropGet("Connection"));
    }

    /**
     * Represents property "ConnectionStatus" on the remote object.
     * 
     * If the Connection property is non-empty, the status of that connection. 
     * If the Connection property is the empty string, this property may 
     * either be Disconnected (indicating that the account manager is not 
     * attempting to bring it online), or Connecting (indicating that the 
     * account manager is attempting to connect). The account manager is 
     * expected to set this by observing signals from the Connection. If the 
     * AM is doing some sort of backoff/delay on reconnection attempts, the 
     * account&apos;s status is conceptually &quot;Connecting&quot; even 
     * though there is no Connection. This vaguely corresponds to 
     * GetCurrentStatus in NMC 4.x.
     */
    Q_PROPERTY(uint ConnectionStatus READ ConnectionStatus)

    /**
     * Getter for the remote object property "ConnectionStatus".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint ConnectionStatus() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("ConnectionStatus"));
    }

    /**
     * Represents property "ConnectionStatusReason" on the remote object.
     * 
     * The reason for the last change to ConnectionStatus. The account manager 
     * is expected to set this by observing signals from the Connection. If 
     * you weren&apos;t watching the Connection at the time it failed, you 
     * can&apos;t tell why - unless the AM can tell you. This is part of 
     * GetCurrentStatus in NMC 4.x.
     */
    Q_PROPERTY(uint ConnectionStatusReason READ ConnectionStatusReason)

    /**
     * Getter for the remote object property "ConnectionStatusReason".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline uint ConnectionStatusReason() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<uint>(internalPropGet("ConnectionStatusReason"));
    }

    /**
     * Represents property "CurrentPresence" on the remote object.
     * 
     * The actual presence. If the connection is not online, this should be 
     * (Connection_Presence_Type_Offline, &quot;&quot;, &quot;&quot;). If the 
     * connection is online but does not support the SimplePresence interface, 
     * this should be (Connection_Presence_Type_Unset, &quot;&quot;, 
     * &quot;&quot;). The account manager is expected to set this by observing 
     * signals from the Connection. This corresponds to GetPresenceActual in 
     * NMC 4.x.
     */
    Q_PROPERTY(Tp::SimplePresence CurrentPresence READ CurrentPresence)

    /**
     * Getter for the remote object property "CurrentPresence".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SimplePresence CurrentPresence() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SimplePresence>(internalPropGet("CurrentPresence"));
    }

    /**
     * Represents property "RequestedPresence" on the remote object.
     * 
     * <p>The requested presence for this account. When this is changed, the
     * account manager should attempt to manipulate the connection manager to
     * make <tp:member-ref>CurrentPresence</tp:member-ref> match
     * <tp:member-ref>RequestedPresence</tp:member-ref> as closely as
     *   possible. It should not be saved to any sort of persistent
     *   storage.</p>
     * 
     * <p>When the account manager automatically connects an account,
     *   it must signal this by setting the RequestedPresence to the same
     *   thing as the <tp:member-ref>AutomaticPresence</tp:member-ref>.</p>
     * 
     * <tp:rationale>
     *   This corresponds to e.g. GetPresence and GetPresenceMessage
     *   in NMC 4.x.
     * </tp:rationale>
     */
    Q_PROPERTY(Tp::SimplePresence RequestedPresence READ RequestedPresence WRITE setRequestedPresence)

    /**
     * Getter for the remote object property "RequestedPresence".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::SimplePresence RequestedPresence() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::SimplePresence>(internalPropGet("RequestedPresence"));
    }

    /**
     * Setter for the remote object property "RequestedPresence".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setRequestedPresence(const Tp::SimplePresence& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("RequestedPresence", QVariant::fromValue(newValue));
    }

    /**
     * Represents property "NormalizedName" on the remote object.
     * 
     * <p>The normalized user ID of the local user on this account (i.e. the
     *   string returned when the <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">InspectHandles</tp:dbus-ref>
     *   method is called on the
     *   result of <tp:dbus-ref namespace="org.freedesktop.Telepathy.Connection">GetSelfHandle</tp:dbus-ref>
     *   for an active connection).</p>
     * 
     * <p>It is unspecified whether this user ID is globally unique.</p>
     * 
     * <tp:rationale>
     *   <p>As currently implemented, IRC user IDs are only unique within
     *     the same IRCnet. On some saner protocols, the user ID includes a
     *     DNS name which provides global uniqueness.</p>
     * </tp:rationale>
     * 
     * <p>If this value is not known yet (which will always be the case for
     *   accounts that have never been online), it will be an empty
     *   string.</p>
     * 
     * <p>It is possible that this value will change if the connection
     *   manager's normalization algorithm changes, although this SHOULD
     *   be avoided.</p>
     * 
     * <tp:rationale>
     *   <p>It's not always completely clear what normalization algorithm
     *     should be used; for instance, in Gabble, we currently use JIDs,
     *     but it would also have been reasonable to use xmpp URIs.</p>
     * </tp:rationale>
     */
    Q_PROPERTY(QString NormalizedName READ NormalizedName)

    /**
     * Getter for the remote object property "NormalizedName".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline QString NormalizedName() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<QString>(internalPropGet("NormalizedName"));
    }

    /**
     * Represents property "HasBeenOnline" on the remote object.
     * 
     * If true, this account has successfully been put online at some point in 
     * the past. UIs could apply a policy that the &apos;account&apos; 
     * parameter can only be edited in accounts that have never been online, 
     * or that ConnectAutomatically cannot be set on such accounts. The 
     * account manager should not enforce such policies, but it can expose 
     * enough information to UIs that the UI can decide what to do.
     */
    Q_PROPERTY(bool HasBeenOnline READ HasBeenOnline)

    /**
     * Getter for the remote object property "HasBeenOnline".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline bool HasBeenOnline() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<bool>(internalPropGet("HasBeenOnline"));
    }

public Q_SLOTS:
    /**
     * Begins a call to the D-Bus method "Remove" on the remote object.
     * 
     * Delete the account.
     */
    inline QDBusPendingReply<> Remove()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Remove"));
    }

    /**
     * Begins a call to the D-Bus method "UpdateParameters" on the remote object.
     * 
     * <p>Change the value of the <tp:member-ref>Parameters</tp:member-ref>
     *   property.</p>
     * 
     * <p>If any of the changed parameters'
     *   <tp:type>Conn_Mgr_Param_Flags</tp:type> include
     *   <code>DBus_Property</code>, the change will be applied to the
     *   corresponding D-Bus Property on the active
     *   <tp:member-ref>Connection</tp:member-ref>, if there is one. Changes to
     *   other parameters will not take effect until the next time the account
     *   is disconnected and reconnected.</p>
     * 
     * <tp:rationale>
     *   <p>In general, reconnecting is a destructive operation that shouldn't
     *     happen as a side-effect. In particular, migration tools that
     *     twiddle the settings of all accounts shouldn't cause an automatic
     *     disconnect and reconnect.</p>
     * </tp:rationale>
     *
     * \param set
     *     
     *     A mapping from parameter names to their values. These parameters 
     *     should be stored for future use.
     *
     * \param unset
     *     
     *     A list of the names of parameters to be removed from the set of 
     *     stored values, allowing the default values to be used. If the given 
     *     parameters were not, in fact, stored, or even if they do not exist 
     *     at all, the account manager MUST accept this without error.
     *
     * \return
     *     
     *     A list of the names of parameters with changes that will not take 
     *     effect until the account is reconnected (this may be empty, e.g. if 
     *     all the parameters are D-Bus properties or parameters for which the 
     *     account manager has specific support). User interfaces that require 
     *     &quot;instant apply&quot; semantics MAY call Reconnect in response 
     *     to receiving a non-empty list.
     */
    inline QDBusPendingReply<QStringList> UpdateParameters(const QVariantMap& set, const QStringList& unset)
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<QStringList>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(set) << QVariant::fromValue(unset);
        return asyncCallWithArgumentList(QLatin1String("UpdateParameters"), argumentList);
    }

    /**
     * Begins a call to the D-Bus method "Reconnect" on the remote object.
     * 
     * <p>Re-connect this account. If the account is currently disconnected
     *   and the requested presence is offline, or if the account
     *   is not <tp:member-ref>Enabled</tp:member-ref> or not
     *   <tp:member-ref>Valid</tp:member-ref>, this does nothing.</p>
     * 
     * <p>If the account is disconnected and the requested presence is not
     *   offline, this forces an attempt to connect with the requested
     *   presence immediately.</p>
     * 
     * <p>If the account is connecting or connected, this is equivalent to
     *   remembering the current value of
     *   <tp:member-ref>RequestedPresence</tp:member-ref>, setting its value
     *   to (OFFLINE, &quot;offline&quot;, &quot;&quot;), waiting for the change to take effect,
     *   then setting its value to the value that was previously
     *   remembered.</p>
     * 
     * <tp:rationale>
     *   <p>Clients desiring &quot;instant apply&quot; semantics for CM parameters MAY
     *     call this method to achieve that.</p>
     * </tp:rationale>
     * 
     * <p>In particular, if the account's
     *   <tp:member-ref>Connection</tp:member-ref> is in the Connecting
     *   state, calling this method causes the attempt to connect to be
     *   aborted and re-tried.</p>
     * 
     * <tp:rationale>
     *   <p>This is necessary to ensure that the new parameters are
     *     picked up.</p>
     * </tp:rationale>
     */
    inline QDBusPendingReply<> Reconnect()
    {
        if (!invalidationReason().isEmpty()) {
            return QDBusPendingReply<>(QDBusMessage::createError(
                invalidationReason(),
                invalidationMessage()
            ));
        }


        return asyncCall(QLatin1String("Reconnect"));
    }

Q_SIGNALS:
    /**
     * Represents the signal "Removed" on the remote object.
     * 
     * This account has been removed. This is redundant with AccountRemoved, 
     * but it&apos;s still worth having, to avoid having to bind to 
     * AccountManager.AccountRemoved to tell you whether your Account is valid 
     * — ideally, an account-editing UI should only care about a single 
     * Account.
     */
    void Removed();

    /**
     * Represents the signal "AccountPropertyChanged" on the remote object.
     * 
     * The values of one or more properties on this interface (that do not 
     * specify that this signal does not apply to them) may have changed. This 
     * does not cover properties of other interfaces, which must provide their 
     * own change notification if appropriate.
     *
     * \param properties
     *     
     *     A map from property names in this namespace (e.g. Nickname) to 
     *     values. Properties whose values have not changed SHOULD be omitted, 
     *     but this need not be done.
     */
    void AccountPropertyChanged(const QVariantMap& properties);

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};

/**
 * \class AccountInterfaceAvatarInterface
 * \headerfile TelepathyQt4/account.h "../AccountManager"
 * \ingroup clientaccount
 *
 * Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Account.Interface.Avatar."
 */
class AccountInterfaceAvatarInterface : public Tp::AbstractInterface
{
    Q_OBJECT

public:
    /**
     * Returns the name of the interface "org.freedesktop.Telepathy.Account.Interface.Avatar", which this class
     * represents.
     *
     * \return The D-Bus interface name.
     */
    static inline const char *staticInterfaceName()
    {
        return "org.freedesktop.Telepathy.Account.Interface.Avatar";
    }

    /**
     * Creates a AccountInterfaceAvatarInterface associated with the given object on the session bus.
     *
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    AccountInterfaceAvatarInterface(
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a AccountInterfaceAvatarInterface associated with the given object on the given bus.
     *
     * \param connection The bus via which the object can be reached.
     * \param busName Name of the service the object is on.
     * \param objectPath Path to the object on the service.
     * \param parent Passed to the parent class constructor.
     */
    AccountInterfaceAvatarInterface(
        const QDBusConnection& connection,
        const QString& busName,
        const QString& objectPath,
        QObject* parent = 0
    );

    /**
     * Creates a AccountInterfaceAvatarInterface associated with the same object as the given proxy.
     *
     * \param proxy The proxy to use. It will also be the QObject::parent()
     *               for this object.
     */
    AccountInterfaceAvatarInterface(Tp::DBusProxy *proxy);

    /**
     * Creates a AccountInterfaceAvatarInterface associated with the same object as the given proxy.
     * Additionally, the created proxy will have the same parent as the given
     * proxy.
     *
     * \param mainInterface The proxy to use.
     */
    explicit AccountInterfaceAvatarInterface(const Tp::Client::AccountInterface& mainInterface);

    /**
     * Creates a AccountInterfaceAvatarInterface associated with the same object as the given proxy.
     * However, a different parent object can be specified.
     *
     * \param mainInterface The proxy to use.
     * \param parent Passed to the parent class constructor.
     */
    AccountInterfaceAvatarInterface(const Tp::Client::AccountInterface& mainInterface, QObject* parent);

    /**
     * Represents property "Avatar" on the remote object.
     * 
     * The avatar to set on this account for display to other contacts, 
     * represented as a structure containing the bytes of the avatar, and the 
     * MIME type as a string; may be set to an empty byte-array and an empty 
     * string to indicate no avatar. When the account becomes connected, the 
     * account manager SHOULD set this avatar using SetAvatar if appropriate. 
     * This corresponds to NMC 4.x mc_account_get_avatar.
     */
    Q_PROPERTY(Tp::Avatar Avatar READ Avatar WRITE setAvatar)

    /**
     * Getter for the remote object property "Avatar".
     *
     * Don't use this: it blocks the main loop.
     *
     * \return The value of the property, or a default-constructed value
     *          if the property is not readable.
     */
    inline Tp::Avatar Avatar() const TELEPATHY_GNUC_DEPRECATED
    {
        return qvariant_cast<Tp::Avatar>(internalPropGet("Avatar"));
    }

    /**
     * Setter for the remote object property "Avatar".
     *
     * Don't use this: it blocks the main loop.
     *
     * \param newValue The value to set the property to.
     */
    inline void setAvatar(const Tp::Avatar& newValue) TELEPATHY_GNUC_DEPRECATED
    {
        internalPropSet("Avatar", QVariant::fromValue(newValue));
    }

Q_SIGNALS:
    /**
     * Represents the signal "AvatarChanged" on the remote object.
     * 
     * Emitted when the Avatar property changes. The avatar itself is 
     * deliberately not included in this signal, to reduce bus traffic in the 
     * (likely common) case where no running application cares about the 
     * user&apos;s own avatar.
     */
    void AvatarChanged();

protected:
    virtual void invalidate(Tp::DBusProxy *, const QString &, const QString &);
};
}
}
Q_DECLARE_METATYPE(Tp::Client::AccountInterface*)
Q_DECLARE_METATYPE(Tp::Client::AccountInterfaceAvatarInterface*)

#endif //#ifndef CLI_ACCOUNT_H

